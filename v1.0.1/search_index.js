var documenterSearchIndex = {"docs":
[{"location":"fitting/fitting_intro/#fitting","page":"Background and Template Construction","title":"Background and Template Construction","text":"","category":"section"},{"location":"fitting/fitting_intro/#Background","page":"Background and Template Construction","title":"Background","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"In the classic formulation of star formation history fitting from resolved-star photometry (Dolphin 2002), an observed color-magnitude diagram (CMD) is binned into a 2-D histogram known as a Hess diagram. Such a CMD and Hess diagram pair is shown below.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"(Image: Comparison of CMD and a Hess diagram generated from the same observational data.)","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The representation of the observations as a Hess diagram allows one to apply Poisson statistics, specifically the Poisson likelihood ratio (Equations 7–10 in Dolphin 2002), to model the observations. As the CMD of a complex stellar population is simply the sum of the CMDs of its sub-populations, one need only prepare a number of templates for each simple stellar population (SSP) which may make up the complex population in question and model the observed Hess diagram as a linear combination of these templates. Keeping the same notation as Dolphin 2002 (Equation 1), the complex model Hess diagram is simply","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"m_i = sum_j  r_j  c_ij","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"where m_i is the value of the complex model in bin i, c_ij is the value of simple template j in bin i, and r_j is the multiplicative coefficient determining how significant template j is to the complex population. In Dolphin 2002, he normalizes the templates to identical star formation rates (SFRs) and so the r_j are SFRs as well. In this package, we prefer to normalize our templates to identical population stellar masses, so our r_j are stellar masses, but the principal is the same.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Construction of the templates is, however, not a trivial exercise. Ideally, a template constructed to represent a particular SSP would accurately reflect the expectation of how such a population would be observed. Thus, these templates must be adjusted for photometric error, incompleteness, and other effects such as those caused by unresolved binary- and multi-star systems. Observational effects such as photometric error and incompleteness are best measured from artificial star tests (ASTs). It is worth mentioning that ASTs can often return \"best case\" results, as they typically neglect systematics like uncertainty in the point-spread model used for the photometry; as such it is sometimes necessary to add a systematic error floor to photometric error results from ASTs.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Such templates can be constructed by sampling many mock stars from an initial mass function (IMF), interpolating their absolute magnitudes from an isochrone of the relevant SSP, and \"mock observing\" them by applying photometric error and completeness functions (for example, by looking up the 1sigma photometric error and completeness value from a catalog of artificial stars). Such Monte Carlo templates can be slow to construct and exhibit Poisson shot-noise, requiring a statistical data–data comparison rather than a model–data comparison. Thus this method is non-optimal from both a practical and statistical perspective.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"It is better to form what Dolphin 2002 calls a \"blurred isochrone;\" in this form of template, the SSP isochrone is first interpolated in initial stellar mass to improve the point density along the isochrone. The number of interpolated points is generally a function of the size of the bins in the Hess diagram and the observational error; more points are required as the bin size or photometric errors become smaller. These points are then weighted according to the IMF and the photometric completeness, and this weight is distributed into the Hess diagram following the photometric error distribution determined by similar artificial stars. Dolphin 2002 also mentions interpolating across stellar age/metallicity when constructing such templates; for example, for an SSP with an age of 1 Gyr and a metallicity of [M/H]=-1.0, you could interpolate the isochrones to introduce a Gaussian metallicity spread of 0.05 dex or an age spread of 100 Myr. The general effects of this form of interpolation is to broaden the model templates, particularly features that are very sharp in true SSP models. We neglect this form of interpolation in our implementation as it adds significant complexity and requires users to provide more information about the isochrones that are providing. Such widening of the individual templates is most impactful when photometric errors in the observational data are low (perhaps <0.10 mag).","category":"page"},{"location":"fitting/fitting_intro/#templates","page":"Background and Template Construction","title":"Constructing Templates","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"While the above description summarizes the necessary components for constructing such a blurred isochrone, it can be a bit difficult to figure out how best to actually construct them. Specifically there are many ways that one could implement the observational effects of photometric error and incompleteness. We provide a method partial_cmd_smooth to construct such templates under the assumption of Gaussian photometric error distributions, which is often a good approximation in the high-completeness regime. This method makes use of user-defined functions for the mean photometric error and completeness as a function of magnitude and filter, such that these can be defined in a number of ways; for example, as direct lookups from a large table of ASTs or as simple function evaluations of analytic approximations or fits to the ASTs.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"This method begins by interpolating the provided SSP isochrone to increase point density. For every such point with i band apparent magnitude m_i, it calls a user-defined function to estimate the 1sigma photometric error as sigma_i = f_i(m_i). This is done for each provided photometric filter. These errors are used to define an asymmetric 2-D Gaussian kernel for each point in the interpolated isochrone. This kernel describes the probability distribution of where the isochrone point would be observed in the Hess diagram. The shape of the kernel is automatically adjusted to account for covariance when the magnitude on the y-axis of the Hess diagram also appears in the x-axis color, as occurs when only two filters of imaging are available (for example, an x-axis of B-V and a y-axis magnitude of V). Details on these kernels are given here. However, the kernel also must be normalized (weighted) according to the IMF and observational completeness functions.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Assume that the vector of initial stellar masses for the points in the interpolated isochrone are m_i and that they are sorted such that m_i  m_i+1. The IMF weight on point m_i can be approximated as the number fraction of stars born between m_i and m_i+1 divided by the mean mass per star born langle m rangle, such that the weight effectively represents the number of stars expected to be born with masses between m_i and m_i+1 per solar mass of star formation:","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"beginaligned\nw_itextIMF = frac int_0^m_i+1 fracdN(m)dm dm - int_0^m_i fracdN(m)dm dm int_0^infty m times fracdN(m)dm dm = frac int_m_i^m_i+1 fracdN(m)dm dm langle m rangle\nendaligned","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The numerator can either be calculated as the difference in the cumulative distribution function across the bin or approximated efficiently via the trapezoidal rule. The denominator is a function only of the IMF and need only be calculated once. Multiplying this weight by the probability of detection in the relevant bands gives the final weight.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"mv(\"../../../examples/templates/template_compare.svg\", \"figures/template_compare.svg\") # hide\nmv(\"../../../examples/templates/sigma_distribution.svg\", \"figures/sigma_distribution.svg\") # hide\nnothing # hide","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"A worked example comparing a sampled stellar population with a smooth Hess diagram template is available in examples/templates/smooth_template.jl. The smooth Hess diagram template is constructed with partial_cmd_smooth and the Monte Carlo population is sampled with generate_stars_mass, with observational effects modelled by model_cmd. The isochrone used comes from PARSEC and has an age of 12.6 Gyr and initial metallicity [M/H] of -2.8. The output figure is shown below. A distance modulus of 25 mag is used for this example, with photometric error and completeness functions roughly based on those we observe in the JWST/NIRCAM data of WLM (see Weisz et al. 2024).","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"(Image: Comparison of CMD-sampled population with smooth Hess diagram template.)","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"At left is a population of stars sampled from an SSP with the methods described in the section of the documentation on simulating CMDs. The points from the isochrone are colored orange. The next figure shows the binned Hess diagram derived from these data. The next figure shows our smooth Hess diagram template calculated for this SSP. The final figure at right shows the residual between the data and model in units of standard deviations. These are sometimes called Pearson residuals. Below we show the distribution of these residuals, which should be Gaussian with mean 0 and standard deviation 1 if the model were perfect. Note that, because all bins with 0 observed stars are excluded from the distribution and the observed Hess diagram contains Poisson error, the mean of our distribution will always be slightly higher than 0. We do, however, achieve a standard deviation of nearly 1, indicating that our model is robust. We show a Gaussian PDF with standard deviation 1 and mean equal to the observed mean of the residuals for comparison.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"(Image: Distribution of data - model residuals, in units of standard deviations.)","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The method used to create these smooth Hess diagram templates is partial_cmd_smooth.","category":"page"},{"location":"fitting/fitting_intro/#StarFormationHistories.partial_cmd_smooth","page":"Background and Template Construction","title":"StarFormationHistories.partial_cmd_smooth","text":"result::StatsBase.Histogram =\n    partial_cmd_smooth(m_ini::AbstractVector{<:Number},\n                       mags::AbstractVector{<:AbstractVector{<:Number}},\n                       mag_err_funcs,\n                       y_index,\n                       color_indices,\n                       imf,\n                       completeness_funcs=[one for i in mags];\n                       dmod::Number=0,\n                       normalize_value::Number=1,\n                       binary_model::AbstractBinaryModel=NoBinaries(),\n                       mean_mass=mean(imf),\n                       edges=nothing,\n                       xlim=nothing,\n                       ylim=nothing,\n                       nbins=nothing,\n                       xwidth=nothing,\n                       ywidth=nothing)\n\nMain function for generating template Hess diagrams from a simple stellar population of stars from an isochrone, including photometric error and completeness.\n\nArguments\n\nm_ini::AbstractVector{<:Number} is a vector containing the initial stellar masses of the stars from the isochrone.\nmags::AbstractVector{<:AbstractVector{<:Number}} is a vector of vectors. Each constituent vector with index i should have length(mags[i]) == length(m_ini), representing the magnitudes of the isochrone stars in each of the magnitudes considered. In most cases, mags should contain 2 (if y-axis mag is also involved in the x-axis color) or 3 vectors.\nmag_err_funcs must be an indexable object (e.g., a Vector or Tuple) that contains callables (e.g., a Function) to compute the 1σ photometric errors for the same filters provided in mags. Each callable must take a single argument (an apparent magnitude) and return a Number. The length mag_err_funcs must be equal to the length of mags.\ny_index gives a valid index (e.g., an Int or CartesianIndex) into mags for the filter you want to have on the y-axis of the Hess diagram. For example, if the mags argument contains the B and V band magnitudes as mags=[B, V] and you want V on the y-axis, you would set y_index as 2. \ncolor_indices is a length-2 indexable object giving the indices into mags that are to be used to compute the x-axis color. For example, if the mags argument contains the B and V band magnitudes as mags=[B, V], and you want B-V to be the x-axis color, then color_indices should be [1,2] or (1,2) or similar.\nimf is a callable that takes an initial stellar mass as its sole argument and returns the (properly normalized) probability density of your initial mass function model. All the models from InitialMassFunctions.jl are valid for imf.\ncompleteness_functions must be an indexable object (e.g., a Vector or Tuple) that contains callables (e.g., a Function) to compute the single-filter completeness fractions as a function of apparent magnitude. Each callable in this argument must correspond to the matching filter provided in mags.\n\nKeyword Arguments\n\ndmod::Number=0 is the distance modulus in magnitudes to apply to the input mags. Leave at 0 if you are providing apparent magnitudes in mags.\nnormalize_value::Number=1 is the total stellar mass of the population you wish to model.\nbinary_model::AbstractBinaryModel=NoBinaries() is the model to use for including binary systems. Currently only StarFormationHistories.NoBinaries and StarFormationHistories.RandomBinaryPairs are supported.\nmean_mass::Number is the expectation value of the initial mass for a random star drawn from your provided imf. This will be computed for you if your provided imf is a valid continuous, univariate Distributions.Distribution object.\nedges is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: (-1.0:0.1:1.5, 22:0.1:27.2). If edges is provided, it overrides the following keyword arguments that offer other ways to specify the extent of the Hess diagram.\nxlim is a length-2 indexable object (e.g., a Vector or Tuple) giving the lower and upper bounds on the x-axis corresponding to the provided colors array. Example: (-1.0, 1.5). This is only used if edges is not provided. \nylim is as xlim but for the y-axis corresponding to the provided mags array. Example (25.0, 20.0). This is only used if edges is not provided.\nnbins::NTuple{2, <:Integer} is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if edges is not provided.\nxwidth is the bin width along the x-axis for the colors array. This is only used if edges and nbins are not provided. Example: 0.1.\nywidth is as xwidth but for the y-axis corresponding to the provided mags array. Example: 0.1.\n\nReturns\n\nThis method returns the Hess diagram as a StatsBase.Histogram; you should refer to the StatsBase documentation for more information. In short, if the output of this method is result, then the Hess diagram represented as a Matrix is available as result.weights (this is what you would want for fit_templates and similar functions) and the edges of the histogram are available as result.edges.\n\n\n\n\n\n","category":"function"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The user-provided functions returning magnitude errors (mag_err_funcs) and completeness values (completness_functions) given a star's intrinsic apparent magnitude are important for deriving good templates. These are typically derived from catalogs of artificial star tests. Some helper functions for constructing these are provided here.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"We note that in many cases it can also be helpful to add in a foreground/background template that models contamination of the Hess diagram from stars not in your population of interest – this is often done using observations of parallel fields though there are several other possible methods.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Photometric catalogs can be processed into Hess diagrams meeting our formatting requirements with the method bin_cmd.","category":"page"},{"location":"fitting/fitting_intro/#StarFormationHistories.bin_cmd","page":"Background and Template Construction","title":"StarFormationHistories.bin_cmd","text":"result::StatsBase.Histogram =\n   bin_cmd(colors::AbstractVector{<:Number},\n           mags::AbstractVector{<:Number};\n           weights::AbstractVector{<:Number} = ones(promote_type(eltype(colors),\n                                                    eltype(mags)), size(colors)),\n           edges  = nothing,\n           xlim   = extrema(colors),\n           ylim   = extrema(mags),\n           nbins  = nothing,\n           xwidth = nothing,\n           ywidth = nothing)\n\nReturns a StatsBase.Histogram type containing the Hess diagram from the provided x-axis photometric colors and y-axis photometric magnitudes mags. These must all be vectors equal in length. You can either specify the bin edges directly via the edges keyword (e.g., edges = (range(-0.5, 1.6, length=100), range(17.0, 26.0, length=100))), or you can set the x- and y-limits via xlim and ylim and the number of bins as nbins, or you can omit nbins and instead pass the bin width in the x and y directions, xwidth and ywidth. See below for more info on the keyword arguments. To plot this with PyPlot.jl you should do PyPlot.imshow(permutedims(result.weights), origin=\"lower\", extent=(extrema(result.edges[1])..., extrema(result.edges[2]), kws...) where kws... are any other keyword arguments you wish to pass to PyPlot.imshow.\n\nKeyword Arguments\n\nweights::AbstractVector{<:Number} is a array of length equal to colors and mags that contains the probabilistic weights associated with each point. This is passed to StatsBase.fit as StatsBase.Weights(weights). The following keyword arguments are passed to StarFormationHistories.calculate_edges to determine the bin edges of the histogram.\nedges is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: (-1.0:0.1:1.5, 22:0.1:27.2). If edges is provided, weights is the only other keyword that will be read; edges supercedes the other construction methods. \nxlim is a length-2 indexable object (e.g., a vector or tuple) giving the lower and upper bounds on the x-axis corresponding to the provided colors array. Example: [-1.0, 1.5]. This is only used if edges is not provided. \nylim is like xlim but  for the y-axis corresponding to the provided mags array. Example [25.0, 20.0]. This is only used if edges is not provided.\nnbins::NTuple{2, <:Integer} is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if edges is not provided.\nxwidth is the bin width along the x-axis for the colors array. This is only used if edges and nbins are not provided. Example: 0.1. \nywidth is like xwidth but for the y-axis corresponding to the provided mags array. Example: 0.1.\n\n\n\n\n\n","category":"function"},{"location":"fitting/fitting_intro/#A-Note-on-Array-Formatting","page":"Background and Template Construction","title":"A Note on Array Formatting","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"It is expected that the user will typically have model templates stored as two-dimensional matrices as these are the obvious choice for representing a binned two-dimensional histogram. We fully support supplying the list of model templates as a list of matrices (e.g., a Vector{Matrix{<:Number}}) to the fitting functions discussed below. The important computational kernels composite! and ∇loglikelihood! have custom loops for these input types.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"However, additional optimizations are possible by flattening the data. By flattening each matrix in the list of model templates into a column vector and concatenating them such that the list of model templates becomes a single matrix, we can compute the complex model Hess diagram as a single matrix-vector product rather than using a custom loop. The same optimization can be made when computing the gradient of the loglikelihood (discussed more below). The majority of all computation for the fitting methods below is spent in these two functions, so optimizing their performance translates directly to improved fitting runtimes. With this flattened memory arrangement we can use the highly optimized LinearAlgbera.mul! method to do the in-place matrix-vector product. This will typically be translated into a call to a BLAS function like gemv!. As such, we can benefit from Julia's ability to switch BLAS implementations at runtime to use Intel's Math Kernel Library, Apple's Accelerate, and others.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Most of the fitting methods below support both the natural and flattened data layouts. We provide the stack_models method to produce the optimized layout for the list of model templates.","category":"page"},{"location":"fitting/fitting_intro/#StarFormationHistories.stack_models","page":"Background and Template Construction","title":"StarFormationHistories.stack_models","text":"stack_models(models::AbstractVector{<:AbstractMatrix{<:Number}})\n\nTransforms a vector of matrices into a single matrix, with each matrix from models being transcribed into a single column in the output matrix. This data layout enables more efficient calculations in some of our internal functions like composite! and ∇loglikelihood!. This function is just reduce(hcat, map(vec, models)).\n\nExamples\n\njulia> stack_models([rand(5,5) for i in 1:10])\n25×10 Matrix{Float64}:\n...\n\n\n\n\n\n","category":"function"},{"location":"fitting/fitting_intro/#A-Note-on-Threading","page":"Background and Template Construction","title":"A Note on Threading","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"While generally the methods using BLAS routines offer significant performance improvements, there is a caveat when multithreading from within Julia. By default Julia will allow BLAS to use multiple threads even if Julia itself is started with a single thread (i.e., by running julia -t 1). BLAS threads do not compose with Julia threads. That is, if you start Julia with N>1 threads (julia -t N) and write a threaded workload where each Julia thread is doing BLAS operations concurrently, you can easily oversubscribe the CPU. Specific recommendations vary depending on BLAS vendor (see this page and the linked discourse threads), but generally this package is in the regime of doing many small calculations that do not individually benefit much from BLAS threading (e.g., performance for OpenBLAS with 8 threads is only ~2x the 1 thread performance). As such it is often sufficient to set BLAS to use a single thread (via LinearAlgbera.BLAS.set_num_threads(1) or environment variables; see above link).","category":"page"},{"location":"fitting/hierarchical/overview/#metal_evo_intro","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"Why should the metallicity evolution be constrained? While the above methods work well for optimizing the per-template r_j as a means for fitting SFHs, these methods can produce metallicity evolutions that could be considered unphysical, with large changes in the mean metallicity over small changes in time. An example of this type of behavior is shown in the SFH fit below.","category":"page"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"(Image: Example of a SFH fit with variations in the metallicity evolution.)","category":"page"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"While some metallicity variation in the star-forming gas is to be expected, these variations in the SFH fit can end up being quite large depending on the data and isochrone grid adopted. A solution is to construct a more physically-motivated model.","category":"page"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"We can do this using a hierarchical model with a parameterized metallicity evolution where the the r_j are not the parameters directly optimized. Rather, we can optimize one stellar mass (or star formation rate) parameter per age bin, and then a number of metallicity evolution parameters that determine how that stellar mass is split between models with different metallicities at fixed age.","category":"page"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"In most star formation history analyses, the metallicities are constrained through age-metallicity relations (AMRs), where the mean metallicity at time t is a function of time and a small set of metallicity evolution parameters. A popular AMR model is the linear age-metallicity relation langle textMtextH rangle (t) = alpha  left( T_textmax - t right) + beta with a Gaussian distribution in metallicity at fixed age. T_textmax here is the earliest lookback time under consideration such that langle textMtextH rangle (T_textmax) = beta. This model is described in more detail here.","category":"page"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"AMRs have historically been popular because they are generally capable of producing reasonable fits to observed data and it is relatively easy to derive the gradient of the objective function with respect to the AMR parameters analytically. However, in AMR models there is no direct link between the SFRs being fit and the metallicity evolution as a function of time, even though the two should in principle have some correlation as stellar processes are responsible for enriching the ISM.","category":"page"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"A promising avenue of research involves fitting mass-metallicity relations (MZRs) rather than AMRs. In these models, the mean metallicity of stars forming at time t is a function of the total stellar mass of the population at that time – therefore, the mean metallicity evolution changes self-consistently with the SFRs during the fitting process, resulting in a metallicity evolution that is meaningfully coupled to the star formation history. Additionally, AMRs can be difficult to compare between different galaxies because they do not reflect the different SFHs of the galaxies, whereas MZRs can be compared between galaxies much more easily. Our methods for MZR fitting are described in more detail here.","category":"page"},{"location":"fitting/hierarchical/overview/#Generic-Methods","page":"Overview","title":"Generic Methods","text":"","category":"section"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"While there are some methods in this package that are unique to AMR or MZR models, we present a minimal unified interface that can be used to fit SFHs under both types of models. To support multiple dispatch, we define AbstractMetallicityModel as the abstract supertype of AbstractAMR and AbstractMZR, which are each the supertypes for AMR and MZR types, respectively.","category":"page"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.AbstractMetallicityModel","page":"Overview","title":"StarFormationHistories.AbstractMetallicityModel","text":"AbstractMetallicityModel{T <: Real} is the abstract supertype for all hierarchical metallicity models. Abstract subtypes are AbstractAMR for age-metallicity relations and AbstractMZR for mass-metallicity relations. \n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"The generic methods that can be used for both AMRs and MZRs are described here. The main method for obtaining best-fit star formation histories is fit_sfh.","category":"page"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.fit_sfh","page":"Overview","title":"StarFormationHistories.fit_sfh","text":"fit_sfh(MH_model0::AbstractMetallicityModel,\n        disp_model0::AbstractDispersionModel,\n        models::AbstractMatrix{<:Number},\n        data::AbstractVector{<:Number},\n        logAge::AbstractVector{<:Number},\n        metallicities::AbstractVector{<:Number};\n        x0::AbstractVector{<:Number} = <...>\n        kws...)\nfit_sfh(MH_model0::AbstractMetallicityModel,\n        disp_model0::AbstractDispersionModel,\n        models::AbstractVector{<:AbstractMatrix{<:Number}},\n        data::AbstractMatrix{<:Number},\n        logAge::AbstractVector{<:Number},\n        metallicities::AbstractVector{<:Number};\n        x0::AbstractVector{<:Number} = <...>\n        kws...)\n\nReturns a CompositeBFGSResult instance that contains the maximum a posteriori (MAP) and maximum likelihood estimates (MLE) obtained from fitting the provided simple stellar population (SSP) templates models (with logarithmic ages logAge = log10(age [yr]) and metallicities metallicities) to the provided data. The metallicity evolution is modelled using the provided MH_model0, whose parameters can be free or fixed, with metallicity dispersion at fixed time modelled by disp_model0, whose parameters can be free or fixed.\n\nThis method is designed to work best with a grid of stellar models, defined by the outer product of N unique entries in logAge and M unique entries in metallicities. See the examples for more information on usage.\n\nWe provide several options for age-metallicity relations and mass-metallicity relations that can be used for MH_model0 and define APIs for users to create new models that will integrate with this function. Similar flexibility is allowed for the metallicity dispersion model disp_model0.\n\nThe primary method signature uses flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details, as well as stack_models that facilitates rearranging the models into this flattened format.\n\nArguments\n\nMH_model0 is an instance of AbstractMetallicityModel that defines how the average metallicity stars being formed in the population changes over time. The fittable parameters contained in this instance are used as the initial values to start the optimization. \ndisp_model0 is an instance of AbstractDispersionModel that defines the distribution of metallicities of stars forming in a fixed time bin (i.e., the dispersion in metallicity around the mean at fixed time). The fittable parameters contained in this instance are used as the initial values to start the optimization. \nmodels are the template Hess diagrams for the SSPs that compose the observed Hess diagram.\ndata is the Hess diagram for the observed data.\nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. These should be logarithmic abundances like [M/H] or [Fe/H]. There are some notes on the Wikipedia that might be useful.\n\nKeyword Arguments\n\nx0 is the vector of initial guesses for the stellar mass coefficients per unique entry in logAge. We try to set reasonable defaults, but in most cases users should be calculating and passing this keyword argument. We provide StarFormationHistories.construct_x0_mdf to prepare x0 assuming a constant star formation rate and total stellar mass, which is typically a good initial guess.\nkws... are passed to Optim.Options and can be used to control tolerances for convergence.\n\nReturns\n\nThis function returns a CompositeBFGSResult that contains the output from both MLE and MAP optimizations, accessible via result.mle and result.map. These are each instances of BFGSResult. See the docs for these structs for more information.\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"This function returns an instance of CompositeBFGSResult.","category":"page"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.CompositeBFGSResult","page":"Overview","title":"StarFormationHistories.CompositeBFGSResult","text":"CompositeBFGSResult(map::BFGSResult, mle::BFGSResult)\n\nType for containing the maximum a posteriori (MAP) AND maximum likelihood estimate (MLE) results from BFGS optimizations that use Optim.jl, which are individually accessible via the :mle and :map properties (i.e., for an instance of this type t, t.mle or getproperty(t, :mle) and t.map or getproperty(t, :map)).\n\nRandom samples can be drawn from an instance t as rand(t, N::Integer). This will return a size length(μ) x N matrix. This will use the MLE result for the best-fit values and the inverse Hessian approximation to the covariance matrix from the MAP result, which is more robust when best-fit values that are constrained to be positive approach 0.\n\nPer-SSP coefficients can be calculated with calculate_coeffs(result::CompositeBFGSResult, logAge::AbstractVector{<:Number}, metallicities::AbstractVector{<:Number}), which uses the MLE result (see these docs).\n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.BFGSResult","page":"Overview","title":"StarFormationHistories.BFGSResult","text":"BFGSResult(μ::AbstractVector{<:Number},\n           σ::AbstractVector{<:Number},\n           invH::AbstractMatrix{<:Number},\n           result,\n           MH_model::AbstractMetallicityModel,\n           disp_model::AbstractDispersionModel)\n\nType for containing the maximum likelihood estimate (MLE) or maximum a posteriori (MAP) results from BFGS optimizations that use Optim.jl. Fields are as follows:\n\nμ contains the final values of the fitting parameters. The mode and median methods will both return μ, but the mean of samples is not always equal to μ due to the variable transformations we perform.\nσ contains the standard errors estimated for the parameters and is returned by the std method.\ninvH is the BFGS approximation to the inverse Hessian, which is an estimator for the covariance matrix of the parameters if the objective function is approximately Gaussian near the best-fit μ.\nresult is the full result object returned by Optim.jl.\nMH_model is the best-fit metallicity model.\ndisp_model is the best-fit metallicity dispersion model.\n\nThis type is implemented as a subtype of Distributions.Sampleable{Multivariate, Continuous} to enable sampling from an estimate of the likelihood / posterior distribution constructed from the invH. You can obtain N::Integer samples from the distribution with rand(R, N) where R is an instance of this type. This will return a size length(μ) x N matrix.\n\nYou can also directly obtain the per-SSP template coefficients (r_jk in the derivation) using the optimization results stored in a BFGSResult with calculate_coeffs.\n\nSee also\n\nCompositeBFGSResult is a type that contains two instances of BFGSResult, one for the MAP and one for the MLE.\n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"This can be used to obtain random samples under a multivariable Normal approximation to the posterior or used to initialize a Hamiltonian Monte Carlo (HMC) sampling process to obtain more accurate posterior samples with sample_sfh and its multi-threaded alternative tsample_sfh.","category":"page"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.sample_sfh","page":"Overview","title":"StarFormationHistories.sample_sfh","text":"sample_sfh(bfgs_result::CompositeBFGSResult, \n           models::AbstractMatrix{<:Number},\n           data::AbstractVector{<:Number},\n           logAge::AbstractVector{<:Number},\n           metallicities::AbstractVector{<:Number},\n           Nsteps::Integer;\n           ϵ::Real = 0.05, # HMC step size\n           reporter = DynamicHMC.ProgressMeterReport(),\n           show_convergence::Bool = true,\n           rng::AbstractRNG = default_rng())\nsample_sfh(bfgs_result::CompositeBFGSResult, \n           models::AbstractVector{<:AbstractMatrix{<:Number}},\n           data::AbstractMatrix{<:Number},\n           logAge::AbstractVector{<:Number},\n           metallicities::AbstractVector{<:Number},\n           Nsteps::Integer;\n           kws...)\n\nTakes the SFH fitting result in bfgs_result and uses it to initialize the Hamiltonian Monte Carlo (HMC) sampler from DynamicHMC.jl to sample Nsteps independent draws from the posterior.\n\nThe primary method signature uses flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details, as well as stack_models that facilitates rearranging the models into this flattened format.\n\nArguments\n\nmodels, data, logAge, metallicities are as in fit_sfh.\nNsteps is the number of Monte Carlo samples you want to draw.\n\nKeyword Arguments\n\nϵ is the HMC step size. Convergence of the HMC samples is checked after sampling and if a convergence warning is issued, you should decrease this value.\nreporter is a valid reporter type from DynamicHMC.jl, either NoProgressReport, ProgressMeterReport for a basic progress meter, or LogProgressReport for more detailed reporting.\nshow_convergence if true, will send sample convergence statistics to the default display.\nrng is a Random.AbstractRNG sampler instance that will be used when generating the random samples.\n\nReturns\n\nA NamedTuple with two elements:\n\nposterior_matrix is a Matrix with dimensions (npar, Nsteps) where npar is the number of fitting variables in the problem and is npar = length(bfgs_result.mle.μ). Each column is one independent sample.\ntree_statistics contains convergence statistics that can be viewed with DynamicHMC.Diagnostics.summarize_tree_statistics.\n\nSee also\n\n[tsample_sfh(@ref StarFormationHistories.tsample_sfh) for multi-threaded version.\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.tsample_sfh","page":"Overview","title":"StarFormationHistories.tsample_sfh","text":"tsample_sfh(bfgs_result::CompositeBFGSResult, \n            models::AbstractMatrix{<:Number},\n            data::AbstractVector{<:Number},\n            logAge::AbstractVector{<:Number},\n            metallicities::AbstractVector{<:Number},\n            Nsteps::Integer;\n            ϵ::Real = 0.05, # HMC step size\n            show_convergence::Bool=true,\n            show_progress::Bool=true,\n            rng::AbstractRNG=default_rng(),\n            chain_length::Integer=100)\ntsample_sfh(bfgs_result::CompositeBFGSResult, \n            models::AbstractVector{<:AbstractMatrix{<:Number}},\n            data::AbstractMatrix{<:Number},\n            logAge::AbstractVector{<:Number},\n            metallicities::AbstractVector{<:Number},\n            Nsteps::Integer;\n            kws...)\n\nMulti-threaded version of sample_sfh; see that method's documentation for details.\n\nImplementation\n\nThis method splits the requested number of samples Nsamples into a number of independent HMC chains, each of which has length chain_length. Initial positions for each chain are randomly drawn from the multivariate Gaussian approximation to the objective function stored in bfgs_result, approximating a warm start. Smaller values of chain_length achieve better load balancing while larger values of chain_length allow each chain more time to mix (see also Chen et al. 2020). The default value of 100 results in good mixing with 24 fitting variables and a well-scaled step length ϵ – higher dimensional problems should increase chain_length. The downside to large chain_length is poor load balancing across available threads resulting in longer runtimes.\n\nNotes\n\nif show_progress is true, we will show a progress bar that updates when individual chains complete. Currently this is not terribly useful unless the total number of chains is much greater than the number of available threads.\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/overview/","page":"Overview","title":"Overview","text":"The per-SSP stellar mass coefficients (r_jk in the derivation) can be derived from a metallicity model, a metallicity dispersion model, the per-unique-log(age) stellar mass coefficients (R_j in the derivation), and the set of SSP logarithmic ages logAge = log10(age [yr]) and metallicites using calculate_coeffs. Alternatively a CompositeBFGSResult can be fed into this method and the first three arguments will be read from the result object.","category":"page"},{"location":"fitting/hierarchical/overview/#StarFormationHistories.calculate_coeffs","page":"Overview","title":"StarFormationHistories.calculate_coeffs","text":"calculate_coeffs(MH_model::AbstractMetallicityModel,\n                 disp_model::AbstractDispersionModel,\n                 mstars::AbstractVector{<:Number}, \n                 logAge::AbstractVector{<:Number},\n                 metallicities::AbstractVector{<:Number})\n\nReturns per-SSP stellar mass coefficients (r_jk in the derivation) using the provided metallicity model MH_model and metallicity dispersion model disp_model for the set of SSPs with logarithmic ages logAge and metallicities metallicities.\n\nExamples\n\njulia> n_logage, n_mh = 10, 20; # Number of unique logAges, MHs\n\njulia> coeffs = calculate_coeffs(PowerLawMZR(1.0, -1.0),\n                                 GaussianDispersion(0.2),\n                                 rand(n_logage),\n                                 repeat(range(7.0, 10.0; length=n_logage); inner=n_mh),\n                                 repeat(range(-2.0, 0.0; length=n_mh); outer=n_logage));\n\njulia> coeffs isa Vector{Float64}\ntrue\n\njulia> length(coeffs) == n_logage * n_mh\ntrue\n\n\n\n\n\n","category":"function"},{"location":"doc_index/#index","page":"Index","title":"Index","text":"","category":"section"},{"location":"doc_index/","page":"Index","title":"Index","text":"Modules = [StarFormationHistories]","category":"page"},{"location":"fitting/hierarchical/linear_amr/#linear_amr_section","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"","category":"section"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Here we describe the linear age-metallicity relation langle textMtextH rangle (t) = alpha  left( T_textmax - t right) + beta with a Gaussian distribution in metallicity at fixed age as described by the GaussianDispersion dispersion model. T_textmax here is the earliest lookback time under consideration such that langle textMtextH rangle (T_textmax) = beta. If the per-age-bin stellar mass coefficients are R_j, the age of the stellar population j is t_j, and the metallicity of population k is textMtextH_k, then we can write the per-model r_jk (where we are now using separate indices for age and metallicity) as","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nmu_j = alpha  left( T_textmax - t_j right) + beta \nr_jk = R_j  frac textexp left( - left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - left( frac textMtextH_k - mu_jsigma right)^2 right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"where the numerator is the MDF at fixed age evaluated at metallicity textMtextH_k and the denominator is a normalizing coefficient that ensures sum_k r_jk = R_j. In this notation, bin i of the complex model Hess diagram (equation 1 of Dolphin 2002) is","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"m_i = sum_jk  r_jk  c_ijk","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Below we show a fit using this hierarchical model to the same data as was used to derive the unconstrained fit in the introduction. ","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"(Image: Example of a SFH fit with a linear metallicity evolution.)","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"This model is represented by the LinearAMR type, which is a subtype of AbstractAMR.","category":"page"},{"location":"fitting/hierarchical/linear_amr/#StarFormationHistories.AbstractAMR","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.AbstractAMR","text":"AbstractAMR{T <: Real} <: AbstractMetallicityModel{T}: abstract supertype for all metallicity models that are age-metallicity relations. Concrete subtypes T <: AbstractAMR should implement the following API: \n\n(model::T)(logAge::Real) should be defined so that the struct is callable with a logarithmic age (log10(age [yr])), returning the mean metallicity given the AMR model. This is mu_j left( t_j right) in the derivations presented in the documentation.\nnparams(model::T) should return the number of fittable parameters in the model.\nfittable_params(model::T) should return the values of the fittable parameters in the model.\ngradient(model::T, logAge::Real) should return a tuple that contains the partial derivative of the mean metallicity mu_j with respect to each fittable model parameter evaluated at logarithmic age logAge.\nupdate_params(model::T, newparams) should return a new instance of T with the fittable parameters contained in newparams (which is typically a vector or tuple) and non-fittable parameters inherited from the provided model.\ntransforms(model::T) should return a tuple of length nparams(model) which indicates how the fittable variables should be transformed for optimization, if at all. Elements should be 1 for parameters that are constrained to always be positive, 0 for parameters that can be positive or negative, and -1 for parameters that are constrained to always be negative.\nfree_params(model::T) should return an NTuple{nparams(model), Bool} that is true for fittable parameters that you want to optimize and false for fittable parameters that you want to stay fixed during optimization. \n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/linear_amr/#StarFormationHistories.LinearAMR","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.LinearAMR","text":"LinearAMR(α::Real,\n          β::Real,\n          T_max::Real = 137//10,\n          free::NTuple{2, Bool} = (true, true))\n\nSubtype of AbstractAMR implementing the linear age-metallicity relation where the mean metallicity at a lookback time t_j (in Gyr) is μ_j = α * (T_max - t_j) + β. α is therefore a slope describing the rate of change in the metallicity per Gyr, and β is the mean metallicity value of stars being born at a lookback time of T_max, which has units of Gyr. free controls whether α and β should be freely fit or fixed when passed into fit_sfh; if free[1] == true then α will be freely fit, whereas it will fixed if free[1] == false. free[2] has the same effect but for β. \n\n\n\n\n\nLinearAMR(constraint1, constraint2, T_max::Real=137//10,\n          free::NTuple{2, Bool}=(true, true))\n\nConstruct an instance of LinearAMR from MH constraints at two different lookback times. Each of constraint1 and constraint2 should be length-2 indexables (e.g., tuples) whose first element is a metallicity [M/H] and second element is a lookback time in Gyr. The order of the constraints does not matter. \n\nExamples\n\njulia> LinearAMR((-2.5, 13.7), (-1.0, 0.0), 13.7) isa LinearAMR{Float64}\ntrue\n\njulia> LinearAMR((-2.5, 13.7), (-1.0, 0.0), 13.7) == LinearAMR((-1.0, 0.0), (-2.5, 13.7), 13.7)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/linear_amr/#Fitting-Functions","page":"Linear Age-Metallicity Relation","title":"Fitting Functions","text":"","category":"section"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"fit_sfh and sample_sfh both work with this AMR model.","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"The method StarFormationHistories.construct_x0_mdf can be used to construct the stellar mass components R_j of the initial guess vector x0.","category":"page"},{"location":"fitting/hierarchical/linear_amr/#StarFormationHistories.construct_x0_mdf","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.construct_x0_mdf","text":"x0::Vector = construct_x0_mdf(logAge::AbstractVector{T},\n                              [ cum_sfh, ]\n                              T_max::Number;\n                              normalize_value::Number = one(T)) where T <: Number\n\nGenerates a vector of initial stellar mass normalizations for input to fit_sfh and similar methods with a total stellar mass of normalize_value. The logAge vector must contain the log10(Age [yr]) of each isochrone that you are going to input as models. If cum_sfh is not provided, a constant star formation rate is assumed. For the purposes of computing the constant star formation rate, the provided logAge are treated as left-bin edges, with the final right-bin edge being T_max, which has units of Gyr. For example, you might have logAge=[6.6, 6.7, 6.8] in which case a final logAge of 6.9 would give equal bin widths (in log-space). In this case you would set T_max = exp10(6.9) / 1e9 ≈ 0.0079 so that the width of the final bin for the star formation rate calculation has the same log10(Age [yr]) step as the other bins.\n\nA desired cumulative SFH vector cum_sfh::AbstractVector{<:Number} can be provided as the second argument, which should correspond to a lookback time vector unique(logAge). You can also provide cum_sfh as a length-2 indexable (e.g., a length-2 Vector{Vector{<:Number}}) with the first element containing a list of log10(Age [yr]) values and the second element containing the cumulative SFH values at those values. This cumulative SFH is then interpolated onto the logAge provided in the first argument. This method should be used when you want to define the cumulative SFH on a different age grid from the logAge you provide in the first argument. The examples below demonstrate these use cases.\n\nThe difference between this function and StarFormationHistories.construct_x0 is that this function generates an x0 vector that is of length length(unique(logage)) (that is, a single normalization factor for each unique entry in logAge) while StarFormationHistories.construct_x0 returns an x0 vector that is of length length(logAge); that is, a normalization factor for every entry in logAge. The order of the coefficients is such that the coefficient x[i] corresponds to the entry unique(logAge)[i]. \n\nNotes\n\nExamples – Constant SFR\n\njulia> isapprox( construct_x0_mdf([9.0, 8.0, 7.0], 10.0; normalize_value=5.0),\n                 [4.504504504504504, 0.4504504504504504, 0.04504504504504504] )\ntrue\n\njulia> isapprox( construct_x0_mdf(repeat([9.0, 8.0, 7.0, 8.0]; inner=3), 10.0; normalize_value=5.0),\n                 [4.504504504504504, 0.4504504504504504, 0.04504504504504504] )\ntrue\n\njulia> isapprox( construct_x0_mdf(repeat([9.0, 8.0, 7.0, 8.0]; outer=3), 10.0; normalize_value=5.0),\n                 construct_x0([9.0, 8.0, 7.0], 10.0; normalize_value=5.0) )\ntrue\n\nExamples – Input Cumulative SFH defined on same logAge grid\n\njulia> isapprox( construct_x0_mdf([9.0, 8.0, 7.0], [0.9009, 0.99099, 1.0], 10.0; normalize_value=5.0),\n                 [4.5045, 0.4504, 0.0450]; atol=1e-3 )\ntrue\n\njulia> isapprox( construct_x0_mdf([9.0, 8.0, 7.0], [0.1, 0.5, 1.0], 10.0; normalize_value=5.0),\n                 [0.5, 2.0, 2.5] )\ntrue\n\njulia> isapprox( construct_x0_mdf([7.0, 8.0, 9.0], [1.0, 0.5, 0.1], 10.0; normalize_value=5.0),\n                 [2.5, 2.0, 0.5] )\ntrue\n\nExamples – Input Cumulative SFH with separate logAge grid\n\njulia> isapprox( construct_x0_mdf([9.0, 8.0, 7.0],\n                                  [[9.0, 8.0, 7.0], [0.9009, 0.99099, 1.0]], 10.0; normalize_value=5.0),\n                 construct_x0_mdf([9.0, 8.0, 7.0], [0.9009, 0.99099, 1.0], 10.0; normalize_value=5.0) )\ntrue\n\njulia> isapprox( construct_x0_mdf([9.0, 8.0, 7.0],\n                                  [[9.0, 8.5, 8.25, 7.0], [0.9009, 0.945945, 0.9887375, 1.0]], 10.0; normalize_value=5.0),\n                 construct_x0_mdf([9.0, 8.0, 7.0], [0.9009, 0.99099, 1.0], 10.0; normalize_value=5.0) )\ntrue\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"and calculate_coeffs can be used to calculate per-template stellar mass coefficients (the r_jk above) given the results of a fit (which will be the R_j in the equations above).","category":"page"},{"location":"fitting/hierarchical/linear_amr/#linear_amr_implementation","page":"Linear Age-Metallicity Relation","title":"Implementation","text":"","category":"section"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"While one could optimize the above model without an analytic gradient, such gradient-free methods are typically slower and less robust. One could also calculate the gradient numerically using finite differences or auto-differentiation, but these are still slower than analytic calculations. We will show that the gradient of this hierarchical model is analytic, allowing us to design an efficient optimization scheme.","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Equation 21 in Dolphin 2001 gives the gradient of our objective function with respect to the underlying coefficients","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nF equiv - textln  mathscrL = sum_i m_i - n_i times left( 1 - textln  left( fracn_im_i right) right) \nfracpartial  Fpartial  r_jk = sum_i c_ijk left( 1 - fracn_im_i right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"where c_ijk is the value of template jk in bin i and n_i is bin i of the observed Hess diagram. These partial derivatives are easy to obtain, but we need partials with respect to the per-age-bin fitting parameters R_j. Given the above relation between r_jk and R_j, we can calculate these derivatives as","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  R_j = sum_k  fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j \nfracpartial  r_jkpartial  R_j = frac textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) = fracr_jkR_j\nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Then we need only the partial derivatives of the objective function F with respect to the MDF parameters, which in this case are alpha beta sigma. For convenience we will rewrite","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"r_jk = R_j  frac textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) = R_j  fracA_jksum_k A_jk","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"as many different types of models can be expressed via this simplified notation by substituting the A_jk with different distributions. This allows us to write ","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  beta = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta \nfracpartial  r_jkpartial  beta = R_j left( frac1sum_k  A_jk  fracpartial  A_jkpartial  beta - fracA_jkleft( sum_k  A_jk right)^2  fracpartial  sum_k  A_jkpartial  beta right)  \n= fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  beta - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  beta right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Given our specific definition of A_jk being a Gaussian distribution, we have","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nmu_j = alpha  left( T_textmax - t_j right) + beta \nfracpartial  A_jkpartial  beta = fracpartialpartial  beta  left textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) right \n= fracA_jksigma^2 left( textMtextH_k - mu_j right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"We can now substitute this result into the above expressions to write","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  beta = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta \n= sum_jk fracpartial  Fpartial  r_jk  fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  beta - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  beta right) \n= sum_jk fracpartial  Fpartial  r_jk  fracR_jsigma^2  sum_k  A_jk left( A_jk left( textMtextH_k - mu_j right) - fracA_jksum_k  A_jk sum_k A_jk left( textMtextH_k - mu_j right) right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"It can be shown that the partial derivative of F with respect to alpha is simply","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"fracpartial  Fpartial  alpha = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  alpha = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta times left( T_textmax - t_j right) ","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"The partial derivative with respect to sigma is slightly more complicated, but we can start identically to how we started above when deriving fracpartial  Fpartial  beta with","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  sigma = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  sigma \nfracpartial  r_jkpartial  sigma = R_j left( frac1sum_k  A_jk  fracpartial  A_jkpartial  sigma - fracA_jkleft( sum_k  A_jk right)^2  fracpartial  sum_k  A_jkpartial  sigma right)  \n= fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  sigma - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  sigma right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Then all we need is","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"fracpartial  A_jkpartial  sigma = fracA_jk  left( textMtextH_k - mu_j right)^2sigma^3","category":"page"},{"location":"fitting/hierarchical/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"which we can substitute into the above expressions to find fracpartial  Fpartial  sigma.","category":"page"},{"location":"fitting/hierarchical/dispersion_models/#dispersion_models","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"","category":"section"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"In order to reproduce the broadness of features in observed color-magnitude diagrams it is common to introduce some dispersion in metallicity for stars formed in each time bin, where each time bin is associated with a mean metallicity mu_j. We implement a generic hierarchical model to accomodate this functionality.","category":"page"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"The hierarchical model forms the per-SSP weights r_jk, which are indexed by population age j and metallicity k, as a function of a linear coefficient R_j which describes the stellar mass formed in the time bin, and a relative weight A_jk which depends on the mean metallicity mu_j and the metallicity of the SSP under consideration. In the case of a Gaussian metallicity dispersion at fixed age, which is often used in practice, we can write ","category":"page"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"A_jk = textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)","category":"page"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"If we take R_j to be the total stellar mass formed in the time bin, then it is clear that we require the sum over the relative weights for the SSPs of age j to equal one, i.e., sum_k r_jk = 1. We therefore require that the relative weight on each SSP template of age j be normalized by the sum sum_k A_jk, so that the relative weights are","category":"page"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"r_jk = R_j  fracA_jksum_k A_jk","category":"page"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"We provide a generic interface for describing the analytic form of the A_jk so that it is easy to define new dispersion models that will integrate with our fitting routines. Built-in, ready to use models are described below, and the API for defining new models is described in the API section.","category":"page"},{"location":"fitting/hierarchical/dispersion_models/#Built-In-Models","page":"Metallicity Dispersion Models","title":"Built-In Models","text":"","category":"section"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.GaussianDispersion","page":"Metallicity Dispersion Models","title":"StarFormationHistories.GaussianDispersion","text":"GaussianDispersion(σ::Real, free::NTuple{1, Bool} = (true,)) <: AbstractDispersionModel\n\nDispersion model for a Gaussian (i.e., Normal) spread in metallicities with standard deviation σ (which must be greater than 0) at fixed age. The relative weights for this model are given by A_jk = exp(-((x_k - μ_j)σ)^22) The σ can be fit during optimizations if free == (true,) or fixed if free == (false,).\n\nExamples\n\njulia> GaussianDispersion(0.2) isa GaussianDispersion{Float64}\ntrue\n\njulia> import Test\n\njulia> Test.@test_throws(ArgumentError, GaussianDispersion(-0.2)) isa Test.Pass\ntrue\n\njulia> nparams(GaussianDispersion(0.2)) == 1\ntrue\n\njulia> GaussianDispersion(0.2)(1.0, 1.2) ≈ exp(-0.5)\ntrue\n\njulia> all(values(gradient(GaussianDispersion(0.2), 1.0, 1.2)) .≈\n                (3.0326532985631656, -3.0326532985631656))\ntrue\n\njulia> update_params(GaussianDispersion(0.2), 0.3) == GaussianDispersion(0.3)\ntrue\n\njulia> transforms(GaussianDispersion(0.2)) == (1,)\ntrue\n\njulia> free_params(GaussianDispersion(0.2, (false,))) == (false,)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/dispersion_models/#dispersion_API","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion API","text":"","category":"section"},{"location":"fitting/hierarchical/dispersion_models/","page":"Metallicity Dispersion Models","title":"Metallicity Dispersion Models","text":"Below we describe the API that must be followed in order to implement new types for describing the A_jk, such that they will work with our provided fitting and sampling methods.","category":"page"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.AbstractDispersionModel","page":"Metallicity Dispersion Models","title":"StarFormationHistories.AbstractDispersionModel","text":"Abstract type for all models of metallicity dispersion at fixed time t_j, for which the mean metallicity is mu_j. Concrete subtypes T <: AbstractDispersionModel should implement the following API: \n\n(model::T)(x::Real, μ::Real) should be defined so that the struct is callable with a metallicity x and a mean metallicity μ, returning the relative weight for the metallicity x given the dispersion model. This is A_jk for mu = mu_j in the derivations presented in the documentation.\nnparams(model::T) should return the number of fittable parameters in the model.\nfittable_params(model::T) should return the values of the fittable parameters in the model.\ngradient(model::T, x::Real, μ::Real) should return a tuple that contains the partial derivative of the A_jk with respect to each fittable model parameter, plus the partial derivative with respect to μ as the final element.\nupdate_params(model::T, newparams) should return a new instance of T with the fittable parameters contained in newparams (which is typically a vector or tuple) and non-fittable parameters inherited from the provided model.\ntransforms(model::T) should return a tuple of length nparams(model) which indicates how the fittable variables should be transformed for optimization, if at all. Elements should be 1 for parameters that are constrained to always be positive, 0 for parameters that can be positive or negative, and -1 for parameters that are constrained to always be negative.\nfree_params(model::T) should return an NTuple{nparams(model), Bool} that is true for fittable parameters that you want to optimize and false for fittable parameters that you want to stay fixed during optimization. \n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.nparams-Tuple{StarFormationHistories.AbstractDispersionModel}","page":"Metallicity Dispersion Models","title":"StarFormationHistories.nparams","text":"nparams(model::AbstractDispersionModel)::Int\n\nReturns the number of fittable parameters in the model. \n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.fittable_params-Tuple{StarFormationHistories.AbstractDispersionModel}","page":"Metallicity Dispersion Models","title":"StarFormationHistories.fittable_params","text":"fittable_params(model::AbstractDispersionModel{T})::NTuple{nparams(model), T}\n\nReturns the values of the fittable parameters in the provided dispersion model model.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.gradient-Tuple{StarFormationHistories.AbstractDispersionModel, Real, Real}","page":"Metallicity Dispersion Models","title":"StarFormationHistories.gradient","text":"gradient(model::AbstractDispersionModel{T}, x::Real, μ::Real)::NTuple{nparams(model)+1, T}\n\nReturns a tuple containing the partial derivative of the model with respect to all fittable parameters, plus the partial derivative with respect to the mean metallicity μ as the final element. These partial derivatives are evaluated at metallicity x where the model has expectation value μ.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.update_params-Tuple{StarFormationHistories.AbstractDispersionModel, Any}","page":"Metallicity Dispersion Models","title":"StarFormationHistories.update_params","text":"update_params(model::T, newparams)::T where {T <: AbstractDispersionModel}\n\nReturns a new instance of the model type T with the fittable parameters contained in newparams (which is typically a vector or tuple), with non-fittable parameters inherited from the provided model. \n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.transforms-Tuple{StarFormationHistories.AbstractDispersionModel}","page":"Metallicity Dispersion Models","title":"StarFormationHistories.transforms","text":"transforms(model::AbstractDispersionModel)::NTuple{nparams(model), Int}\n\nReturns a tuple of length nparams(model) which indicates how the fittable variables should be transformed for optimization, if at all. Elements should be 1 for parameters that are constrained to always be positive, 0 for parameters that can be positive or negative, and -1 for parameters that are constrained to always be negative.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/dispersion_models/#StarFormationHistories.free_params-Tuple{StarFormationHistories.AbstractDispersionModel}","page":"Metallicity Dispersion Models","title":"StarFormationHistories.free_params","text":"free_params(model::AbstractDispersionModel)::NTuple{nparams(model), Bool}\n\nReturns an tuple of length nparams(model) that is true for fittable parameters that you want to optimize and false for fittable parameters that you want to stay fixed during optimization.\n\n\n\n\n\n","category":"method"},{"location":"simulate/#simulate","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"Modelling observations of resolved stellar populations (e.g., color-magnitude or Hess diagrams) with user-defined star formation histories can be useful for comparison to actual observations, but also enables a number of other scientific activities (e.g., making predictions to motivate observational proposals). To support these uses we offer methods for sampling stellar populations from isochrones using user-defined star formation histories, initial mass functions, and stellar binary models. These methods require data from user-provided isochrones (this package does not provide any), an initial mass function model (such as those provided in InitialMassFunctions.jl), and a model specifying how (or if) to sample binary or multi-star systems. ","category":"page"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"The simplest methods only sample stars from a single stellar population. We provide a method that samples up to a provided stellar mass, generate_stars_mass (e.g., 10^7  textM_odot) and a method that samples up to a provided absolute magnitude generate_stars_mag (e.g., M_V=-10). These are documented under the first subsection below. These methods are single-threaded.","category":"page"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"We also offer methods for sampling populations with complex star formation histories; these are implicitly multi-threaded across the separate populations if you start Julia with multiple threads (e.g., with julia -t 4 or similar). We provide generate_stars_mass_composite for sampling such populations up to a provided stellar mass and generate_stars_mag_composite for sampling such populations up to a provided absolute magnitude. These are documented under the second subsection below.","category":"page"},{"location":"simulate/#Simple-Stellar-Populations","page":"Simulating Color-Magnitude Diagrams","title":"Simple Stellar Populations","text":"","category":"section"},{"location":"simulate/#StarFormationHistories.generate_stars_mass","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mass","text":"generate_stars_mass(mini_vec::AbstractVector{<:Number},\n                    mags, mag_names::AbstractVector{String},\n                    limit::Number,\n                    imf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous};\n                    dist_mod::Number=0,\n                    rng::Random.AbstractRNG=Random.default_rng(),\n                    mag_lim::Number = Inf,\n                    mag_lim_name::String = \"V\",\n                    binary_model::StarFormationHistories.AbstractBinaryModel =\n                        StarFormationHistories.RandomBinaryPairs(0.3))\n\nGenerates a random sample of stars from an isochrone defined by the provided initial stellar masses mini_vec, absolute magnitudes mags, and filter names mag_names with total population birth stellar mass limit (e.g., 1e5 solar masses). Initial stellar masses are sampled from the provided imf. \n\nArguments\n\nmini_vec::AbstractVector{<:Number} contains the initial masses (in solar masses) for the stars in the isochrone; must be mutable as we call Interpolations.deduplicate_knots!(mini_vec).\nmags contains the absolute magnitudes from the isochrone in the desired filters corresponding to the same stars as provided in mini_vec. mags is internally interpreted and converted into a standard format by StarFormationHistories.ingest_mags. Valid inputs are:\nmags::AbstractVector{AbstractVector{<:Number}}, in which case the length of the outer vector length(mags) can either be equal to length(mini_vec), in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to length(mini_vec); this is the more common use-case.\nmags::AbstractMatrix{<:Number}, in which case mags must be 2-dimensional. Valid shapes are size(mags) == (length(mini_vec), nfilters) or size(mags) == (nfilters, length(mini_vec)), with nfilters being the number of filters you are providing.\nmag_names::AbstractVector{String} contains strings describing the filters you are providing in mags; an example might be [\"B\",\"V\"]. These are used when mag_lim is finite to determine what filter you want to use to limit the faintest stars you want returned.\nlimit::Number gives the total birth stellar mass of the population you want to sample. See the \"Notes\" section on population masses for more information.\nimf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous} is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined rand(rng::Random.AbstractRNG, imf) method to use for sampling masses. All instances of Distributions.ContinuousUnivariateDistribution are also valid. Implementations of commonly used IMFs are available in InitialMassFunctions.jl.\n\nKeyword Arguments\n\ndist_mod::Number=0 is the distance modulus (see StarFormationHistories.distance_modulus) you wish to have added to the returned magnitudes to simulate a population at a particular distance.\nrng::Random.AbstractRNG=Random.default_rng() is the rng instance that will be used to sample the stellar initial masses from imf.\nmag_lim::Number=Inf gives the faintest apparent magnitude for stars you want to be returned in the output. Stars fainter than this magnitude will still be sampled and contribute properly to the total mass of the population, but they will not be returned.\nmag_lim_name::String=\"V\" gives the filter name (as contained in mag_names) to use when considering if a star is fainter than mag_lim. This is unused if mag_lim is infinite.\nbinary_model::StarFormationHistories.AbstractBinaryModel=StarFormationHistories.RandomBinaryPairs(0.3) is an instance of a model for treating binaries; currently provided options are NoBinaries, RandomBinaryPairs, and BinaryMassRatio.\n\nReturns\n\n(sampled_masses, sampled_mags) defined as\n\nsampled_masses::Vector{SVector{N,eltype(imf)}} is a vector containing the initial stellar masses of the stars sampled by sample_system; see that method's documentation for details on format. In short, each StaticArrays.SVector represents one stellar system and each entry in each StaticArrays.SVector is one star in that system. Entries will be 0 when companions could have been sampled but were not (i.e., when using a binary_model that supports multi-star systems). \nsampled_mags::Vector{SVector{N,<:Number}} is a vector containing StaticArrays.SVectors with the multi-band magnitudes of the sampled stars. To get the magnitude of star i in band j, you index as sampled_mags[i][j]. This can be reinterpreted as a 2-dimensional Matrix with reduce(hcat,sampled_mags). \n\nNotes\n\nPopulation Masses\n\nGiven a particular isochrone with an initial mass vector mini_vec, it will never cover the full range of stellar birth masses because stars that die before present-day are not included in the isochrone. However, these stars were born, and so contribute to the total birth mass of the system. There are two ways to properly account for this lost mass when sampling:\n\nSet the upper limit for masses that can be sampled from the imf distribution to a physical value for the maximum birth mass of stars (e.g., 100 solar masses). In this case, these stars will be sampled from imf, and will contribute their masses to the system, but they will not be returned if their birth mass is greater than maximum(mini_vec). This is typically easiest for the user and only results in ∼15% loss of efficiency for 10 Gyr isochrones. This approach is preferred when sampling with binaries.\nSet the upper limit for masses that can be sampled from the imf distribution to maximum(mini_vec) and adjust limit to respect the amount of initial stellar mass lost by not sampling higher mass stars. This can be calculated as new_limit = limit * ( QuadGK.quadgk(x->x*pdf(imf,x), minimum(mini_vec), maximum(mini_vec))[1] / QuadGK.quadgk(x->x*pdf(imf,x), minimum(imf), maximum(imf))[1] ), with the multiplicative factor being the fraction of the population stellar mass contained in stars with initial masses between minimum(mini_vec) and maximum(mini_vec); this factor is the ratio\n\nfracint_a^b  m times fracdN(m)dm  dmint_0^  m times fracdN(m)dm  dm\n\nNote that, if binaries are included, this approach only forms binary pairs between stars whose masses are less than maximum(mini_vec). This is probably not desired, so we recommend the previous approach when including binaries.\n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.generate_stars_mag","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mag","text":"(sampled_masses, sampled_mags) =  generate_stars_mag(mini_vec::AbstractVector{<:Number}, mags, mag_names::AbstractVector{String}, absmag::Real, absmag_name::String, imf::Distributions.Sampleable{Distributions.Univariate,Distributions.Continuous}; dist_mod::Number=0, rng::AbstractRNG=default_rng(), mag_lim::Number=Inf, mag_lim_name::String=\"V\", binary_model::StarFormationHistories.AbstractBinaryModel=RandomBinaryPairs(0.3))\n\nGenerates a mock stellar population from an isochrone defined by the provided initial stellar masses mini_vec, absolute magnitudes mags, and filter names mag_names. The population is sampled to a total absolute magnitude absmag::Real (e.g., -7 or -12) in the filter absmag_name::String (e.g., \"V\" or \"F606W\") which is contained in the provided mag_names::AbstractVector{String}. Other arguments are shared with generate_stars_mass, which contains the main documentation.\n\nNotes\n\nPopulation Magnitudes\n\nUnlike when sampling a population to a fixed initial birth mass, as is implemented in generate_stars_mass, when generating a population up to a fixed absolute magnitude, only stars that survive to present-day contribute to the flux of the population. If you choose to limit the apparent magnitude of stars returned by passing the mag_lim and mag_lim_name keyword arguments, stars fainter than your chosen limit will still be sampled and will still contribute their luminosity to the total population, but they will not be contained in the returned output. \n\n\n\n\n\n","category":"function"},{"location":"simulate/#Complex-Stellar-Populations","page":"Simulating Color-Magnitude Diagrams","title":"Complex Stellar Populations","text":"","category":"section"},{"location":"simulate/#StarFormationHistories.generate_stars_mass_composite","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mass_composite","text":"(sampled_masses, sampled_mags) = generate_stars_mass_composite(mini_vec::AbstractVector{<:AbstractVector{<:Number}}, mags::AbstractVector, mag_names::AbstractVector{String}, limit::Number, massfrac::AbstractVector{<:Number}, imf::Sampleable{Univariate,Continuous}; kws...)\n\nGenerates a random sample of stars with a complex star formation history using multiple isochrones. Very similar to generate_stars_mass except the isochrone-related arguments mini_vec and mags should now be vectors of vectors containing the relevant data for the full set of isochrones to be considered. The total birth stellar mass of the sampled population is given by limit. The proportion of this mass allotted to each of the individual isochrones is given by the entries of the massfrac vector. This basically just proportions limit according to massfrac and calls generate_stars_mass for each of the individual stellar populations; as such it is set up to multi-thread across the multiple stellar populations. \n\nArguments\n\nmini_vec::AbstractVector{<:AbstractVector{<:Number}} contains the initial masses (in solar masses) for the stars in each isochrone; the internal vectors must be mutable as we will call Interpolations.deduplicate_knots! on each. The length of mini_vec should be equal to the number of isochrones. \nmags contains the absolute magnitudes from the isochrones in the desired filters corresponding to the same stars as provided in mini_vec. The length of mags should be equal to the number of isochrones. The individual elements of mags are each internally interpreted and converted into a standard format by StarFormationHistories.ingest_mags. The valid formats for the individual elements of mags are:\nAbstractVector{AbstractVector{<:Number}}, in which case the length of the vector length(mags[i]) can either be equal to length(mini_vec[i]), in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to length(mini_vec[i]); this is the more common use-case.\nAbstractMatrix{<:Number}, in which case mags[i] must be 2-dimensional. Valid shapes are size(mags[i]) == (length(mini_vec[i]), nfilters) or size(mags[i]) == (nfilters, length(mini_vec[i])), with nfilters being the number of filters you are providing.\nmag_names::AbstractVector{String} contains strings describing the filters you are providing in mags; an example might be [\"B\",\"V\"]. These are used when mag_lim is finite to determine what filter you want to use to limit the faintest stars you want returned. These are assumed to be the same for all isochrones.\nlimit::Number gives the total birth stellar mass of the population you want to sample. \nmassfrac::AbstractVector{<:Number} is vector giving the relative fraction of mass allotted to each individual stellar population; length must be equal to the length of mini_vec and mags. \nimf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous} is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined rand(rng::Random.AbstractRNG, imf) method to use for sampling masses. All instances of Distributions.ContinuousUnivariateDistribution are also valid. Implementations of commonly used IMFs are available in InitialMassFunctions.jl.\n\nKeyword Arguments\n\nAll keyword arguments kws... are passed to generate_stars_mass; you should refer to that method's documentation for more information. \n\nReturns\n\nsampled_masses::Vector{Vector{SVector{N,eltype(imf)}}} is a vector of vectors containing the initial stellar masses of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e., all of sampled_masses[1] were sampled from mini_vec[1] and so on. These can be concatenated into a single vector with reduce(vcat,sampled_masses). The format of the contained StaticArrays.SVectors are as output from sample_system; see that method's documentation for more details. \nsampled_mags::Vector{Vector{SVector{N,<:Number}}} is a vector of vectors containing StaticArrays.SVectors with the multi-band magnitudes of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e. all of sampled_mags[1] were sampled from mags[1] and so on. To get the magnitude of star i in band j sampled from isochrone k, you would do sampled_mags[k][i][j]. This can be concatenated into a Vector{SVector} with reduce(vcat,sampled_mags) and a 2-D Matrix with reduce(hcat,reduce(vcat,sampled_mags)). \n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.generate_stars_mag_composite","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mag_composite","text":"(sampled_masses, sampled_mags) = generate_stars_mag_composite(mini_vec::AbstractVector{<:AbstractVector{<:Number}}, mags::AbstractVector, mag_names::AbstractVector{String}, absmag::Number, absmag_name::String, fracs::AbstractVector{<:Number}, imf::Sampleable{Univariate,Continuous}; frac_type::String=\"lum\", kws...)\n\nGenerates a random sample of stars with a complex star formation history using multiple isochrones. Very similar to generate_stars_mag except the isochrone-related arguments mini_vec and mags should now be vectors of vectors containing the relevant data for the full set of isochrones to be considered. The total absolute magnitude of the sampled population is given by absmag. The proportion of the luminosity allotted to each of the individual isochrones is given by the entries of the frac vector. This basically just proportions the luminosity according to frac and calls generate_stars_mag for each of the individual stellar populations; as such it is set up to multi-thread across the multiple stellar populations. \n\nArguments\n\nmini_vec::AbstractVector{<:AbstractVector{<:Number}} contains the initial masses (in solar masses) for the stars in each isochrone; the internal vectors must be mutable as we will call Interpolations.deduplicate_knots! on each. The length of mini_vec should be equal to the number of isochrones. \nmags contains the absolute magnitudes from the isochrones in the desired filters corresponding to the same stars as provided in mini_vec. The length of mags should be equal to the number of isochrones. The individual elements of mags are each internally interpreted and converted into a standard format by StarFormationHistories.ingest_mags. The valid formats for the individual elements of mags are:\nAbstractVector{AbstractVector{<:Number}}, in which case the length of the vector length(mags[i]) can either be equal to length(mini_vec[i]), in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to length(mini_vec[i]); this is the more common use-case.\nAbstractMatrix{<:Number}, in which case mags[i] must be 2-dimensional. Valid shapes are size(mags[i]) == (length(mini_vec[i]), nfilters) or size(mags[i]) == (nfilters, length(mini_vec[i])), with nfilters being the number of filters you are providing.\nmag_names::AbstractVector{String} contains strings describing the filters you are providing in mags; an example might be [\"B\",\"V\"]. These are used when mag_lim is finite to determine what filter you want to use to limit the faintest stars you want returned. These are assumed to be the same for all isochrones.\nabsmag::Number gives the total absolute magnitude of the complex population to be sampled. \nfracs::AbstractVector{<:Number} is a vector giving the relative fraction of luminosity or mass (determined by the frac_type keyword argument) allotted to each individual stellar population; length must be equal to the length of mini_vec and mags. \nimf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous} is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined rand(rng::Random.AbstractRNG, imf) method to use for sampling masses. All instances of Distributions.ContinuousUnivariateDistribution are also valid. Implementations of commonly used IMFs are available in InitialMassFunctions.jl.\n\nKeyword Arguments\n\nfrac_type::String either \"lum\", in which case fracs is assumed to contain the relative luminosity fractions for each individual isochrone, or \"mass\", in which case it is assumed that fracs contains mass fractions (\"mass\" is not yet implemented). \n\nAll other keyword arguments kws... are passed to generate_stars_mag; you should refer to that method's documentation for more information. \n\nReturns\n\nsampled_masses::Vector{Vector{SVector{N,eltype(imf)}}} is a vector of vectors containing the initial stellar masses of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e., all of sampled_masses[1] were sampled from mini_vec[1] and so on. These can be concatenated into a single vector with reduce(vcat,sampled_masses). The format of the contained StaticArrays.SVectors are as output from sample_system; see that method's documentation for more details. \nsampled_mags::Vector{Vector{SVector{N,<:Number}}} is a vector of vectors containing StaticArrays.SVectors with the multi-band magnitudes of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e. all of sampled_mags[1] were sampled from mags[1] and so on. To get the magnitude of star i in band j sampled from isochrone k, you would do sampled_mags[k][i][j]. This can be concatenated into a Vector{SVector} with reduce(vcat,sampled_mags) and a 2-D Matrix with reduce(hcat,reduce(vcat,sampled_mags)). \n\n\n\n\n\n","category":"function"},{"location":"simulate/#Observational-Effects","page":"Simulating Color-Magnitude Diagrams","title":"Observational Effects","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"The output produced from the above methods are clean in the sense that they do not include any observational effects like photometric error or incompleteness. These effects should be implemented in a post-processing step. We provide a simple method model_cmd that accepts user-defined photometric error and completeness functions and applies them to the initial catalog, returning a Monte Carlo realization of a possible observed catalog. This method assumes Gaussian photometric errors and that the photometric error and completeness functions are separable by filter – these assumptions are not applicable for all types of data, but the source code for the method is exceedingly simple (~20 lines) and should provide an example for how you could write a similar method that more accurately reflects your data.","category":"page"},{"location":"simulate/#StarFormationHistories.model_cmd","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.model_cmd","text":"new_mags [, good_idxs] = model_cmd(mags::AbstractVector{<:AbstractVector{<:Number}}, errfuncs, completefuncs; rng::Random.AbstractRNG=Random.default_rng(), ret_idxs::Bool=false)\n\nSimple method for modelling photometric error and incompleteness to \"mock observe\" a pure catalog of stellar photometry, such as those produced by generate_stars_mass and generate_stars_mag. This method assumes Gaussian photometric errors and that the photometric error and completeness functions are separable by filter. \n\nArguments\n\nmags::AbstractVector{<:AbstractVector{<:Number}}: a vector of vectors giving the magnitudes of each star to be modelled. The first index is the per-star index and the second index is the per-filter index (so mags[10][2] would give the magnitude of the tenth star in the second filter). This is the same format as the magnitudes returned by generate_stars_mass and generate_stars_mag; to use output from the composite versions, you must first reduce(vcat,mags) before passing to this function.\nerrfuncs: an iterable (typically a vector or tuple) of callables (typically functions or interpolators) with length equal to the number of filters contained in the elements of mags. This iterable must contain callables that, when called with the associated magnitudes from mags, will return the expected 1-σ photometric error at that magnitude. The organization is such that the photometric error for star i in band j is σ_ij = errfuncs[j](mags[i][j]). \ncompletefuncs: an iterable (typically a vector or tuple) of callables (typically functions or interpolators) with length equal to the number of filters contained in the elements of mags. This iterable must contain callables that, when called with the associated magnitudes from mags, will return the probability that a star with that magnitude in that band will be found in your color-magnitude diagram (this should include the original detection probability and any post-detection quality, morphology, or other cuts). The organization is such that the detection probability for star i in band j is c_ij = completefuncs[j](mags[i][j]).\n\nKeyword Arguments\n\nrng::AbstractRNG=Random.default_rng(): The object to use for random number generation.\nret_idxs::Bool: whether to return the indices of the input mags for the stars that were successfully \"observed\" and are represented in the output new_mags.\n\nReturns\n\nnew_mags: an object similar to mags (i.e., a Vector{Vector{<:Number}}, Vector{SVector{N,<:Number}}, etc.) containing the magnitudes of the mock-observed stars. This will be shorter than the provided mags vector as we are modelling photometric incompleteness, and the magnitudes will also have random photometric errors added to them. This can be reinterpreted as a 2-dimensional Matrix with reduce(hcat,new_mags).\ngood_idxs: if ret_idxs is true, the vector of indices into the input mags for the stars that were successfully \"observed\" and are represented in the output new_mags.\n\nNotes\n\nThis is a simple implementation that seeks to show a simple example of how one can post-process catalogs of \"pure\" stars from methods like generate_stars_mass and generate_stars_mag to include observational effects. This method assumes Gaussian photometric errors, which may not, in general, be accurate. It also assumes that the total detection probability can be modelled as the product of the single-filter detection probabilities as computed by completefuncs (i.e., that the completeness functions are separable across filters). This can be a reasonable assumption when you have separate photometric catalogs derived for each filter and you only collate them afterwards, but it is generally not a good assumption for detection algorithms that operate on simultaneously on multi-band photometry – the completeness functions for these types of algorithms are generally not separable.\n\n\n\n\n\n","category":"function"},{"location":"simulate/#Developer-Internals","page":"Simulating Color-Magnitude Diagrams","title":"Developer Internals","text":"","category":"section"},{"location":"simulate/#StarFormationHistories.ingest_mags","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.ingest_mags","text":"new_mags = ingest_mags(mini_vec::AbstractVector, mags::AbstractVector{T}) where {S <: Number, T <: AbstractVector{S}}\nnew_mags = ingest_mags(mini_vec::AbstractVector, mags::AbstractMatrix{S}) where S <: Number\n\nReinterprets provided mags to be in the correct format for input to Interpolations.interpolate.\n\nReturns\n\nnew_mags::Base.ReinterpretArray{StaticArrays.SVector}: a length(mini_vec) vector of StaticArrays.SVectors containing the same data as mags but formatted for input to Interpolations.interpolate.\n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.sort_ingested","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.sort_ingested","text":"(new_mini_vec, new_mags) = sort_ingested(mini_vec::AbstractVector, mags::AbstractVector)\n\nTakes mini_vec and mags and ensures that mini_vec is sorted (sometimes in PARSEC isochrones they are not) and calls Interpolations.deduplicate_knots! on mini_vec to ensure there are no repeat entries. Arguments must satisfy length(mini_vec) == length(mags). \n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.mass_limits","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.mass_limits","text":"(mmin, mmax) = mass_limits(mini_vec::AbstractVector{<:Number}, mags::AbstractVector{T},\n                 mag_names::AbstractVector{String}, mag_lim::Number,\n                 mag_lim_name::String) where T <: AbstractVector{<:Number}\n\nCalculates initial mass limits that reflect a given faint-end magnitude limit.\n\nArguments\n\nmini_vec::AbstractVector{<:Number}: a length nstars vector containing initial stellar masses.\nmags::AbstractVector{<:AbstractVector{<:Number}}: a length nstars vector, with each element being a length nfilters vector giving the magnitudes of each star in the filters mag_names.\nmag_names::AbstractVector{String}: a vector giving the names of each filter as strings.\nmag_lim::Number: the faint-end magnitude limit you wish to use.\nmag_lim_name::String: the name of the filter in which mag_lim is to be applied. Must be contained in mag_names.\n\nReturns\n\nmmin::eltype(mini_vec): the initial mass corresponding to your requested mag_lim in the filter mag_lim_name. If all stars provided are brighter than your requested mag_lim, then this will be equal to minimum(mini_vec).\nmmax::eltype(mini_vec): the maximum valid mass in mini_vec; simply maximum(mini_vec).\n\nExamples\n\njulia> mass_limits([0.05,0.1,0.2,0.3], [[4.0],[3.0],[2.0],[1.0]], [\"F090W\"], 2.5, \"F090W\")\n(0.15, 0.3)\n\njulia> mass_limits([0.05,0.1,0.2,0.3], [[4.0,3.0],[3.0,2.0],[2.0,1.0],[1.0,0.0]], [\"F090W\",\"F150W\"], 2.5, \"F090W\")\n(0.15, 0.3)\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#Low-Level-Functions","page":"Low-Level Functions","title":"Low-Level Functions","text":"","category":"section"},{"location":"fitting/internals/#StarFormationHistories.composite!","page":"Low-Level Functions","title":"StarFormationHistories.composite!","text":" composite!(composite::AbstractMatrix{<:Number},\n            coeffs::AbstractVector{<:Number},\n            models::AbstractVector{T}) where T <: AbstractMatrix{<:Number}\n\nUpdates the composite matrix in place with the linear combination of sum( coeffs .* models ); this is equation 1 in Dolphin 2002, m_i = sum_j  r_j  c_ij.\n\nExamples\n\njulia> C = zeros(5,5);\njulia> models = [rand(size(C)...) for i in 1:5];\njulia> coeffs = rand(length(models));\njulia> composite!(C, coeffs, models);\njulia> C ≈ sum( coeffs .* models)\ntrue\n\n\n\n\n\ncomposite!(composite::AbstractVector{<:Number},\n           coeffs::AbstractVector{<:Number},\n           models::AbstractMatrix{<:Number})\n\nUpdates the composite vector with the matrix-vector product of models * coeffs. This is equation 1 in Dolphin 2002, m_i = sum_j  r_j  c_ij.\n\nExamples\n\njulia> hist_size = (5,10);\njulia> models = reduce(hcat,rand(prod(hist_size)) for i in 1:20);\njulia> coeffs = rand(length(axes(models,2)));\njulia> C = zeros(length(axes(models,1)));\njulia> composite!(C, coeffs, models);\njulia> C ≈ models * coeffs\ntrue\n\nNotes\n\nWhile the other call signature for this function more closely mirrors the natural data structure for Hess diagrams (2D matrices for composite and each entry in models), this method operates on the same data but flattened. Thus composite becomes a vector rather than a matrix and models becomes a single matrix rather than a vector of matrices. The method StarFormationHistories.stack_models is provided to stack the models into this format. This data layout enables us to use the highly optimized LinearAlgebra.mul! function to perform the matrix-vector product which typically achieves >30% speedup relative to the more natural formulation. Additionally, as mul! will typically call to a BLAS matrix-vector product function like gemv! for our use-case, we can switch out Julia's default OpenBLAS at runtime for other BLAS libraries with Julia bindings like MKL and Apple Accelerate, enabling even greater performance improvements.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.loglikelihood","page":"Low-Level Functions","title":"StarFormationHistories.loglikelihood","text":"loglikelihood(composite::AbstractArray{<:Number}, data::AbstractArray{<:Number})\n\nReturns the logarithm of the Poisson likelihood ratio given by equation 10 in Dolphin 2002,\n\ntextln  mathscrL = sum_i -m_i + n_i times left( 1 - textln  left( fracn_im_i right) right)\n\nwith composite being the complex Hess model diagram m_i (see StarFormationHistories.composite!) and data being the observed Hess diagram n_i.\n\nPerformance Notes\n\n~18.57 μs for composite=Matrix{Float64}(undef,99,99) and data=similar(composite).\n~20 μs for composite=Matrix{Float64}(undef,99,99) and data=Matrix{Int64}(undef,99,99).\n~9.3 μs for composite=Matrix{Float32}(undef,99,99) and data=similar(composite).\n~9.6 μs for composite=Matrix{Float32}(undef,99,99) and data=Matrix{Int64}(undef,99,99).\n\n\n\n\n\nloglikelihood(coeffs::AbstractVector{<:Number},\n              models::AbstractVector{T},\n              data::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\nloglikelihood(coeffs::AbstractVector{<:Number},\n              models::AbstractMatrix{<:Number},\n              data::AbstractVector{<:Number})\n\nReturns the logarithm of the Poisson likelihood ratio, but constructs the complex Hess diagram model as sum(coeffs .* models) rather than taking composite directly as an argument. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.∇loglikelihood","page":"Low-Level Functions","title":"StarFormationHistories.∇loglikelihood","text":"∇loglikelihood(model::AbstractArray{<:Number},\n               composite::AbstractArray{<:Number},\n               data::AbstractArray{<:Number})\n\nReturns the partial derivative of the logarithm of the Poisson likelihood ratio (StarFormationHistories.loglikelihood) with respect to the coefficient r_j on the provided model. If the complex Hess diagram model is m_i = sum_j  r_j  c_ij, then model is c_ij, and this function computes the partial derivative of textlog  mathscrL with respect to the coefficient r_j. This is given by equation 21 in Dolphin 2002,\n\nfracpartial  textlog  mathscrLpartial  r_j = sum_i c_ij left( fracn_im_i - 1 right)\n\nwhere n_i is bin i of the observed Hess diagram data. \n\nPerformance Notes\n\n~4.1 μs for model, composite, data all being Matrix{Float64}(undef,99,99).\n~1.3 μs for model, composite, data all being Matrix{Float32}(undef,99,99). \n\n\n\n\n\n∇loglikelihood(models::AbstractVector{T},\n               composite::AbstractMatrix{<:Number},\n               data::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\n∇loglikelihood(models::AbstractMatrix{<:Number},\n               composite::AbstractVector{<:Number},\n               data::AbstractVector{<:Number})\n\nComputes the gradient of the logarithm of the Poisson likelihood ratio with respect to the coefficients by calling the single-model ∇loglikelihood for every model in models. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n∇loglikelihood(coeffs::AbstractVector{<:Number},\n               models::AbstractVector{T},\n               data::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\n∇loglikelihood(coeffs::AbstractVector{<:Number},\n               models::AbstractMatrix{<:Number},\n               data::AbstractVector{<:Number})\n\nForms the composite matrix from coefficients coeffs and model templates models and returns the gradient of the loglikelihood with respect to the coefficients. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.∇loglikelihood!","page":"Low-Level Functions","title":"StarFormationHistories.∇loglikelihood!","text":" ∇loglikelihood!(G::AbstractVector,\n                 composite::AbstractMatrix{<:Number},\n                 models::AbstractVector{S},\n                 data::AbstractMatrix{<:Number}) where S <: AbstractMatrix{<:Number}\n\nEfficiently computes the gradient of StarFormationHistories.loglikelihood with respect to all coefficients by updating G with the gradient. This will overwrite composite with the result of 1 .- (data ./ composite) so it shouldn't be reused after being passed to this function. \n\nArguments\n\nG::AbstractVector is the vector that  will be mutated in-place with the computed gradient values.\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is the vector of matrices giving the model Hess diagrams.\ncomposite::AbstractMatrix{<:Number} is a matrix that contains the composite model sum(coeffs .* models).\ndata::AbstractMatrix{<:Number} contains the observed Hess diagram that is being fit.\n\n\n\n\n\nG = ∇loglikelihood!(G::AbstractVector,\n                    composite::AbstractVector{<:Number},\n                    models::AbstractMatrix{<:Number},\n                    data::AbstractVector{<:Number})\n\nUpdates and returns G with the gradient of the loglikelihood with respect to all coefficients. This call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.fg!","page":"Low-Level Functions","title":"StarFormationHistories.fg!","text":"fg!(F, G, MH_model0::AbstractMetallicityModel,\n    disp_model0::AbstractDispersionModel,\n    variables::AbstractVector{<:Number},\n    models::Union{AbstractMatrix{<:Number},\n                  AbstractVector{<:AbstractMatrix{<:Number}}},\n    data::Union{AbstractVector{<:Number}, AbstractMatrix{<:Number}},\n    composite::Union{AbstractVector{<:Number}, AbstractMatrix{<:Number}},\n    logAge::AbstractVector{<:Number},\n    metallicities::AbstractVector{<:Number})\n\nMain function that differs between AMR and MZR models that accounts for the difference in the gradient formulations between models. F and G mirror the Optim.jl interface for computing the objective and gradient in a single function to make use of common intermediate computations.\n\nArguments\n\nF controls whether the objective is being requested. If !isnothing(F), the negative log likelihood will be returned from fg!.\nG controls whether the gradient of the objective with respect to the variables is being requested. If !isnothing(G), G will be updated in-place with the gradient of the negative log likelihood with respect to the fitting parameters variables.\nMH_model0 is an instance of a concrete subtype of AbstractMetallicityModel (e.g., PowerLawMZR) that specifies the metallicity evolution model to use. The parameters contained in MH_model0 are used as initial parameters to begin the optimization in fit_sfh, but are not used internally in fg! – new instances are constructed from variables instead.\ndisp_model0 is an instance of a concrete subtype of AbstractDispersionModel (e.g., GaussianDispersion) that specifies the PDF of the metallicities of stars forming at fixed time. The parameters contained in disp_model0 are used as initial parameters to begin the optimization in fit_sfh, but are not used internally in fg! – new instances are constructed from variables instead.\nvariables are the fitting parameters, including free and fixed parameters. This vector is split into stellar mass coefficients R_j, metallicity model parameters, and dispersion model parameters, and so must contain all relevant fittable parameters, even those that are to be fixed during the solve.\nmodels are the template Hess diagrams for the SSPs that compose the observed Hess diagram.\ndata is the Hess diagram for the observed data.\ncomposite is the pre-allocated array in which to store the complex Hess diagram model. Must have same shape as data.\nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. These should be logarithmic abundances like [M/H] or [Fe/H]. There are some notes on the Wikipedia that might be useful.\n\nReturns\n\nNegative log likelihood if !isnothing(F).\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.truncate_relweights","page":"Low-Level Functions","title":"StarFormationHistories.truncate_relweights","text":"keep_idx::Vector{Int} =\n    truncate_relweights(relweightsmin::Number,\n                        relweights::AbstractVector{<:Number},\n                        logAge::AbstractVector{<:Number})\n\nMethod to truncate an isochrone grid with log10(age [yr]) values logAge and relative weights relweights derived from a hierarchical metallicity evolution model to only include template models with relweights greater than relweightsmin times the maximum relative weight for each unique entry in logAge. The input vectors are the same as those for StarFormationHistories.fixed_amr, which includes more information. Returns a vector of the indices into relweights and logAge of the template models whose relative weights are significant given the provided relweightsmin.\n\nExamples\n\nWhen using a fixed input age-metallicity relation as enabled by, for example, StarFormationHistories.fixed_amr, only the star formation rate (or total stellar mass) coefficients need to be fit, as the metallicity distribution is no longer a free parameter in the model. As such, the relative weights of each model with identical logAge but different metallicities only need to be computed once at the start of the optimization. As the metallicity distribution is not a free parameter, it is also possible to truncate the list of models to only those that contribute significantly to the final composite model to improve runtime performance. That is what this method does.\n\nA simple isochrone grid will be two-dimensional, encompassing age and metallicity. Consider a subset of the model grid with the same age such that unique(logAge) = [10.0] but a series of different metallicities, metallicities = -2.5:0.25:0. If we model the metallicity distribution function for this age as having a mean [M/H] of -2.0 and a Gaussian spread of 0.2 dex, then the relative weights of these models can be approximated as \n\nimport Distributions: Normal, pdf\nmetallicities = -2.5:0.25:0\nrelweights = pdf.(Normal(-2.0, 0.2), metallicities)\nrelweights ./= sum(relweights) # Normalize the relative weights to unity sum\n\n11-element Vector{Float64}:\n 0.021919934465195145\n 0.2284109622221623\n 0.4988954088848224\n 0.2284109622221623\n 0.021919934465195145\n 0.0004409368867815243\n 1.8592101580561089e-6\n 1.6432188478108614e-9\n 3.0442281937632026e-13\n 1.1821534989089337e-17\n 9.622444440364979e-23\n\nSeveral of these models with very low relative weights are unlikely to contribute significantly to the final composite model. We can select out only the significant ones with, say, relative weights greater than 10% of the maximum as StarFormationHistories.truncate_relweights(0.1, relweights, fill(10.0,length(metallicities))) which will return indices into relweights whose values are greater than 0.1 * maximum(relweights) = 0.04988954088848224,\n\n3-element Vector{Int64}:\n 2\n 3\n 4\n\nwhich correspond to relweights[2,3,4] = [ 0.2284109622221623, 0.4988954088848224, 0.2284109622221623 ]. If we use only these 3 templates in the fit, instead of the original 11, we will achieve a speedup of almost 4x with a minor loss in precision which, in most cases, will be less than the numerical uncertainties on the individual star formation rate parameters. However, as fits of these sort are naturally quite fast, we recommend use of this type of truncation only in applications where many fits are required (e.g., Monte Carlo experiments). For most applications, this level of optimization is not necessary.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.calculate_edges","page":"Low-Level Functions","title":"StarFormationHistories.calculate_edges","text":"calculate_edges(edges, xlim, ylim, nbins, xwidth, ywidth)\n\nFunction to calculate the bin edges for 2D histograms. Returns (xbins, ybins) with both entries being ranges.\n\nKeyword Arguments\n\nedges is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: (-1.0:0.1:1.5, 22:0.1:27.2). If edges is provided, it will simply be returned.\nxlim is a length-2 indexable object (e.g., a Vector{Float64} or NTuple{2,Float64)) giving the lower and upper bounds on the x-axis corresponding to the provided colors array. Example: [-1.0, 1.5]. This is only used if edges==nothing.\nylim is like xlim but  for the y-axis corresponding to the provided mags array. Example [25, 20]. This is only used if edges==nothing.\nnbins::NTuple{2,<:Integer} is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if edges==nothing.\nxwidth is the bin width along the x-axis for the colors array. This is only used if edges==nothing and nbins==nothing. Example: 0.1. \nywidth is like xwidth but for the y-axis corresponding to the provided mags array. Example: 0.1.\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/MZR/MZR_old/#MZR_old","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"The parametric age-metallicity relations (AMRs) provided by this package are typically sufficient to provide good fits to observed CMDs with very few degrees of freedom. However, they are somewhat arbitrary and unphysical as they have no direct relation to the underlying star formation activity, which is what enrichs the ISM in the first place. As such, physical interpretation of AMRs is dubious – rather, it is often the population-integrated metallicity distribution functions (MDFs) which are compared against external datasets that directly probe stellar metallicities (e.g., single-star spectroscopy).","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"As we are simultaneously fitting both the historical star formation rates (SFRs) and the metallicity at which those stars are forming over time, it is possible to design a framework in which the metallicity evolves in a self-consistent way with the star formation activity. As the AMR describes the mean metallicity of stars forming at different times, it should be most directly related to the metallicity evolution of the star-forming ISM. We therefore need to connect the star formation activity to the ISM metallicity.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"This is complicated by the fact that in general one-zone chemical models, both star-formation driven outflows (which deplete the ISM of both metals and HI) and pristine gas inflows (composed majorly of HI which dilutes the metallicity of the ISM) must be modelled. While hydrodynamic simulations can provide predictions of outflow rates (i.e., through mass-loading factors), the inflow rates are time-variable, depend on the local environment, and generally unconstrained observationally on an object-to-object basis. As such, general one-zone chemical models are unattractive for our purposes.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"A more attractive formulation can be found in the idea of an effective yield, which is the fraction of stellar mass that is composed of metals gamma = M_Z*  M_*. As shown by Torrey et al. 2019, who measured these yields in the Illustris TNG100 simulation, these yields are primarily a function of total galaxy stellar mass and not of redshift. Therefore, the rate of change of the yield with respect to stellar mass fracpartial gammapartial M_* can be connected to the rate at which metals are accumulated in stars as galaxies grow.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"Further, the existence of the gas-phase mass-metallicity relation (MZR) for star-forming galaxies gives us some empirical guidance for an implementation, as the AMR should be mostly connected to the gas-phase metallicity. While the MZR is mostly unconstrained for the low-mass galaxies that are typically studied in the Local Universe with resolved photometry (M_*  10^8  textM_odot), the MZR is often extrapolated to low masses as a power law in stellar mass.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"While it is known that higher-mass galaxies do not strictly evolve along the MZR, due in large part to the time variability of inflows mentioned above, the simple form of the power law extrapolation of the MZR allows for a simple experiment. If (on average) the ISM metallicity at time t is primarily driven by the total stellar mass at that time M_*(t), then a two-parameter MZR (power law slope and intercept) coupled to the SFRs in the SFH fitting process should result in better CMD models than a similar two-parameter AMR (e.g., the linear AMR model) which has no mathematical link to the SFRs. In turn, the best-fit SFRs and population-integrated MDFs should also be more accurate if the modelled AMR is better.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/#Derivation","page":"OLD Mass-Metallicity Relations (MZRs)","title":"Derivation","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"We once again wish to derive the gradient of the objective function with respect to the fitting parameters to enable gradient-based optimization. Our derivation will reuse some of the notation developed in the section on the linear AMR. The main difference is that instead of expressing the mean metallicity as a function of time langle textMtextH rangle (t), with an MZR we express the mean metallicity as a function of stellar mass at that time langle textMtextH rangle (textM_*(t)). This means that the partial derivatives of the objective with respect to the stellar mass coefficients have a more complex form than in the AMR case, as changing the stellar mass formed 10 Gyr ago (for example) would change the total stellar mass at all more recent times, which in turn changes the mean metallicity expected at all more recent times.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"In the derivations for AMRs we were agnostic about the choice of template normalization; templates could either be normalized to have units of expected number of stars per solar mass of stars formed N  textM_odot, or expected number of stars per unit star formation rate N  dottextM_odot. Changing the units of the templates would, in turn, change the units of the fitting variables returned by the fitting routines, but as shown in our example Jupyter notebook, the fit results are the same no matter the choice of fitting units. For an MZR, we must know the units of the templates and fitting variables so that we may properly calculate the total cumulative stellar mass as a function of time. For simplicity, we assume templates are normalized to number of stars per solar mass of stars formed N  textM_odot and that the fitting variables are therefore the total stellar mass ascribed to each time bin – this is the default behavior for the template creation routines.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"Borrowing notation from the fitting introduction and the section on linear AMRs, the bin m_i of the complex model Hess diagram can be written as the sum over the grid of templates with ages indexed by j and metallicities indexed by k as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"m_i = sum_jk  r_jk  c_ijk","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"where m_i is the value of the complex model in bin i, c_ijk is the value of the SSP template with age j and metallicity k in bin i, and r_jk is the multiplicative coefficient determining how significant the template is to the complex population.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"The gradient of the objective with respect to the r_jk is given by Equation 21 in Dolphin 2001 as shown in the section on linear AMRs,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nF equiv - textln  mathscrL = sum_i m_i - n_i times left( 1 - textln  left( fracn_im_i right) right) \nfracpartial  Fpartial  r_jk = sum_i c_ijk left( 1 - fracn_im_i right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"where n_i is bin i of the observed Hess diagram. These partial derivatives are easy to obtain, but we need partials with respect to the total stellar mass formed at each distinct age, R_j. These are more complicated that the same partial derivatives under an AMR model.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"For the purposes of illustration, we will consider a power law MZR with slope alpha as is typically used to describe the extrapolation of gas-phase MZRs to masses below 10^8 textM_odot. Under this model, we can express the mean metallicity at time j, notated as mu_j, as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nmu_j = textMtextH_0 + textlog left( left( fractextM_* (t_j)textM_0 right)^alpha right) \n= textMtextH_0 + alpha  left( textlog left( textM_* (t_j) right) - textlog left( textM_0 right) right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"where the power law MZR is normalized such that the mean metallicity is textMtextH_0 at stellar mass textM_0. Note that the MZR comes linear with slope alpha when expressed in textlog(textM_*). As in the AMR models, we use a Gaussian to introduce some metallicity dispersion at fixed time, such that the r_jk are","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nr_jk = R_j  frac textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nA_jk = textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nr_jk = R_j  fracA_jksum_k A_jk \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"where the R_j are the fitting variables representing the total stellar mass formed at each distinct age in the template grid. We define A_jk to substitute in for the broadening PDF, as the Gaussian could easily be substituted for other forms with minimal changes to the derivation. The three parameters in the MZR model are therefore the power law slope alpha, a normalization/intercept parameter textMtextH_0, and the metallicity broadening parameter sigma; this is the same number of parameters as in the linear AMR model.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"We can write the partial derivative of the objective F with respect to the R_j as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"fracpartial  Fpartial  R_j = sum_k  fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"For AMRs, this calculation is simple as the mean metallity at time j, denoted mu_j, is not a function of R_j, and so fracpartial  r_jkpartial  R_j simplifies easily. For MZRs, mu_j is a function of the total stellar mass formed by time t_j, which itself is a function of other R_j which give the total stellar mass formed in their respective time bins. We must therefore apply the chain rule to formulate the total partial derivative fracpartial  Fpartial  R_j.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"Applying the product rule first,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nr_jk = R_j  fracA_jksum_k A_jk \nfracpartial  r_jkpartial  R_j = fracA_jksum_k A_jk + R_j  left( fracfracpartial  A_jkpartial  R_jsum_k A_jk - fracA_jk  fracpartial  sum_k A_jkpartial  R_jleft(sum_k A_jkright)^2 right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"In AMR models, the term in parentheses on the right hand side is zero as the partial derivatives of all A_jk with respect to the stellar mass coefficients R_j are zero. These terms are new for the MZR model, as A_jk depends on mu_j which depends on the R_j through the total stellar mass formed by time t_j. ","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"The first term can be replaced by an equivalent expression which is often more convenient: fracA_jksum_k A_jk = fracr_jkR_j. The term fracpartial  sum_k A_jkpartial  R_j can be replaced by noting that the partial derivative with respect to R_j of the sum over k of the A_jk must be equal to the sum over k of the partial derivatives of the individual A_jk with respect to R_j such that the following equivalency holds true: fracpartial  sum_k A_jkpartial  R_j = sum_k fracpartial  A_jkpartial R_j. We therefore have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  r_jkpartial  R_j = fracA_jksum_k A_jk + R_j  left( fracfracpartial  A_jkpartial  R_jsum_k A_jk - fracA_jk  fracpartial  sum_k A_jkpartial  R_jleft(sum_k A_jkright)^2 right) \n= fracr_jkR_j + R_j  left( fracfracpartial  A_jkpartial  R_jsum_k A_jk - fracA_jk  sum_k fracpartial  A_jkpartial  R_jleft(sum_k A_jkright)^2 right) \n= fracr_jkR_j + fracR_jsum_k A_jk left( fracpartial  A_jkpartial  R_j - fracA_jk  sum_k fracpartial  A_jkpartial  R_jsum_k A_jk right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"We now need to formulate the partial derivatives of the dispersion weights with respect to the stellar mass coefficients, fracpartial  A_jkpartial  R_j. The dependence of the A_jk on the R_j is manifested through the dependence of the A_jk on mu_j, which itself is dependent on the R_j. We will assume the mu_j for all general MZR models can be expressed as a function of the stellar mass at time t_j, which we denote textM_* left( t_j right), and that the stellar mass depends on the R_j. Applying the chain rule,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_jkpartial  R_j = fracpartial  A_jkpartial  mu_j fracpartial  mu_jpartial  R_j \nfracpartial  mu_jpartial  R_j = fracpartial  mu_jpartial  textM_* left( t_j right)  fracpartial  textM_* left( t_j right)partial R_j \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"In the case that the R_j represent the amount of stellar mass formed in time bin t_j, then the second term reduces to 1. Let the R_j be sorted in order from earliest time t_j (i.e., largest lookback time) to most recent time (i.e., lowest lookback time). The cumulative stellar mass textM_* left( t_j right) can therefore be expressed as the sum over the R_j^prime for j^prime leq j, such that","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\ntextM_* left( t_j right) = sum_j^prime=0^j^prime=j R_j^prime \nfracpartial  textM_* left( t_j right)partial R_j = 1 \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"We can therefore make the simplification","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  mu_jpartial  R_j = fracpartial  mu_jpartial  textM_* left( t_j right)  fracpartial  textM_* left( t_j right)partial R_j \n= fracpartial  mu_jpartial  textM_* left( t_j right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"so that the partial derivatives of the A_jk with respect to the R_j become","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_jkpartial  R_j = fracpartial  A_jkpartial  mu_j fracpartial  mu_jpartial  R_j \n= fracpartial  A_jkpartial  mu_j fracpartial  mu_jpartial  textM_* left( t_j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"The forms of these partials will depend on the choices of the metallicity dispersion profile at fixed time, which sets the first term involving A_jk, as well as the form of the MZR model which will set the partial derivative of the mean metallicity at time j, mu_j, with respect to the cumulative stellar mass at time t_j. For our choice of a Gaussian metallicity dispersion profile at fixed time we have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nA_jk = textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nfracpartial  A_jkpartial  mu_j = fracA_jksigma^2 left( textMtextH_k - mu_j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"and for our choice of a power law MZR we have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"beginaligned\nmu_j = textMtextH_0 + alpha  left( textlog left( textM_* (t_j) right) - textlog left( textM_0 right) right) \nfracpartial  mu_jpartial  textM_* left( t_j right) = fracalphatextM_* left( t_j right)  textln  10 \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR_old/","page":"OLD Mass-Metallicity Relations (MZRs)","title":"OLD Mass-Metallicity Relations (MZRs)","text":"such that we now have all the terms we need to compute the fracpartial  r_jkpartial  R_j which enables us to compute the partial derivatives of the objective with respect to the R_j, fracpartial  Fpartial  R_j = sum_k  fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j.","category":"page"},{"location":"binaries/#binaries","page":"Binary Systems","title":"Binary Systems","text":"","category":"section"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"Here we review the API for including binary systems in our population models. Our Monte Carlo sampling methods supports all three models, while our smooth template modelling procedure only supports NoBinaries and RandomBinaryPairs. A comparison between a Monte Carlo population and a smooth template model for a RandomBinaryPairs model with binary fraction of 70% is shown below. The redward shift of the lower main sequence typical of populations with high binary fractions is clearly evident and robustly modelled.","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"mv(\"../../examples/templates/template_compare_binaries.svg\", \"template_compare_binaries.svg\") # hide\nmv(\"../../examples/templates/sigma_distribution_binaries.svg\", \"sigma_distribution_binaries.svg\") # hide\nnothing # hide","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"(Image: Comparison of CMD-sampled population with smooth Hess diagram template, with binaries.)","category":"page"},{"location":"binaries/#Types","page":"Binary Systems","title":"Types","text":"","category":"section"},{"location":"binaries/#StarFormationHistories.AbstractBinaryModel","page":"Binary Systems","title":"StarFormationHistories.AbstractBinaryModel","text":"StarFormationHistories.AbstractBinaryModel is the abstract supertype for all types that are used to model multi-star systems in the package. All concrete subtypes should implement the following methods to support all features:\n\nStarFormationHistories.sample_system\nStarFormationHistories.binary_system_fraction\nStarFormationHistories.binary_mass_fraction\nBase.length, which should return an integer indicating the number of stars per system that can be sampled by the model; this is equivalent to the length of the mass vector returned by sample_system.\n\nNote that all quantities relating to binary populations (e.g., binary_system_fraction) should be defined for the population at birth. As the stars in a binary system evolve, the more massive star may die before the system is observed at present-day. Of course, the stars in single-star systems can also die. If the rate at which binary systems become single-star systems is not equal to the rate at which single-star systems die, then there can be net transfer between these populations over time. Therefore the observed, present-day binary system fraction of an evolved population is not necessarily equal to the fraction at birth, which is the more fundamental quantity.\n\n\n\n\n\n","category":"type"},{"location":"binaries/#StarFormationHistories.NoBinaries","page":"Binary Systems","title":"StarFormationHistories.NoBinaries","text":"NoBinaries()\n\nThe NoBinaries type indicates that no binaries of any kind should be created. \n\n\n\n\n\n","category":"type"},{"location":"binaries/#StarFormationHistories.RandomBinaryPairs","page":"Binary Systems","title":"StarFormationHistories.RandomBinaryPairs","text":"RandomBinaryPairs(fraction::Real)\n\nThe RandomBinaryPairs type takes one argument 0 <= fraction::Real <= 1 that denotes the number fraction of stellar systems that are binaries (e.g., 0.3 for 30% binary fraction) and will sample binaries as random pairs of two stars drawn from the same single-star IMF. This model will ONLY generate up to one additional star – it will not generate any 3+ star systems. This model typically incurs a 10–20% speed penalty relative to NoBinaries. \n\n\n\n\n\n","category":"type"},{"location":"binaries/#StarFormationHistories.BinaryMassRatio","page":"Binary Systems","title":"StarFormationHistories.BinaryMassRatio","text":"BinaryMassRatio(fraction::Real,\n                qdist::Distributions.ContinuousUnivariateDistribution =\n                    Distributions.Uniform(0.1, 1.0))\n\nThe BinaryMassRatio type takes two arguments; the number fraction of stellar systems that are binaries 0 <= fraction::Real <= 1 and a continuous univariate distribution qdist from which to sample binary mass ratios, defined as the ratio of the secondary mass to the primary mass: q = textM_S  textM_P. The provided qdist must have the proper support of (minimum(qdist) >= 0) & (maximum(qdist) <= 1). Users may find the Distributions.truncated method useful for enforcing this support on more general distributions. The default qdist is a uniform distribution from 0.1 to 1, which appears to give reasonably good agreement to observations (see, e.g., Goodwin 2013).\n\n\n\n\n\n","category":"type"},{"location":"binaries/#Methods","page":"Binary Systems","title":"Methods","text":"","category":"section"},{"location":"binaries/#StarFormationHistories.binary_system_fraction","page":"Binary Systems","title":"StarFormationHistories.binary_system_fraction","text":"binary_system_fraction(model::T) where T <: AbstractBinaryModel\n\nReturns the number fraction of stellar systems that are binaries for the given concrete subtype T <: AbstractBinaryModel. Has a default implementation of binary_system_fraction(model::AbstractBinaryModel) = model.fraction.\n\n\n\n\n\n","category":"function"},{"location":"binaries/#StarFormationHistories.binary_number_fraction","page":"Binary Systems","title":"StarFormationHistories.binary_number_fraction","text":"binary_number_fraction(model::T) where T <: AbstractBinaryModel\n\nReturns the number fraction of stars that in binary pairs for the given concrete subtype T <: AbstractBinaryModel. Has a default implementation of 2b / (1+b), where b is the result of StarFormationHistories.binary_system_fraction.\n\n\n\n\n\n","category":"function"},{"location":"binaries/#StarFormationHistories.binary_mass_fraction","page":"Binary Systems","title":"StarFormationHistories.binary_mass_fraction","text":"binary_mass_fraction(model::T, imf) where T <: AbstractBinaryModel\n\nReturns the fraction of stellar mass in binary systems for the given concrete subtype T <: AbstractBinaryModel and initial mass function imf. imf must be a properly normalized probability distribution such that the number fraction of stars/systems between mass m1 and m2 is given by the integral of dispatch_imf(imf, x) from m1 to m2. \n\n\n\n\n\nbinary_mass_fraction(m::RandomBinaryPairs, imf)\n\nThe RandomBinaryPairs model uses a single-star imf. If a system is chosen to be a binary pair, two stars are drawn from the single-star imf and the more massive star is made the primary. Given this model, it can be shown that the expectation value for the mass of a binary system is twice the expectation value for single star systems:\n\n2int_textM_textmin^textM_textmax textM fracdtextN left( textM right)dtextM  dtextM  =  int_textM_textmin^textM_textmax int_textM_textmin^textM_textmax left( textM_P + textM_S right) fracdtextN left( textM_S right)dtextM fracdtextN left( textM_P right)dtextM dtextM_S  dtextM_P\n\nfor primary mass textM_P, secondary mass textM_S, and single-star IMF dtextN  dtextM. As such, the fraction of total stellar mass in binaries is equal to the number fraction of all stars in binary pairs, which is given by StarFormationHistories.binary_number_fraction.\n\n\n\n\n\nbinary_mass_fraction(m::BinaryMassRatio, imf)\n\nThis binary model requires an imf that is defined by stellar system mass. If a system with a randomly sampled mass M is is a binary, the primary and secondary mass are determined based on a binary mass ratio q sampled from a user-defined distribution. By definition, the expectation value for the total mass of a binary system is equal to the expectation value for single-star systems. In this case the binary mass fraction is equal the binary system number fraction as given by StarFormationHistories.binary_system_fraction.\n\n\n\n\n\n","category":"function"},{"location":"binaries/#StarFormationHistories.sample_system","page":"Binary Systems","title":"StarFormationHistories.sample_system","text":"masses = sample_system(imf, rng::AbstractRNG, binarymodel::StarFormationHistories.AbstractBinaryModel)\n\nSimulates the effects of non-interacting, unresolved stellar companions on stellar photometry. Implementation depends on the choice of binarymodel.\n\nArguments\n\nimf: an object implementing rand(imf) to draw a random mass for a single star or a stellar system (depends on choice of binarymodel)\nrng::AbstractRNG: the random number generator to use when sampling stars\nbinarymodel::StarFormationHistories.AbstractBinaryModel: an instance of a binary model that determines which implementation will be used; currently provided options are NoBinaries, RandomBinaryPairs, and BinaryMassRatio.\n\nReturns\n\nmasses::SVector{N,eltype(imf)}: the masses of the individual stars sampled in the system in descending order where N is the maximum number of stars that can be sampled by the provided binarymodel as given by Base.length(binarymodel). \n\n\n\n\n\n","category":"function"},{"location":"binaries/#Notes","page":"Binary Systems","title":"Notes","text":"","category":"section"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"The trickiest part of including binaries in the smooth template modelling procedure is deriving the IMF weights. Let M_p be the sorted list of initial masses for primary stars and M_s be the sorted list of initial masses for secondary stars. Conceptually, the IMF weight for a binary system with primary mass M_pi and secondary mass M_sj should compute the number fraction of binary systems born with primary masses between M_pi and M_pi+1 and secondary masses between M_sj and M_sj+1 per unit solar mass formed. ","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"In the case of the RandomBinaryPairs model, the IMF weights are calculated as follows, with dN(M)dM being the IMF for single stars, langle M rangle being the mean mass of single stars over the full range of possible initial masses, and the integral in the denominator being over the range of initial masses in the isochrone. The integral in the denominator accounts for losses due to stellar evolution.","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"  w_textIMFij = fracint_M_pi^M_pi+1 int_M_sj^M_sj+1 fracdN(M_p)dM fracdN(M_s)dM  dM_p  dM_slangle M rangle  int_M_textmin^M_textmax fracdN(M)dM  dM","category":"page"},{"location":"helpers/#helpers","page":"Helper Functions","title":"Helper Functions","text":"","category":"section"},{"location":"helpers/#Distances-and-Sizes","page":"Helper Functions","title":"Distances and Sizes","text":"","category":"section"},{"location":"helpers/#StarFormationHistories.arcsec_to_pc","page":"Helper Functions","title":"StarFormationHistories.arcsec_to_pc","text":"arcsec_to_pc(arcsec, dist_mod)\n\nConverts on-sky angle in arcseconds to physical separation based on distance modulus under the small-angle approximation.\n\nr  10^μ5 + 1 times textatan(θ3600)\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.pc_to_arcsec","page":"Helper Functions","title":"StarFormationHistories.pc_to_arcsec","text":"pc_to_arcsec(pc, dist_mod)\n\nInverse of arcsec_to_pc.\n\nθ  texttanleft( r  10^μ5 + 1 right) times 3600\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.distance_modulus","page":"Helper Functions","title":"StarFormationHistories.distance_modulus","text":"distance_modulus(distance)\n\nFinds distance modulus for distance in parsecs.\n\nμ = 5 times log_10(d) - 5\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.distance_modulus_to_distance","page":"Helper Functions","title":"StarFormationHistories.distance_modulus_to_distance","text":"distance_modulus_to_distance(dist_mod)\n\nConverts distance modulus to distance in parsecs.\n\nd = 10^μ5 + 1\n\n\n\n\n\n","category":"function"},{"location":"helpers/#Magnitudes-and-Luminosities","page":"Helper Functions","title":"Magnitudes and Luminosities","text":"","category":"section"},{"location":"helpers/#StarFormationHistories.mag2flux","page":"Helper Functions","title":"StarFormationHistories.mag2flux","text":"mag2flux(m, zpt=0)\n\nConvert a magnitude m to a flux assuming a photometric zeropoint of zpt, defined as the magnitude of an object that produces one count (or data number, DN) per second.\n\njulia> mag2flux(15.0, 25.0) ≈ exp10(4 * (25.0 - 15.0) / 10)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.flux2mag","page":"Helper Functions","title":"StarFormationHistories.flux2mag","text":"flux2mag(f, zpt=0)\n\nConvert a flux f to a magnitude assuming a photometric zeropoint of zpt, defined as the magnitude of an object that produces one count (or data number, DN) per second.\n\njulia> flux2mag(10000.0, 25.0) ≈ 25.0 - 5 * log10(10000.0) / 2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.magerr","page":"Helper Functions","title":"StarFormationHistories.magerr","text":"magerr(f, σf)\n\nReturns an error in magnitudes given a flux and a flux uncertainty.\n\njulia> magerr(100.0, 1.0) ≈ 2.5 / log(10) * (1.0 / 100.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.fluxerr","page":"Helper Functions","title":"StarFormationHistories.fluxerr","text":"fluxerr(f, σm)\n\nReturns an error in flux given a flux and a magnitude uncertainty.\n\njulia> fluxerr(100.0, 0.01) ≈ (0.01 * 100.0) / 2.5 * log(10)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.snr_magerr","page":"Helper Functions","title":"StarFormationHistories.snr_magerr","text":"snr_magerr(σm)\n\nReturns a signal-to-noise ratio (fσf) given an uncertainty in magnitudes.\n\njulia> snr_magerr(0.01) ≈ 2.5 / log(10) / 0.01\ntrue\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.magerr_snr","page":"Helper Functions","title":"StarFormationHistories.magerr_snr","text":"magerr_snr(snr)\n\nReturns a magnitude uncertainty given a signal-to-noise ratio (fσf).\n\njulia> magerr_snr(100.0) ≈ 2.5 / log(10) / 100.0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"helpers/#metallicity_helpers","page":"Helper Functions","title":"Metallicities","text":"","category":"section"},{"location":"helpers/#StarFormationHistories.Y_from_Z","page":"Helper Functions","title":"StarFormationHistories.Y_from_Z","text":"Y_from_Z(Z, Y_p=0.2485, γ=1.78)\n\nCalculates the helium mass fraction (Y) for a star given its metal mass fraction (Z) using the approximation Y = Y_p + γ * Z, with Y_p being the primordial helium abundance Y_p=0.2485 as assumed for PARSEC isochrones and γ=1.78 matching the input scaling for PARSEC as well. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.X_from_Z","page":"Helper Functions","title":"StarFormationHistories.X_from_Z","text":"X_from_Z(Z[, Yp, γ])\n\nCalculates the hydrogen mass fraction (X) for a star given its metal mass fraction (Z) via X = 1 - (Z + Y), with the helium mass fraction Y approximated via StarFormationHistories.Y_from_Z. You may also provide the primordial helium abundance Y_p and γ such that Y = Y_p + γ * Z; these are passed through to X_from_Z. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.MH_from_Z","page":"Helper Functions","title":"StarFormationHistories.MH_from_Z","text":"MH_from_Z(Z, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nCalculates [M/H] = log(Z/X) - log(Z/X)⊙. Given the provided solar metal mass fraction solZ, it calculates the hydrogen mass fraction X for both the Sun and the provided Z with StarFormationHistories.X_from_Z. You may also provide the primordial helium abundance Y_p and γ such that Y = Y_p + γ * Z; these are passed through to X_from_Z. \n\nPARSEC Normalization\n\nFor PARSEC tracks, [M/H]=0 will result in isochrones with Z=0.014711, instead of the Z=0.01524 expected for the present Sun (Caffau et al. 2011). This small offset is caused by the intrinsic difference between the helium content in the model for the present Sun, and the initial helium content for which the PARSEC evolutionary tracks are computed. That is:\n\nThe model for the present Sun is forced to reproduce the observed ratio of Z⊙/X⊙=0.0207. This ratio defines the zero-point of the [M/H] scale, [M/H] = log(Z/X)-log(Z⊙/X⊙).\nThe same solar model has an initial surface composition of Zinitial=0.01774, Yinitial=0.28 (see Table 3 in Bressan et al. 2012). Together with the primordial helium content of Yp=0.2485, these numbers define the relation Y = Yp + 1.78Z, which was used to build the set of initial (Z, Y) values for which we compute the tracks.\nTherefore, the Y(Z) relation used to compute the grids, is respected by the initial Sun, but not by the present Sun (which is affected by diffusion). This creates a 0.015 dex offset between the metallicity scale of the present Sun, and the initial metallicity scale of the computed grids of tracks. See Table 4 in Bressan et al. (2012) for a more complete list of [M/H] values that follow from this approximation.\n\nThe above note was taken from the CMD webform FAQ, copyright Leo Girardi.\n\nThis function is an approximation and may not be suitable for precision calculations.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.dMH_dZ","page":"Helper Functions","title":"StarFormationHistories.dMH_dZ","text":"dMH_dZ(Z, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nPartial derivative of MH_from_Z with respect to the input metal mass fraction Z. Used for LogarithmicAMR.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.Z_from_MH","page":"Helper Functions","title":"StarFormationHistories.Z_from_MH","text":"Z_from_MH(MH, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nCalculates metal mass fraction Z assuming that the solar metal mass fraction is solZ and using the PARSEC relation for the helium mass fraction Y = Y_p + γ * Z with primordial helium abundance Y_p = 0.2485, and γ = 1.78.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.dZ_dMH","page":"Helper Functions","title":"StarFormationHistories.dZ_dMH","text":"dZ_dMH(MH, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nPartial derivative of Z_from_MH with respect to the input metal abundance MH. Used for LogarithmicAMR.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.mdf_amr","page":"Helper Functions","title":"StarFormationHistories.mdf_amr","text":"(unique_MH, mass_mdf) =\nmdf_amr(coeffs::AbstractVector{<:Number},\n        logAge::AbstractVector{<:Number},\n        metallicities::AbstractVector{<:Number})\n\nCalculates the mass-weighted metallicity distribution function given a set of stellar mass coefficients coeffs for stellar populations with logarithmic ages logAge=log10(age [yr]) and metallicities given by metallicities. This is calculated as\n\nP_j = frac sum_k r_jk  textM  textH_ksum_jk r_jk  textM  textH_k\n\nwhere r_jk are the elements of coeffs where j indexes over unique entries in logAge and k indexes over unique entries in metallicities. This is the same nomenclature used in the the documentation on constrained metallicity evolutions. The return values are sorted so that unique_MH is in increasing order.\n\nExamples\n\njulia> mdf_amr([1.0, 2.0, 1.0], [10, 10, 10], [-2, -1.5, -1])\n([-2.0, -1.5, -1.0], [0.25, 0.5, 0.25])\n\n\n\n\n\n(unique_MH, mass_mdf) =\nmdf_amr(coeffs::AbstractVector{<:Number},\n        logAge::AbstractVector{<:Number},\n        metallicities::AbstractVector{<:Number},\n        models::Union{AbstractVector{<:AbstractMatrix{<:Number}},\n                      AbstractMatrix{<:Number}})\n\nCalculates the number-weighted metallicity distribution function given a set of coefficients coeffs for stellar populations with logarithmic ages logAge=log10(age [yr]), metallicities given by metallicities, and Hess diagram templates models. This function constructs a composite Hess diagram (see composite! for definition) out of the coeffs and models that match each unique entry in metallicites. The sums over the bins of these composite Hess diagrams then give the total predicted number of stars in the Hess diagram viewport for each metallicity. The raw number counts for each unique metallicity are returned as mass_mdf – these can be renormalized afterward to sum to one by calculating mass_mdf ./ sum(mass_mdf).\n\nExamples\n\njulia> mdf_amr([1.0, 2.0, 1.0], [10, 10, 10], [-2, -1.5, -1],\n               map(Base.Fix2(fill, (100, 100)), [1.0, 2.0, 1.0]))\n([-2.0, -1.5, -1.0], [10000.0, 40000.0, 10000.0])\n\n\n\n\n\n","category":"function"},{"location":"helpers/#phot_helpers","page":"Helper Functions","title":"Photometric Error and Completeness Models","text":"","category":"section"},{"location":"helpers/#StarFormationHistories.Martin2016_complete","page":"Helper Functions","title":"StarFormationHistories.Martin2016_complete","text":"η(m) = Martin2016_complete(m, A, m50, ρ)\n\nCompleteness model of Martin et al. 2016 implemented as their Equation 7:\n\neta(m) = fracA1 + textexp left( fracm - m_50rho right)\n\nm is the magnitude of interest, A is the maximum completeness, m50 is the magnitude at which the data are 50% complete, and ρ is an effective slope modifier.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.exp_photerr","page":"Helper Functions","title":"StarFormationHistories.exp_photerr","text":"exp_photerr(m, a, b, c, d)\n\nExponential model for photometric errors of the form\n\nsigma(m) = a^b times left( m-c right) + d\n\nReported values for some HST data were a=1.05, b=10.0, c=32.0, d=0.01. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.process_ASTs","page":"Helper Functions","title":"StarFormationHistories.process_ASTs","text":"process_ASTs(ASTs::Union{DataFrames.DataFrame,\n                         TypedTables.Table},\n             inmag::Symbol,\n             outmag::Symbol,\n             bins::AbstractVector{<:Real},\n             selectfunc;\n             statistic=StatsBase.median)\n\nProcesses a table of artificial stars to calculate photometric completeness, bias, and error across the provided bins. This method has no default implementation and is implemented in package extensions that rely on either DataFrames.jl or TypedTables.jl being loaded into your Julia session to load the relevant method. This method therefore requires Julia 1.9 or greater to use.\n\nArguments\n\nASTs is the table of artificial stars to be analyzed.\ninmag is the column name in symbol format (e.g., :F606Wi) that corresponds to the intrinsic (input) magnitudes of the artificial stars.\noutmag is the column name in symbol format (e.g., :F606Wo) that corresponds to the measured (output) magnitude of the artificial stars.\nbins give the bin edges to be used when computing the binned statistics.\nselectfunc is a method that takes a single row from ASTs, corresponding to a single artificial star, and returns a boolean that is true if the star is considered successfully measured.\n\nKeyword Arguments\n\nstatistic is the method that will be used to determine the bias and error, i.e., bias = statistic(out .- in) and error = statistic(abs.(out .- in)). By default we use StatsBase.median, but you could instead use a simple or sigma-clipped mean if so desired.\n\nReturns\n\nThis method returns a result of type NTuple{4,Vector{Float64}}. Each vector is of length length(bins)-1. result contains the following elements, each of which are computed over the provided bins considering only artificial stars for which selectfunc returned true:\n\nresult[1] contains the mean input magnitude of the stars in each bin.\nresult[2] contains the completeness value measured for each bin, defined as the fraction of input stars in each bin for which selectfunc returned true.\nresult[3] contains the photometric bias measured for each bin, defined as statistic(out .- in), where out are the measured (output) magnitudes and in are the intrinsic (input) magnitudes.\nresult[4] contains the photometric error measured for each bin, defined as statistic(abs.(out .- in)), with out and in defined as above.\n\nExamples\n\nLet\n\nF606Wi be a vector containing the input magnitudes of your artificial stars\nF606Wo be a vector containing the measured magnitudes of the artificial stars, where a value of 99.999 indicates a non-detection.\nflag be a vector of booleans that indicates whether the artificial star passed additional quality cuts (star-galaxy separation, etc.)\n\nYou could call this method as\n\nimport TypedTables: Table\nprocess_ASTs(Table(input=F606Wi, output=F606Wo, good=flag),\n             :input, :output, minimum(F606Wi):0.1:maximum(F606Wi),\n             x -> (x.good==true) & (x.output != 99.999))\n\nSee also the tests in test/utilities/process_ASTs_test.jl.\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/MZR/MZR/#MZR","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/#Motivation","page":"Mass-Metallicity Relations (MZRs)","title":"Motivation","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The parametric age-metallicity relations (AMRs) provided by this package are typically sufficient to provide good fits to observed CMDs with very few degrees of freedom. However, they are somewhat arbitrary and unphysical as they have no direct relation to the underlying star formation activity, which is what enrichs the ISM in the first place. As such, physical interpretation of AMRs is dubious – rather, it is often the population-integrated metallicity distribution functions (MDFs) which are compared against external datasets that directly probe stellar metallicities (e.g., single-star spectroscopy).","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"As we are simultaneously fitting both the historical star formation rates (SFRs) and the metallicity at which those stars are forming over time, it is possible to design a framework in which the metallicity evolves in a self-consistent way with the star formation activity. As the AMR describes the mean metallicity of stars forming at different times, it should be most directly related to the metallicity evolution of the star-forming ISM. We therefore need to connect the star formation activity to the ISM metallicity.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"This is complicated by the fact that in general one-zone chemical models, both star-formation driven outflows (which deplete the ISM of both metals and HI) and pristine gas inflows (composed majorly of HI which dilutes the metallicity of the ISM) must be modelled. While hydrodynamic simulations can provide predictions of outflow rates (i.e., through mass-loading factors), the inflow rates are time-variable, depend on the local environment, and generally unconstrained observationally on an object-to-object basis. As such, general one-zone chemical models are unattractive for our purposes.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"A more attractive formulation can be found in the idea of an effective yield, which is the fraction of stellar mass that is composed of metals gamma = M_Z*  M_*. As shown by Torrey et al. 2019, who measured these yields in the Illustris TNG100 simulation, these yields are primarily a function of total galaxy stellar mass and not of redshift. Therefore, the rate of change of the yield with respect to stellar mass fracpartial gammapartial M_* can be connected to the rate at which metals are accumulated in stars as galaxies grow.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Further, the existence of the gas-phase mass-metallicity relation (MZR) for star-forming galaxies gives us some empirical guidance for an implementation, as the AMR should be mostly connected to the gas-phase metallicity. While the MZR is mostly unconstrained for the low-mass galaxies that are typically studied in the Local Universe with resolved photometry (M_*  10^8  textM_odot), the MZR is often extrapolated to low masses as a power law in stellar mass.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"While it is known that higher-mass galaxies do not strictly evolve along the MZR, due in large part to the time variability of inflows mentioned above, the simple form of the power law extrapolation of the MZR allows for a simple experiment. If (on average) the ISM metallicity at time t is primarily driven by the total stellar mass at that time M_*(t), then a two-parameter MZR (power law slope and intercept) coupled to the SFRs in the SFH fitting process should result in better CMD models than a similar two-parameter AMR (e.g., the linear AMR model) which has no mathematical link to the SFRs. In turn, the best-fit SFRs and population-integrated MDFs should also be more accurate if the modelled AMR is better.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We provide a generic interface for describing the analytic form of the MZR so that it is easy to define new MZR models that will integrate with our fitting routines. Built-in, ready to use models are described below, and the API for defining new models is described in the API section.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#Built-In-Models","page":"Mass-Metallicity Relations (MZRs)","title":"Built-In Models","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.PowerLawMZR","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.PowerLawMZR","text":"PowerLawMZR(α::Real, MH0::Real, logMstar0::Real=6,\n            free::NTuple{2, Bool}=(true, true)) <: AbstractMZR\n\nMass-metallicity model described by a single power law index α > 0, a metallicity normalization MH0, and the logarithm of the stellar mass logMstar0 = log10(Mstar0 [M⊙]) at which the mean metallicity is MH0. Because logMstar0 and MH0 are degenerate, we treat MH0 as a fittable parameter and logMstar0 as a fixed parameter that will not be changed during optimizations. Such a power law MZR is often used when extrapolating literature results to low masses, e.g., textM_*  10^8  textM_odot α will be fit freely during optimizations if free[1] == true and MH0 will be fit freely if free[2] == true. The MZR is defined by\n\nbeginaligned\ntextM  textH left( textM_* right) = textM  textH_0 + textlog left( left( fractextM_*textM_*0 right)^alpha right) \n= textM  textH_0 + alpha  left( textlog left( textM_* right) - textlog left( textM_*0 right) right) \nendaligned\n\nExamples\n\njulia> PowerLawMZR(1.0, -1) isa PowerLawMZR{Float64}\ntrue\n\njulia> import Test\n\njulia> Test.@test_throws(ArgumentError, PowerLawMZR(-1.0, -1)) isa Test.Pass\ntrue\n\njulia> nparams(PowerLawMZR(1.0, -1)) == 2\ntrue\n\njulia> PowerLawMZR(1.0, -1, 6)(1e7) ≈ 0\ntrue\n\njulia> all(values(gradient(PowerLawMZR(1.0, -1, 6), 1e8)) .≈\n                (2.0, 1.0, 1 / 1e8 / log(10)))\ntrue\n\njulia> update_params(PowerLawMZR(1.0, -1, 7, (true, false)), (2.0, -2)) ==\n         PowerLawMZR(2.0, -2, 7, (true, false))\ntrue\n\njulia> transforms(PowerLawMZR(1.0, -1)) == (1,0)\ntrue\n\njulia> free_params(PowerLawMZR(1.0, -1, 7, (true, false))) == (true, false)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The per-SSP stellar mass coefficients (r_jk in the derivation) can be derived from an MZR model, a metallicity dispersion model, the per-unique-log(age) stellar mass coefficients (R_j in the derivation), and the set of SSP logarithmic ages logAge = log10(age [yr]) and metallicites using calculate_coeffs.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#mzr_API","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relation API","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Below we describe the API that must be followed in order to implement new types for describing a mass-metallicity relation, such that they will work with our provided fitting and sampling methods.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.AbstractMZR","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.AbstractMZR","text":"AbstractMZR{T <: Real} <: AbstractMetallicityModel{T}: abstract supertype for all metallicity models that are mass-metallicity relations. Concrete subtypes T <: AbstractMZR should implement the following API: \n\n(model::T)(Mstar::Real) should be defined so that the struct is callable with a stellar mass Mstar in solar masses, returning the mean metallicity given the MZR model. This is mu_j left( textM_* right) in the derivations presented in the documentation.\nnparams(model::T) should return the number of fittable parameters in the model.\nfittable_params(model::T) should return the values of the fittable parameters in the model.\ngradient(model::T, Mstar::Real) should return a tuple that contains the partial derivative of the mean metallicity mu_j with respect to each fittable model parameter, plus the partial derivative with respect to the stellar mass Mstar as the final element.\nupdate_params(model::T, newparams) should return a new instance of T with the fittable parameters contained in newparams (which is typically a vector or tuple) and non-fittable parameters inherited from the provided model.\ntransforms(model::T) should return a tuple of length nparams(model) which indicates how the fittable variables should be transformed for optimization, if at all. Elements should be 1 for parameters that are constrained to always be positive, 0 for parameters that can be positive or negative, and -1 for parameters that are constrained to always be negative.\nfree_params(model::T) should return an NTuple{nparams(model), Bool} that is true for fittable parameters that you want to optimize and false for fittable parameters that you want to stay fixed during optimization. \n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.nparams-Tuple{StarFormationHistories.AbstractMZR}","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.nparams","text":"nparams(model::AbstractMZR)::Int\n\nReturns the number of fittable parameters in the model. \n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.fittable_params-Tuple{StarFormationHistories.AbstractMZR}","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.fittable_params","text":"fittable_params(model::AbstractMZR{T})::NTuple{nparams(model), T}\n\nReturns the values of the fittable parameters in the provided MZR model.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.gradient-Tuple{StarFormationHistories.AbstractMZR, Real}","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.gradient","text":"gradient(model::AbstractMZR{T}, Mstar::Real)::NTuple{nparams(model)+1, T}\n\nReturns a tuple containing the partial derivative of the mean metallicity with respect to all fittable parameters, plus the partial derivative with respect to the stellar mass Mstar as the final element. These partial derivatives are evaluated at stellar mass Mstar.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.update_params-Tuple{StarFormationHistories.AbstractMZR, Any}","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.update_params","text":"update_params(model::T, newparams)::T where {T <: AbstractMZR}\n\nReturns a new instance of the model type T with the fittable parameters contained in newparams (which is typically a vector or tuple), with non-fittable parameters inherited from the provided model. \n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.transforms-Tuple{StarFormationHistories.AbstractMZR}","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.transforms","text":"transforms(model::AbstractMZR)::NTuple{nparams(model), Int}\n\nReturns a tuple of length nparams(model) which indicates how the fittable variables should be transformed for optimization, if at all. Elements should be 1 for parameters that are constrained to always be positive, 0 for parameters that can be positive or negative, and -1 for parameters that are constrained to always be negative.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/MZR/MZR/#StarFormationHistories.free_params-Tuple{StarFormationHistories.AbstractMZR}","page":"Mass-Metallicity Relations (MZRs)","title":"StarFormationHistories.free_params","text":"free_params(model::AbstractMZR)::NTuple{nparams(model), Bool}\n\nReturns an tuple of length nparams(model) that is true for fittable parameters that you want to optimize and false for fittable parameters that you want to stay fixed during optimization.\n\n\n\n\n\n","category":"method"},{"location":"fitting/hierarchical/MZR/MZR/#Fitting-and-Sampling-Methods","page":"Mass-Metallicity Relations (MZRs)","title":"Fitting and Sampling Methods","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The MZRs listed above support the generic fitting and sampling methods listed in the overview.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#mzr_derivation","page":"Mass-Metallicity Relations (MZRs)","title":"Derivation","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We once again wish to derive the gradient of the objective function with respect to the fitting parameters to enable gradient-based optimization. Our derivation will reuse some of the notation developed in the section on the linear AMR. The main difference is that instead of expressing the mean metallicity as a function of time langle textMtextH rangle (t), with an MZR we express the mean metallicity as a function of stellar mass at that time langle textMtextH rangle (textM_*(t)). This means that the partial derivatives of the objective with respect to the stellar mass coefficients have a more complex form than in the AMR case, as changing the stellar mass formed 10 Gyr ago (for example) would change the total stellar mass at all more recent times, which in turn changes the mean metallicity expected at all more recent times.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"In the derivations for AMRs we were agnostic about the choice of template normalization; templates could either be normalized to have units of expected number of stars per solar mass of stars formed N  textM_odot, or expected number of stars per unit star formation rate N  dottextM_odot. Changing the units of the templates would, in turn, change the units of the fitting variables returned by the fitting routines, but as shown in our example Jupyter notebook, the fit results are the same no matter the choice of fitting units. For an MZR, we must know the units of the templates and fitting variables so that we may properly calculate the total cumulative stellar mass as a function of time. For simplicity, we assume templates are normalized to number of stars per solar mass of stars formed N  textM_odot and that the fitting variables are therefore the total stellar mass ascribed to each time bin – this is the default behavior for the template creation routines.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Borrowing notation from the fitting introduction and the section on linear AMRs, the bin m_i of the complex model Hess diagram can be written as the sum over the grid of templates with ages indexed by j and metallicities indexed by k as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"m_i = sum_jk  r_jk  c_ijk","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"where m_i is the value of the complex model in bin i, c_ijk is the value of the SSP template with age j and metallicity k in bin i, and r_jk is the multiplicative coefficient determining how significant the template is to the complex population.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The gradient of the objective with respect to the r_jk is given by Equation 21 in Dolphin 2001 as shown in the section on linear AMRs,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nF equiv - textln  mathscrL = sum_i m_i - n_i times left( 1 - textln  left( fracn_im_i right) right) \nfracpartial  Fpartial  r_jk = sum_i c_ijk left( 1 - fracn_im_i right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"where n_i is bin i of the observed Hess diagram. These partial derivatives are easy to obtain, but we need partials with respect to the total stellar mass formed at each distinct age, R_j. These are more complicated that the same partial derivatives under an AMR model.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"For the purposes of illustration, we will consider a power law MZR with slope alpha as is typically used to describe the extrapolation of gas-phase MZRs to masses below 10^8 textM_odot. Under this model, we can express the mean metallicity at time j, notated as mu_j, as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nmu_j = textMtextH_0 + textlog left( left( fractextM_* (t_j)textM_0 right)^alpha right) \n= textMtextH_0 + alpha  left( textlog left( textM_* (t_j) right) - textlog left( textM_0 right) right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"where the power law MZR is normalized such that the mean metallicity is textMtextH_0 at stellar mass textM_0. Note that the MZR comes linear with slope alpha when expressed in textlog(textM_*). As in the AMR models, we use a Gaussian to introduce some metallicity dispersion at fixed time, such that the r_jk are","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nr_jk = R_j  frac textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nA_jk = textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nr_jk = R_j  fracA_jksum_k A_jk \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"where the R_j are the fitting variables representing the total stellar mass formed at each distinct age in the template grid. We define A_jk to substitute in for the broadening PDF, as the Gaussian could easily be substituted for other forms with minimal changes to the derivation. The three parameters in the MZR model are therefore the power law slope alpha, a normalization/intercept parameter textMtextH_0, and the metallicity broadening parameter sigma; this is the same number of parameters as in the linear AMR model.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We can write the partial derivative of the objective F with respect to the R_j as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"fracpartial  Fpartial  R_j = sum_k sum_j^prime  fracpartial  Fpartial  r_j^primek  fracpartial  r_j^primekpartial  R_j","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"which involves the double sum over the metallicity index k and the age index j^prime. In the case of the AMR models, the second term fracpartial  r_j^primekpartial  R_j is always 0 for j^prime neq j, so the equation can be simplified to sum_k  fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j. As the per-model coefficients r_j^primek can now depend on the per-age-bin stellar mass coefficients R_j through the stellar mass dependence of the mean metallicity at time mu_j^prime, we cannot reduce the sum over j^prime.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We can, however, simplify the sum over j^prime somewhat. Let the R_j be sorted in order from earliest time t_j (i.e., largest lookback time) to most recent time (i.e., lowest lookback time). The cumulative stellar mass textM_* left( t_j right) can therefore be expressed as the sum over the R_j^prime for which j^prime leq j, such that","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\ntextM_* left( t_j right) = sum_j^prime=0^j^prime=j R_j^prime \nfracpartial  textM_* left( t_j right)partial R_j = 1 \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"As the R_j dependence on the r_j^primek enters through the cumulative stellar mass textM_* left( t_j^prime right), it is clear that the r_j^primek will depend only on the R_j for which t_j is earlier than t_j^prime. Given the above sorting of the R_j, we can write the sum as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  Fpartial  R_j = sum_k sum_j^prime=0^j  fracpartial  Fpartial  r_j^primek  fracpartial  r_j^primekpartial  R_j \n= sum_k left( fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j + sum_j^prime=0^j-1  fracpartial  Fpartial  r_j^primek  fracpartial  r_j^primekpartial  R_j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"where the second line splits out the case for j^prime = j from the sum over j^prime as this case involves terms not involved when j^prime neq j.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#Case:-jj\\prime","page":"Mass-Metallicity Relations (MZRs)","title":"Case: j=j^prime","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Applying the product rule twice,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nr_jk = R_j  fracA_jksum_k A_jk \nfracpartial  r_jkpartial  R_j = fracA_jksum_k A_jk + R_j  left( fracfracpartial  A_jkpartial  R_jsum_k A_jk - fracA_jk  fracpartial  sum_k A_jkpartial  R_jleft(sum_k A_jkright)^2 right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"In AMR models, the term in parentheses on the right hand side is zero as the partial derivatives of all A_jk with respect to the stellar mass coefficients R_j are zero. These terms are new for the MZR model, as A_jk depends on mu_j which depends on the R_j through the total stellar mass formed by time t_j. ","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The first term can be replaced by an equivalent expression which is often more convenient: fracA_jksum_k A_jk = fracr_jkR_j. The term fracpartial  sum_k A_jkpartial  R_j can be replaced by noting that the partial derivative with respect to R_j of the sum over k of the A_jk must be equal to the sum over k of the partial derivatives of the individual A_jk with respect to R_j such that the following equivalency holds true: fracpartial  sum_k A_jkpartial  R_j = sum_k fracpartial  A_jkpartial R_j. We therefore have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  r_jkpartial  R_j = fracA_jksum_k A_jk + R_j  left( fracfracpartial  A_jkpartial  R_jsum_k A_jk - fracA_jk  fracpartial  sum_k A_jkpartial  R_jleft(sum_k A_jkright)^2 right) \n= fracr_jkR_j + R_j  left( fracfracpartial  A_jkpartial  R_jsum_k A_jk - fracA_jk  sum_k fracpartial  A_jkpartial  R_jleft(sum_k A_jkright)^2 right) \n= fracr_jkR_j + fracR_jsum_k A_jk left( fracpartial  A_jkpartial  R_j - fracA_jk  sum_k fracpartial  A_jkpartial  R_jsum_k A_jk right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We now need to formulate the partial derivatives of the dispersion weights with respect to the stellar mass coefficients, fracpartial  A_jkpartial  R_j. The dependence of the A_jk on the R_j is manifested through the dependence of the A_jk on mu_j, which itself is dependent on the R_j. We will assume the mu_j for all general MZR models can be expressed as a function of the stellar mass at time t_j, which we denote textM_* left( t_j right), and that the stellar mass depends on the R_j. Applying the chain rule,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_jkpartial  R_j = fracpartial  A_jkpartial  mu_j fracpartial  mu_jpartial  R_j \nfracpartial  mu_jpartial  R_j = fracpartial  mu_jpartial  textM_* left( t_j right)  fracpartial  textM_* left( t_j right)partial R_j \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"In the case that the R_j represent the amount of stellar mass formed in time bin t_j, then the second term reduces to 1. Let the R_j be sorted in order from earliest time t_j (i.e., largest lookback time) to most recent time (i.e., lowest lookback time). The cumulative stellar mass textM_* left( t_j right) can therefore be expressed as the sum over the R_j^prime for j^prime leq j, such that","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\ntextM_* left( t_j right) = sum_j^prime=0^j^prime=j R_j^prime \nfracpartial  textM_* left( t_j right)partial R_j = 1 \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We can therefore make the simplification","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  mu_jpartial  R_j = fracpartial  mu_jpartial  textM_* left( t_j right)  fracpartial  textM_* left( t_j right)partial R_j \n= fracpartial  mu_jpartial  textM_* left( t_j right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"so that the partial derivatives of the A_jk with respect to the R_j become","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_jkpartial  R_j = fracpartial  A_jkpartial  mu_j fracpartial  mu_jpartial  R_j \n= fracpartial  A_jkpartial  mu_j fracpartial  mu_jpartial  textM_* left( t_j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The forms of these partials will depend on the choices of the metallicity dispersion profile at fixed time, which sets the first term involving A_jk, as well as the form of the MZR model which will set the partial derivative of the mean metallicity at time j, mu_j, with respect to the cumulative stellar mass at time t_j. For our choice of a Gaussian metallicity dispersion profile at fixed time we have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nA_jk = textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nfracpartial  A_jkpartial  mu_j = fracA_jksigma^2 left( textMtextH_k - mu_j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"and for our choice of a power law MZR we have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nmu_j = textMtextH_0 + alpha  left( textlog left( textM_* (t_j) right) - textlog left( textM_0 right) right) \nfracpartial  mu_jpartial  textM_* left( t_j right) = fracalphatextM_* left( t_j right)  textln  10 \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"such that we now have all the terms we need to compute the fracpartial  r_jkpartial  R_j which enables us to compute the partial derivatives of the objective with respect to the R_j, fracpartial  Fpartial  R_j = sum_k  fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#Case:-j-\\neq-j\\prime","page":"Mass-Metallicity Relations (MZRs)","title":"Case: j neq j^prime","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"In the case that j neq j^prime, the only dependence of the r_j^primek on the R_j comes through the metallicity dispersion coefficients A_j^primek, which depend on the mean metallicities mu_j^prime, which depend on the cumulative stellar masses textM_* left( t_j^prime right), which depend on the R_j. Applying the product rule,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nr_j^primek = R_j^prime  fracA_j^primeksum_k A_j^primek \nfracpartial  r_j^primekpartial  R_j = R_j^prime  left( fracfracpartial  A_j^primekpartial  R_jsum_k A_j^primek - fracA_j^primek  fracpartial  sum_k A_j^primekpartial  R_jleft(sum_k A_j^primekright)^2 right) \n= fracR_j^primesum_k A_j^primek left( fracpartial  A_j^primekpartial  R_j - fracA_j^primek  sum_k fracpartial A_j^primekpartial R_jsum_k A_j^primek right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"which is very similar to the expression found for j = j^prime, except missing the additive prefactor of fracr_jkR_j. Generally we need to derive the fracpartial A_j^primekpartial R_j, which will follow much the same path as the derivation of fracpartial A_jkpartial R_j above. We will therefore borrow expressions derived for the case of j = j^prime and alter them to be applicable to the case of j neq j^prime.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_j^primekpartial  R_j = fracpartial  A_j^primekpartial  mu_j^prime fracpartial  mu_j^primepartial  R_j \nfracpartial  mu_j^primepartial  R_j = fracpartial  mu_j^primepartial  textM_* left( t_j^prime right)  fracpartial  textM_* left( t_j^prime right)partial R_j \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We will assume as above that the R_j represent the amount of stellar mass formed in time bin t_j so that the second term is 1 if t_j is earlier than t_j^prime and 0 if it is later. This follows from our definition of the cumulative stellar mass from above. We can therefore make the simplification","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"fracpartial  textM_* left( t_j^prime right)partial R_j = Theta left( j^prime - j right)","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"where Theta left( x right) is the Heaviside function, which is one if x  0 and zero if x  0. This allows us to write","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  mu_j^primepartial  R_j = fracpartial  mu_j^primepartial  textM_* left( t_j^prime right)  fracpartial  textM_* left( t_j^prime right)partial R_j \n= fracpartial  mu_j^primepartial  textM_* left( t_j^prime right)  Theta left( j^prime - j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Under our assumption that the R_j are ordered from earliest times to latest times, if j^prime  j, then the R_j represents stellar mass formed more recently than t_j^prime, such that it does not contribute to determining the mean metallicity mu_j^prime and this term will be zero. For a concrete example, consider the lookback times in Gyr of t_j = [13, 12, 11]. If we set j=0 and j^prime=1, then Theta left( j^prime - j right) = 1 as R_j represents stellar mass forming 13 Gyr ago, before t_j^prime which is 12 Gyr ago – therefore, R_j must contribute to the total stellar mass at the later time. In contrast, if we reverse this to j=1 and j^prime=0, now Theta left( j^prime - j right) = 0 because the stellar mass forming at time t_j, a lookback time of 12 Gyr, does not affect the cumulative stellar mass at time t_j^prime, which is 13 Gyr ago.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"We can now write the partial derivatives of the A_j^primek with respect to the R_j as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_j^primekpartial  R_j = fracpartial  A_j^primekpartial  mu_j^prime fracpartial  mu_j^primepartial  R_j \n= fracpartial  A_j^primekpartial  mu_j^prime fracpartial  mu_j^primepartial  textM_* left( t_j^prime right)  Theta left( j^prime - j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"These partial derivatives must be calculated for your choice of metallicity dispersion profile at fixed time, which sets the first term involving A_jk, and MZR model, which will set the partial derivative of mu_j^prime (the mean metallicity at time j^prime) with respect to the cumulative stellar mass at time t_j^prime. For our choice of a Gaussian metallicity dispersion profile at fixed time we have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nA_j^primek = textexp left( - frac12 left( frac textMtextH_k - mu_j^primesigma right)^2 right) \nfracpartial  A_j^primekpartial  mu_j^prime = fracA_j^primeksigma^2 left( textMtextH_k - mu_j^prime right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"and for our choice of a power law MZR we have","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nmu_j^prime = textMtextH_0 + alpha  left( textlog left( textM_* (t_j^prime) right) - textlog left( textM_0 right) right) \nfracpartial  mu_j^primepartial  textM_* left( t_j^prime right) = fracalphatextM_* left( t_j^prime right)  textln  10 \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"such that we now have all the terms we need to compute the fracpartial  r_j^primekpartial  R_j for both j^prime = j and j^prime neq j, which enables us to compute the partial derivatives of the objective with respect to the R_j, fracpartial  Fpartial  R_j.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/#MZR-Parameters","page":"Mass-Metallicity Relations (MZRs)","title":"MZR Parameters","text":"","category":"section"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Above we have derived the partial derivatives of the objective with respect to the stellar mass coefficients fracpartial  Fpartial  R_j. It remains to derive the partial derivatives of the objective with respect to the parameters that define the MZR. In the case of our power law MZR example, the two parameters of interest are the power law slope alpha and the metallicity normalization parameter textMtextH_0, which is the metallicity at a stellar mass of textM_0 – the exact value of textM_0 is not of interest and is treated as fixed.","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"mu_j = beta + alpha  left( textlog left( textM_* (t_j) right) - textlog left( textM_0 right) right) ","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Note that the power law MZR example, as defined, is linear in textlog left( textM_* right), so that it can be written analogously to the linear AMR case. The forms of the partial derivatives are therefore similar. For simplicity of notation, and to highlight the similarity with the linear AMR model, we will write beta equiv textMtextH_0 as it is also a normalization parameter as beta is in the linear AMR case. ","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"The first part of the derivation is then the same as the linear AMR case,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  Fpartial  beta = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta \nfracpartial  r_jkpartial  beta = R_j left( frac1sum_k  A_jk  fracpartial  A_jkpartial  beta - fracA_jkleft( sum_k  A_jk right)^2  fracpartial  sum_k  A_jkpartial  beta right)  \n= fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  beta - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  beta right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Our definition for the A_jk are also the same, assuming a small Gaussian dispersion in metallicity at fixed time. ","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j fracpartial mu_jpartial beta = fracpartial  A_jkpartial  mu_j \nfracpartial  A_jkpartial  beta = fracpartialpartial  mu  left textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) right \n= fracA_jksigma^2 left( textMtextH_k - mu_j right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"which, as expected, is the same result as in the linear AMR case, as beta is a intercept (or normalization parameter) in both models. The partial derivative with respect to the slope alpha can be expanded similarly,","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"fracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j fracpartial mu_jpartial alpha","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"As in the linear AMR case, it can be shown that the partial derivative of the objective with respect to alpha is simply","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"fracpartial  Fpartial  alpha = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  alpha = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta times left( textlog left( textM_* (t_j) right) - textlog left( textM_0 right) right) ","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"More generally, for any parameter P that is used to calculate the mean metallicity mu_j, we can write the partial derivative of the objective with respect to P as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  Fpartial  P = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  P \nfracpartial  r_jkpartial  P = fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  P - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  P right) \nfracpartial  A_jkpartial  P = fracpartial  A_jkpartial  mu_j fracpartial mu_jpartial P \nfracpartial  r_jkpartial  P = fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  mu_j fracpartial mu_jpartial P - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  mu_j fracpartial mu_jpartial P right) \nendaligned","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"Since fracpartial mu_jpartial P has no dependence on the metallicity index k, we can pull it out of the sum in the final term and combine it into the prefactor as","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"fracpartial  r_jkpartial  P = fracR_jsum_k  A_jk fracpartial mu_jpartial P left( fracpartial  A_jkpartial  mu_j - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  mu_j right)","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"so that we can reuse the majority of the calculation for all the parameters P in the model for mu_j, changing only a multiplicative prefactor of fracpartial mu_jpartial P. This means that the partial derivative of the objective with respect to P becomes","category":"page"},{"location":"fitting/hierarchical/MZR/MZR/","page":"Mass-Metallicity Relations (MZRs)","title":"Mass-Metallicity Relations (MZRs)","text":"beginaligned\nfracpartial  Fpartial  P = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  P \n= sum_j fracR_jsum_k  A_jk fracpartial mu_jpartial P sum_k fracpartial  Fpartial  r_jk  left( fracpartial  A_jkpartial  mu_j - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  mu_j right) \nendaligned","category":"page"},{"location":"fitting/kernels/#kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"One of the most important parts of our method is modelling the 2-D probability distribution of observing a star with particular intrinsic magnitudes in the Hess diagram space. We refer to these 2-D probability distributions as \"kernels\" throughout, as our process is conceptually similar to constructing a kernel density estimate. This document describes how these kernels are constructed and what assumptions are made to do so.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"Our implementation is underpinned by the assumption that all kernels can be described the family of 2-D Gaussian probability distributions. To derive these 2-D distributions, we begin with 1-D distributions for each photometric filter used in the analysis.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We assume random photometric errors in the observed photometric catalog can be approximated as Gaussian. This is generally a good assumption for the space-based imaging used for resolved SFHs (e.g., HST and JWST) as long as the photometric completeness is high (greater than, perhaps, 50%). At low completeness, the error distributions become skewed and would be better modelled by something like a skew-normal distribution, which we do not presently consider.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We additionally require that the user can construct functions for each observed photomeric filter which, given a star's input intrinsic magnitude in a single filter m_i, return reliable measures for the average single-band photometric error; sigma(m_i). Assuming that the photometric errors in each band can be modelled as independent, we can derive, for a given m_i, the probability distribution of the observed magnitude m_o. We therefore have the 1-D probability distributions P(m_om_i) for all filters.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"In the case that imaging in three photometric filters are available and are used to construct a Hess diagram with a magnitude on the y-axis that does not appear on the x-axis (e.g., y=R and x=B-V), then there is no covariance between the x and y axes and the 2-D Gaussian kernel is fully separable. We call this the \"non-covariant\" case.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"In order to inject the kernel into the model Hess diagram, it must be integrated across the grid that defines the discretization. The integral of the non-covariant kernel across the Hess diagram pixel grid is entirely analytic, making evaluation easy and efficient. By integrating the kernel over the grid, the numerical precision is nearly independent of the grid resolution, which is not true of Monte Carlo (MC) based template construction algorithms.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"In the case that imaging in only two photometric filters are available and are used to construct a Hess diagram with a magnitude on the y-axis that does appear on the x-axis (e.g., y=B and x=B-V), then there is covariance between x and y axes. The initial implementation of this method neglected this covariance, and while the result was not catastrophic, it was certainly suboptimal. We now model the covariance explicitly. The covariance pattern does not permit a fully analytic integral as in the non-covariant case; instead, the inner integral (over, say, the x-axis) can be calculated analytically but the outer integral cannot. We therefore use Gauss-Legendre quadtrature to finish the integration over the second axis.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"The types representing these kernels are not part of our public API, but we provide an example script examples/templates/kernels_example.jl which illustrates the performance of these kernels. The output of this script is reproduced and explained below.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"Consider a star taken from an isochrone with intrinsic magnitudes B=20, V=19, and R=18 with expected random photometric errors sigma_B=002, sigma_V=003, and sigma_R=005. Our example randomly samples a large population of possible observed magnitudes given these intrinsic properties and compares the distribution of the MC sample to our kernels.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We consider first the non-covariant case:","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"mv(\"../../../examples/templates/covar_0.svg\", \"figures/covar_0.svg\") # hide\nmv(\"../../../examples/templates/covar_1.svg\", \"figures/covar_1.svg\") # hide\nmv(\"../../../examples/templates/covar_m1.svg\", \"figures/covar_m1.svg\") # hide\nnothing # hide","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"(Image: noncovariant)","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"which has the expected, non-rotated morphology.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We next consider the covariant case with the covariance pattern y=B and x=B-V:","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"(Image: covariantm1)","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"which we can see correctly models the covariance pattern.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"And finally, the covariant case with the covariance pattern y=V and x=B-V: (Image: covariant1)","category":"page"},{"location":"fitting/unconstrained/#High-Level-Methods-for-Unconstrained-Fitting","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"","category":"section"},{"location":"fitting/unconstrained/#Maximum-Likelihood-Optimization","page":"High-Level Methods for Unconstrained Fitting","title":"Maximum Likelihood Optimization","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Template construction is by far the most complicated step in the fitting procedure. Once your templates have been constructed, fitting them to an observed Hess diagram amounts to maximization of the Poisson likelihood ratio (Dolphin 2002). It is possible to construct more complicated hierarchical models including things like metallicity distribution functions; we discuss these in the next section. In this section we discuss methods for fitting where the only constraint is that star formation rates cannot be negative. We provide the StarFormationHistories.construct_x0 method to help with setting the initial guess for this optimization. ","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.construct_x0","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.construct_x0","text":"x0::typeof(logage) = construct_x0(logAge::AbstractVector{T},\n                                  T_max::Number;\n                                  normalize_value::Number=one(T)) where T <: Number\n\nGenerates a vector of initial stellar mass normalizations for input to fit_templates or hmc_sample with a total stellar mass of normalize_value such that the implied star formation rate is constant across the provided logAge vector that contains the log10(Age [yr]) of each isochrone that you are going to input as models. For the purposes of computing the constant star formation rate, the provided logAge are treated as left-bin edges, with the final right-bin edge being T_max, which has units of Gyr. For example, you might have logAge=[6.6, 6.7, 6.8] in which case a final logAge of 6.9 would give equal bin widths. In this case you would set T_max = exp10(6.9) / 1e9 ≈ 0.0079 so that the width of the final bin for the star formation rate calculation has the same log10(Age [yr]) step as the other bins.\n\nExamples\n\njulia> x0 = construct_x0(repeat([7.0,8.0,9.0],3), 10.0; normalize_value=5.0)\n9-element Vector{Float64}: ...\n\njulia> sum(x0)\n4.99... # Close to `normalize_value`.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"When it comes to performing the optimization, the simplest method we offer is StarFormationHistories.fit_templates_lbfgsb. This will optimize one coefficient per template; there is no overarching metallicity evolution or other constraint, besides that the stellar masses of the populations cannot be negative. This performs a maximum likelihood optimization with the bounded quasi-Newton LBFGS method as implemented in L-BFGS-B and wrapped in LBFGS.jl with analytic gradients. It is fast and converges fairly reliably, even when the initial guess is not particularly close to the maximum likelihood estimate. It provides no uncertainty estimation. It is normal for some of the coefficients to converge to zero.","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.fit_templates_lbfgsb","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.fit_templates_lbfgsb","text":"(-logL, coeffs) = \nfit_templates_lbfgsb(models::AbstractVector{T},\n                     data::AbstractMatrix{<:Number};\n                     x0::AbstractVector{<:Number} = ones(S,length(models)),\n                     factr::Number=1e-12,\n                     pgtol::Number=1e-5,\n                     iprint::Integer=0,\n                     kws...) where {S <: Number, T <: AbstractMatrix{S}}\n\nFinds the coefficients coeffs that maximize the Poisson likelihood ratio (equations 7–10 in Dolphin 2002) for the composite Hess diagram model sum(models .* coeffs) given the provided templates models and the observed Hess diagram data using the box-constrained LBFGS method provided by LBFGSB.jl. \n\nArguments\n\nmodels::AbstractVector{AbstractMatrix{<:Number}}: the list of template Hess diagrams for the simple stellar populations (SSPs) being considered; all must have the same size.\ndata::AbstractMatrix{<:Number}: the observed Hess diagram; must match the size of the templates contained in models.\n\nKeyword Arguments\n\nx0: The vector of initial guesses for the stellar mass coefficients. You should basically always be calculating and passing this keyword argument; we provide StarFormationHistories.construct_x0 to prepare x0 assuming constant star formation rate, which is typically a good initial guess.\nfactr::Number: Keyword argument passed to LBFGSB.lbfgsb; essentially a relative tolerance for convergence based on the inter-iteration change in the objective function.\npgtol::Number: Keyword argument passed to LBFGSB.lbfgsb; essentially a relative tolerance for convergence based on the inter-iteration change in the projected gradient of the objective.\niprint::Integer: Keyword argument passed to LBFGSB.lbfgsb controlling how much information is printed to the terminal. Setting to 1 can sometimes be helpful to diagnose convergence issues. Setting to -1 will disable printing.\n\nOther kws... are passed to LBFGSB.lbfgsb.\n\nReturns\n\n-logL::Number: the minimum negative log-likelihood found by the optimizer.\ncoeffs::Vector{<:Number}: the maximum likelihood estimate for the coefficient vector. \n\nNotes\n\nIt can be helpful to normalize your models to contain realistic total stellar masses to aid convergence stability; for example, if the total stellar mass of your population is 10^7 solar masses, then you might normalize your templates to contain 10^3 solar masses. If you are using partial_cmd_smooth to construct the templates, you can specify this normalization via the normalize_value keyword. \n\n\n\n\n\nfit_templates_lbfgsb(models::AbstractMatrix{S},\n                     data::AbstractVector{<:Number};\n                     x0::AbstractVector{<:Number} = ones(S,size(models,2)),\n                     factr::Number=1e-12,\n                     pgtol::Number=1e-5,\n                     iprint::Integer=0,\n                     kws...) where S <: Number\n\nThis call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"This method simply minimizes the negative logarithm of the Poisson likelihood ratio (Equation 10 in Dolphin 2002),","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"- textln  mathscrL = sum_i m_i - n_i times left( 1 - textln  left( fracn_im_i right) right)","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where m_i is bin i of the complex model and n_i is bin i of the observed Hess diagram; this can therefore be thought of as computing the maximum likelihood estimate.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"We also provide StarFormationHistories.fit_templates_fast, which is the fastest method we offer for deriving a maximum likelihood estimate for the type of model described above.","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.fit_templates_fast","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.fit_templates_fast","text":"(coeffs::Vector{::eltype(x0)}, result::Optim.MultivariateOptimizationResults) =\nfit_templates_fast(models::AbstractVector{T},\n                   data::AbstractMatrix{<:Number};\n                   x0::AbstractVector{<:Number} = ones(S,length(models)),\n                   kws...)\n                   where {S <: Number, T <: AbstractMatrix{S}}\n\nFinds only the maximum likelihood estimate (MLE) for the coefficients coeffs given the provided data such that the best-fit composite Hess diagram model is sum(models .* coeffs). This is a simplification of the main fit_templates function, which will return the MLE as well as the maximum a posteriori estimate, and further supports uncertainty quantification. For additional details on arguments to this method, see the documentation for fit_templates. \n\nThis method optimizes parameters θ such that coeffs = θ.^2 – this allows for faster convergence than both the fit_templates_lbfgsb method, which does not use a variable transformation, and the logarithmic transformation used in fit_templates. However, the inverse Hessian is not useful for uncertainty estimation under this transformation. As such this method only returns the MLE for coeffs as a vector and the result object returned by Optim.optimize. While this method offers fewer features than fit_templates, this method's runtime is typically half as long (or less). As such, this method is recommended for use in performance-sensitive applications like hierarchical models or hyperparameter estimation where the additional features of fit_templates are unnecessary. In these applications, the value of the objective function at the derived MLE is typically desired as well; this can be obtained the from result::Optim.MultivariateOptimizationResults object as Optim.minimum(result). Note that this will return the negative loglikelihood, which is what is minimized in this application.\n\nNotes\n\nBy passing additional convergence keyword arguments supported by Optim.Options (see this guide), it is possible to converge to the MLE in fewer than 30 iterations with fewer than 100 calls to the likelihood and gradient methods. For example, the main convergence criterion is typically the magnitude of the gradient vector, which by default is g_abstol=1e-8, terminating the optimization when the magnitude of the gradient is less than 1e-8. We find results are typically sufficiently accurate with g_abstol=1e-3, which often uses half as many objective evaluations as the default value.\n\n\n\n\n\nfit_templates_fast(models::AbstractMatrix{S},\n                   data::AbstractVector{<:Number};\n                   x0::AbstractVector{<:Number} = ones(S,size(models,2)),\n                   kws...)\n                   where S <: Number\n\nThis call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/#Posterior-Sampling:-MCMC","page":"High-Level Methods for Unconstrained Fitting","title":"Posterior Sampling: MCMC","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"For low-dimensional problems, Markov Chain Monte Carlo (MCMC) methods can be an efficient way to sample the posterior and obtain uncertainty estimates on the fitting coefficients r_j. We provide StarFormationHistories.mcmc_sample for this purpose. Internally this uses the multi-threaded affine-invariant MCMC sampler from KissMCMC.jl to perform the sampling, which is based on the same algorithm as Python's emcee (specifically, their emcee.moves.StretchMove). There are other MCMC packages like AdvancedMH.jl that offer additional features like distributed execution. ","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.mcmc_sample","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.mcmc_sample","text":"result::MCMCChains.Chains =\nmcmc_sample(models::AbstractVector{<:AbstractMatrix{T}},\n            data::AbstractMatrix{S},\n            x0::Union{AbstractVector{<:AbstractVector{<:Number}}, AbstractMatrix{<:Number}},\n            nsteps::Integer;\n            nburnin::Integer=0,\n            nthin::Integer=1,\n            a_scale::Number=2.0,\n            use_progress_meter::Bool=true)\nmcmc_sample(models::AbstractMatrix{<:Number},\n            data::AbstractVector{<:Number},\n            args...; kws...)\n\nSamples the posterior of the coefficients coeffs such that the full model of the observational data is sum(models .* coeffs). Uses the Poisson likelihood ratio as defined by equations 7–10 of Dolphin 2002. Sampling is done using the affine-invariant MCMC sampler implemented in KissMCMC.jl, which is analogous to Python's emcee.moves.StretchMove. This method will automatically parallelize over threads. If you need distributed execution, you may want to look into AdvancedMH.jl.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nx0::Union{AbstractVector{<:AbstractVector{<:Number}}, AbstractMatrix{<:Number}} are the initial positions for the MCMC walkers. If providing a vector of vectors, each element (i.e., x0[1]) is taken to be the initial position for one walker and each element must have length equal to length(models). The length of x0 is the number of MCMC walkers (nwalkers). You can alternatively provide a matrix of size (nwalkers, length(models)) or (length(models), nwalkers).\nnsteps::Integer is the number of steps to take with each walker.\n\nKeyword Arguments\n\nnburnin::Integer=0 is the number of steps to discard from the start of each chain.\nnthin::Integer=1 is the factor by which to thin the chain; walker positions will only be saved every nthin steps.\na_scale::Number=2.0 is the scale parameter for the stretch move; probably shouldn't need to be changed.\nuse_progress_Meter::Bool=true indicates whether or not to show a progress bar during the MCMC procedure.\n\nReturns\n\nresult is a MCMCChains.Chains instance which enables easy calculation of diagnostic and summary statistics. This type can be indexed and used like a 3-D array of samples with shape (nsteps, length(models), nwalkers).\n\nNotes\n\nWhen displaying result to the terminal it will display summary statistics (MCMCChains.summarystats) and quantiles (MCMCChains.quantile) by calling the MCMCChains.describe method. This can take a second but is nice to have as an option.\nThe highest posterior density interval, which is the narrowest credible interval that includes the posterior mode, can be calculated with the MCMCChains.hpd method. \nIf you want to extract the array of samples from the MCMCChains.Chains object, you can index result.value – this will return an AxisArray but can be converted to a normal array with Array(result.value).\n\nExamples\n\nusing Distributions: Poisson\ncoeffs = rand(10) # SFH coefficients we want to sample\nmodels = [rand(100,100) .* 100 for i in 1:length(coeffs)] # Vector of model Hess diagrams\ndata = rand.(Poisson.( sum(models .* coeffs) ) ) # Poisson-sample the model `sum(models .* coeffs)`\nnwalkers = 1000\nnsteps = 400\nx0 = rand(nwalkers, length(coeffs)) # Initial walker positions\nresult = mcmc_sample(models, data, x0, nsteps) # Sample\nChains MCMC chain (400×10×1000 Array{Float64, 3}) ...\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/#Posterior-Sampling:-Change-of-Variables-and-HMC","page":"High-Level Methods for Unconstrained Fitting","title":"Posterior Sampling: Change of Variables and HMC","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Dolphin 2013 examined methods for obtaining uncertainties on the fitted coefficients (the r_j in Equation 1 of Dolphin 2002) and found that the Hamiltonian Monte Carlo (HMC) approach allowed for relatively efficient sampling of the posterior distribution when considering many isochrones in the modelling process. HMC requires that the variables to be fit are continuous over the real numbers and so requires a change of variables. Rather than sampling the variables r_j directly, we can sample theta_j = textln left( r_j right) such that the sampled variables are continuous over the real numbers -infty  theta_j  infty while the r_j=textexp left( theta_j right) coefficients are bounded from 0  r_j  infty. Using a logarithmic transformation has the additional benefit that the gradient of the Poisson likelihood ratio is still continuous and easy to compute analytically.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"While maximum likelihood estimates are invariant under variable transformations, sampling methods like HMC are not, as formally the posterior being sampled from is a distribution and therefore must be integrable over the sampling coefficients. We can write the posterior from which we wish to sample as","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\np(r_j  D) = fracp(D  r_j)  p(r_j)Z \np(boldsymbolr  D) = frac1Z  prod_j p(D  r_j)  p(r_j) \n-textln  p(boldsymbolr  D) = textln  Z - sum_j  textln  p(D  r_j) + textln  p(r_j) \n= textln  Z - textln  mathscrL + sum_j textln  p(r_j)\nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where Z is the Bayesian evidence (a constant that can be neglected for sampling methods), p left( r_j right) is the prior on the star formation history, and mathscrL is the Poisson likelihood ratio discussed above. An uninformative (and unnormalized) prior on the coefficients r_j could take the form of","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"p(r_j) = begincases\n1  r_j geq 0\n0  r_j  0\nendcases","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"such that, if the coefficients r_j are guaranteed to be positive, the final term becomes zero (since textln(1)=0) and","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"-textln  p(boldsymbolr  D) = textln  Z - textln  mathscrL","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"When sampling with methods like HMC, constants like textln  Z can be neglected and -textln  p(boldsymbolr  D) propto - textln  mathscrL such that the posterior is approximated by the likelihood surface.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Let us consider now what happens when we wish to do a variable transformation from r_j to theta_j = textln (r_j). From above we can write the posterior as","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"p(r_j  D) = fracp(D  r_j)  p(r_j)Z ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Under the change of variables formula we can write","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\np(theta_j  D) = p(r_j  D) left fracd r_jd theta_j right \n= p(r_j  D) left fracd theta_jd r_j right^-1\nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where left fracd theta_jd r_j right^-1 is often called the Jacobian correction. We choose theta_j such that","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\ntheta_j = textln ( r_j ) \nleft fracd theta_jd r_j right = frac1r_j \nr_j = textexp (theta_j) \nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"which leads to a posterior of","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"p(theta_j  D) = textexp (theta_j) times p(textexp (theta_j)  D) = r_j times p(r_j  D) ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"We can then write the product over the theta_j as","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\np(boldsymboltheta  D) = frac1Z  prod_j r_j  p(D  r_j)  p(r_j) \n-textln  p(boldsymboltheta  D) = textln  Z - sum_j textln  (r_j) + textln  p(D  r_j) + textln  p(r_j) \n= textln  Z - sum_j textln  p(D  r_j) + textln  p(r_j) - sum_j theta_j \n= -textln  p(boldsymbolr  D) - sum_j theta_j \n= -textln  p(boldsymbolr  D) - sum_j textln  (r_j)\nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"The choice of a logarithmic transformation means that the negative logarithm of the posterior (which is what HMC uses for its objective function) has this very simple form which allows for simple analytic gradients as well. Once samples of theta have been obtained from this distribution via HMC or any other sampling method, they can be directly transformed back to the standard coefficients r_j = textexp(theta_j).","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"The method hmc_sample implements this approach for sampling the theta_j coefficients; these samples can then be used to estimate random uncertainties on the derived star formation history.","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.hmc_sample","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.hmc_sample","text":"hmc_sample(models::AbstractVector{T},\n           data::AbstractMatrix{<:Number},\n           nsteps::Integer [, nchains::Integer];\n           rng::Random.AbstractRNG=Random.default_rng(),\n           kws...)\n           where {S <: Number, T <: AbstractMatrix{S}}\nhmc_sample(models::AbstractMatrix{S},\n           data::AbstractVector{<:Number},\n           nsteps::Integer;\n           rng::AbstractRNG=default_rng(),\n           kws...)\n           where S <: Number\n\nFunction to sample the posterior of the coefficients coeffs such that the full model of the observational data is sum(models .* coeffs). Uses the Poisson likelihood ratio as defined by equations 7–10 of Dolphin 2002 along with a logarithmic transformation of the coeffs so that the fitting variables are continuous and differentiable over all reals. Sampling is done using the No-U-Turn sampler as implemented in DynamicHMC.jl, which is a form of dynamic Hamiltonian Monte Carlo.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nnsteps::Integer is the number of samples to draw per chain.\n\nOptional Arguments\n\nnchains::Integer: If this argument is not provided, this method will return a single chain. If this argument is provided, it will sample nchains chains using all available Julia threads and will return a vector of the individual chains.\n\nKeyword Arguments\n\nrng::Random.AbstractRNG is the random number generator that will be passed to DynamicHMC.jl. If nchains is provided this method will attempt to sample in parallel, requiring a thread-safe rng such as that provided by Random.default_rng(). \n\nAll other keyword arguments kws... will be passed to DynamicHMC.mcmc_with_warmup or DynamicHMC.mcmc_keep_warmup depending on whether nchains is provided.\n\nReturns\n\nIf nchains is not provided, returns a NamedTuple as summarized in DynamicHMC.jl's documentation. In short, the matrix of samples can be extracted and transformed as exp.( result.posterior_matrix ). Statistics about the chain can be obtained with DynamicHMC.Diagnostics.summarize_tree_statistics(result.tree_statistics); you want to see a fairly high acceptance rate (>0.5) and the majority of samples having termination criteria being \"turning.\" See DynamicHMC.jl's documentation for more information.\nIf nchains is provided, returns a vector of length nchains of the same NamedTuples described above. The samples from each chain in the returned vector can be stacked to a single (nsamples, nchains, length(models)) matrix with DynamicHMC.stack_posterior_matrices(result). \n\nExamples\n\nimport DynamicHMC\nimport StatFormationHistories: hmc_sample\nimport Statistics: mean\n# Run sampler using progress meter to monitor progress\n# assuming you have constructed some templates `models` and your observational Hess diagram `data`\nresult = hmc_sample( models, data, 1000; reporter=DynamicHMC.ProgressMeterReport())\n# The chain values are stored in result.posterior matrix; extract them with `result.posterior_matrix`\n# An exponential transformation is needed since the optimization internally uses a logarithmic \n# transformation and samples log(θ) rather than θ directly. \nmc_matrix = exp.( result.posterior_matrix )\n# We can look at some statistics from the chain; want to see high acceptance rate (>0.5) and large % of\n# \"turning\" for termination criteria. \nDynamicHMC.Diagnostics.summarize_tree_statistics(result.tree_statistics)\n    Hamiltonian Monte Carlo sample of length 1000\n      acceptance rate mean: 0.92, 5/25/50/75/95%: 0.65 0.88 0.97 1.0 1.0\n      termination: divergence => 0%, max_depth => 0%, turning => 100%\n      depth: 0 => 0%, 1 => 64%, 2 => 36%\n# mc_matrix has size `(length(models), nsteps)` so each column is an independent\n# sample of the SFH as defined by the coefficients and the rows contain the samples\n# for each parameter. \nmstar_tot = sum.(eachcol(mc_matrix)) # Total stellar mass of the modelled system per sample\nmc_means = mean.(eachrow(mc_matrix)) # Mean of each coefficient evaluated across all samples\n# Example with multiple chains sampled in parallel via multi-threading\nimport Threads\nt_result = hmc_sample( models, data, 1000, Threads.nthreads(); reporter=DynamicHMC.ProgressMeterReport())\n# Combine the multiple chains into a single matrix and transform\n# Can then use the same way as `mc_matrix` above\nmc_matrix = exp.( DynamicHMC.pool_posterior_matrices(t_result) )\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"See the DynamicHMC.jl documentation for more information on how to use the chains that are output by this method.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Inspection of the samples generated by hmc_sample shows that the posterior defined by the above model is typically smooth, well-behaved, and unimodal. In particular, we find that the sampled r_j for coefficients that are non-zero in the MLE are approximately Gaussian distributed while the logarithms of the sampled r_j are roughly Gaussian distributed for coefficients that are zero in the MLE; i.e.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"begincases\nX_j sim mathcalN  hat r_j  0 \ntextln left( X_j right) sim mathcalN  hat r_j = 0 \nendcases","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where X_j are the samples of r_j obtained from the posterior and hat r_j is the maximum likelihood estimate of r_j. ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"This indicates we may be able to approximate the posterior in the region surrounding the maximum a posteriori (MAP) value by the inverse of the Hessian matrix (see, e.g., Dovi et al. 1991), allowing us to estimate parameter uncertainties very cheaply. The inverse of the Hessian matrix is exactly equal to the variance-covariance matrix of the parameters for a Gaussian probability distribution; for other probability distributions, the inverse of the Hessian approximates the variance-covariance matrix of the parameters when the second-order expansion defined by the Hessian at the maximum is a reasonable approximation to the real objective function being optimized. A particularly simple form arises when the logarithm of the objective is quadratic in the fitting parameters, as in the Gaussian case, because the second derivatives of the objective are constant and do not depend on the fitting parameters or the MAP estimate.","category":"page"},{"location":"fitting/unconstrained/#Maximum-a-Posteriori-Optimization","page":"High-Level Methods for Unconstrained Fitting","title":"Maximum a Posteriori Optimization","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Direct computation of the Hessian and its inverse is expensive, so we'd like another way to obtain it. The first-order, quasi-Newton BFGS optimization algorithm provides such a method as it iteratively builds a dense approximation to the inverse Hessian using the change in the gradient of the objective, which we can compute analytically. It is, however, much less memory efficient than the LBFGS algorithm we use in StarFormationHistories.fit_templates_lbfgsb. For moderate isochrone grids up to a few hundred model templates, this is not a problem. Beyond this it may be better to use StarFormationHistories.fit_templates_lbfgsb to obtain the MLE and hmc_sample to obtain posterior samples.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"We implement this optimization scheme in fit_templates, which is our recommended method for unconstrained SFH fitting (i.e., direct fitting of the r_j coefficients). See the next section for notes on more complicated, hierarchical models that can incorporate features like metallicity distribution functions.","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.fit_templates","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.fit_templates","text":"result = fit_templates(models::AbstractVector{T},\n                       data::AbstractMatrix{<:Number};\n                       x0::AbstractVector{<:Number} = ones(S,length(models)),\n                       kws...) where {S <: Number, T <: AbstractMatrix{S}}\n\nFinds both maximum likelihood estimate (MLE) and maximum a posteriori estimate (MAP) for the coefficients coeffs such that the composite Hess diagram model is sum(models .* coeffs) using the provided templates models and the observed Hess diagram data. Utilizes the Poisson likelihood ratio (equations 7–10 in Dolphin 2002) for the likelihood of the data given the model. See the examples in the documentation for comparisons of the results of this method and hmc_sample which samples the posterior via Hamiltonian Monte Carlo. \n\nArguments\n\nmodels::AbstractVector{AbstractMatrix{<:Number}}: the list of template Hess diagrams for the simple stellar populations (SSPs) being considered; all must have the same size.\ndata::AbstractMatrix{<:Number}: the observed Hess diagram; must match the size of the templates contained in models.\n\nKeyword Arguments\n\nx0: The vector of initial guesses for the stellar mass coefficients. You should basically always be calculating and passing this keyword argument; we provide StarFormationHistories.construct_x0 to prepare x0 assuming constant star formation rate, which is typically a good initial guess.\n\nOther kws... are passed to Optim.options to set things like convergence criteria for the optimization. \n\nReturns\n\nresult is a NamedTuple containing two StarFormationHistories.LogTransformFTResult. The two components of result are result.map or result[1], which contains the results of the MAP optimization, and result.mle or result[2], which contains the results of the MLE optimization. The documentation for StarFormationHistories.LogTransformFTResult contains more information about these types, but briefly they contain the following fields, accessible as, e.g., result.map.μ, result.map.σ, etc.:\n\nμ::Vector{<:Number} are the optimized coeffs at the maximum.\nσ::Vector{<:Number} are the standard errors on the coeffs μ calculated from an estimate of the inverse Hessian matrix evaluated at μ. The inverse of the Hessian matrix at the maximum of the likelihood (or posterior) is a estimator for the variance-covariance matrix of the parameters, but is only accurate when the second-order expansion given by the Hessian at the maximum is a good approximation to the function being optimized (i.e., when the optimized function is approximately quadratic around the maximum; see Dovi et al. 1991 for more information). We find this is often the case for the MAP estimate, but the errors found for coefficients that are ≈0 in the MLE are typically unrealistically small. For coefficients significantly greater than 0, the σ values from the MAP and MLE are typically consistent to 5–10%.\ninvH::Matrix{<:Number} is the estimate of the inverse Hessian matrix at μ that was used to derive σ. The optimization is done under a logarithmic transform, such that θ[j] = log(coeffs[j]) are the actual parameters optimized, so the entries in the Hessian are actually\n\nH^(jk) ( boldsymbolhat theta ) = left fracpartial^2  J(boldsymboltheta)partial theta_j  partial theta_k rightvert_boldsymboltheta=boldsymbolhat theta\n\nresult is the full object returned by the optimization from Optim.jl; this is of type Optim.MultivariateOptimizationResults. Remember that the optimization is done with parameters θ[j] = log(coeffs[j]) when dealing with this raw output. This means that, for example, we calculate result.map.μ as exp.(Optim.minimizer(result.map.result)).\n\nThe special property of the StarFormationHistories.LogTransformFTResult type is that you can draw a set of N::Integer random parameter samples from the result using the inverse Hessian approximation discussed above by doing rand(result.map, N). This type implements the random sampling API of Distributions.jl so the other standard sampling methods should work as well. In our tests these samples compare very favorably against those from hmc_sample, which samples the posterior via Hamiltonian Monte Carlo and is therefore more robust but much more expensive. We compare these methods in the examples.\n\nNotes\n\nThis method uses the BFGS method from Optim.jl internally because it builds and tracks the inverse Hessian matrix approximation which can be used to estimate parameter uncertainties. BFGS is much more memory-intensive than LBFGS (as used for StarFormationHistories.fit_templates_lbfgsb) for large numbers of parameters (equivalently, many models), so you should consider LBFGS to solve for the MLE along with hmc_sample to sample the posterior if you are using a large grid of models (greater than a few hundred).\nThe BFGS implementation we use from Optim.jl uses BLAS operations during its iteration. The OpenBLAS that Julia ships with will often default to running on multiple threads even if Julia itself is started with only a single thread. You can check the current number of BLAS threads with import LinearAlgebra: BLAS; BLAS.get_num_threads(). For the problem sizes typical of this function we actually see performance regression with larger numbers of BLAS threads. For this reason you may wish to use BLAS in single-threaded mode; you can set this as import LinearAlgebra: BLAS; BLAS.set_num_threads(1).\n\n\n\n\n\nfit_templates(models::AbstractMatrix{S},\n              data::AbstractVector{<:Number};\n              x0::AbstractVector{<:Number} = ones(S,length(models)),\n              kws...) where S <: Number\n\nThis call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/#StarFormationHistories.LogTransformFTResult","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.LogTransformFTResult","text":"LogTransformFTResult(μ::AbstractVector{<:Number},\n                     σ::AbstractVector{<:Number},\n                     invH::AbstractMatrix{<:Number},\n                     result)\n\nType for containing the maximum likelihood estimate (MLE) and maximum a posteriori (MAP) results from fit_templates. The fitted coefficients are available in the μ field. Estimates of the standard errors are available in the σ field. These have both been transformed from the native logarithmic fitting space into natural units (i.e., stellar mass or star formation rate).\n\ninvH contains the estimated inverse Hessian of the likelihood / posterior at the maximum point in the logarithmic fitting units. result is the full result object returned by the optimization routine.\n\nThis type is implemented as a subtype of Distributions.Sampleable{Multivariate, Continuous} to enable sampling from an estimate of the likelihood / posterior distribution. We approximate the distribution as a multivariate Gaussian in the native (logarithmically transformed) fitting variables with covariance matrix invH and means log.(μ). We find this approximation is good for the MAP result but less robust for the MLE. You can obtain N::Integer samples from the distribution by rand(R, N) where R is an instance of this type; this will return a size length(μ) x N matrix, or fail if invH is not positive definite.\n\nExamples\n\njulia> result = fit_templates(models, data);\n\njulia> typeof(result.map)\nStarFormationHistories.LogTransformFTResult{...}\n\njulia> size(rand(result.map, 3)) == (length(models),3)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Once you have obtained stellar mass coefficients from the above methods, you can convert them into star formation rates and compute per-age mean metallicities with StarFormationHistories.calculate_cum_sfr.","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.calculate_cum_sfr","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.calculate_cum_sfr","text":"(unique_logAge, cum_sfh, sfr, mean_MH) =\n    calculate_cum_sfr(coeffs::AbstractVector,\n                      logAge::AbstractVector,\n                      MH::AbstractVector,\n                      T_max::Number;\n                      normalize_value=1,\n                      sorted::Bool=false)\n\nCalculates cumulative star formation history, star formation rates, and mean metallicity evolution as functions of logAge = log10(age [yr]).\n\nArguments\n\ncoeffs::AbstractVector is a vector of stellar mass coefficients such as those returned by fit_templates, for example. Actual stellar mass in stellar population j is coeffs[j] * normalize_value.\nlogAge::AbstractVector is a vector giving the log10(age [yr]) of the stellar populations corresponding to the provided coeffs. For the purposes of calculating star formation rates, these are assumed to be left-bin edges.\nMH::AbstractVector is a vector giving the metallicities of the stellar populations corresponding to the provided coeffs.\nT_max::Number is the rightmost final bin edge for calculating star formation rates in units of Gyr. For example, you might have logAge=[6.6, 6.7, 6.8] in which case a final logAge of 6.9 would give equal bin widths. In this case you would set T_max = exp10(6.9) / 1e9 ≈ 0.0079 so that the width of the final bin for the star formation rate calculation has the same log10(Age [yr]) step as the other bins.\n\nKeyword Arguments\n\nnormalize_value is a multiplicative prefactor to apply to all the coeffs; same as the keyword in partial_cmd_smooth.\nsorted::Bool is either true or false and signifies whether to assume logAge is sorted.\n\nReturns\n\nunique_logAge::Vector is essentially unique(sort(logAge)) and provides the x-values you would plot the other returned vectors against.\ncum_sfh::Vector is the normalized cumulative SFH implied by the provided coeffs. This is ~1 at the most recent time in logAge and decreases as logAge increases.\nsfr::Vector gives the star formation rate across each bin in unique_logAge. If coeffs .* normalize_value are in units of solar masses, then sfr is in units of solar masses per year.\nmean_MH::Vector gives the stellar-mass-weighted mean metallicity of the stellar population as a function of unique_logAge. \n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We have constructed an example Jupyter notebook that highlights some common use cases supported by the package. It is recommended that you read some of the background in our main documentation before or concurrently with the example. The notebook is available in the repository as examples/fitting1.ipynb and can be viewed in rendered form at this link. It relies on a custom isochrone file which can be made available upon request to the package author.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are other scripts in the examples directory of the source repository that are used to generate figures for the documentation and provide more targeted examples of usage.","category":"page"},{"location":"fitting/hierarchical/fixed_amr/#Fixed-Age-Metallicity-Relations","page":"Fixed Age-Metallicity Relations","title":"Fixed Age-Metallicity Relations","text":"","category":"section"},{"location":"fitting/hierarchical/fixed_amr/","page":"Fixed Age-Metallicity Relations","title":"Fixed Age-Metallicity Relations","text":"It is often the case that one may want to fit for star formation rates under a fixed age-metallicity relation or other metallicity evolution model with no degrees of freedom. Such functionality is provided by fixed_amr, which takes as input the relative weights (relweights in the function call, equivalently the r_jk in the above derivation) on each template due to a predetermined metallicity model and fits only the per-age-bin coefficients (R_j in the above derivation). ","category":"page"},{"location":"fitting/hierarchical/fixed_amr/#StarFormationHistories.fixed_amr","page":"Fixed Age-Metallicity Relations","title":"StarFormationHistories.fixed_amr","text":"fixed_amr(models::AbstractVector{T},\n          data::AbstractMatrix{<:Number},\n          logAge::AbstractVector{<:Number},\n          metallicities::AbstractVector{<:Number},\n          relweights::AbstractVector{<:Number};\n          relweightsmin::Number=0, \n          x0=construct_x0_mdf(logAge, convert(S,13.7)),\n          kws...) where {S <: Number, T <: AbstractMatrix{S}}\nfixed_amr(models::AbstractMatrix{S},\n          data::AbstractVector{<:Number},\n          logAge::AbstractVector{<:Number},\n          metallicities::AbstractVector{<:Number},\n          relweights::AbstractVector{<:Number};\n          relweightsmin::Number=0,\n          x0=construct_x0_mdf(logAge, convert(S,13.7)),\n          kws...) where S <: Number\n\nMethod that fits a linear combination of the provided Hess diagrams models to the observed Hess diagram data, under an externally-imposed age-metallicity relation (AMR) and/or metallicity distribution function (MDF). As such, a number of coefficients equal to length(unique(logAge)) are returned; that is, only one coefficient is derived per unique entry in logAge.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. This is most commonly a logarithmic abundance like [M/H] or [Fe/H], but you could use a linear abundance like the metal mass fraction Z if you wanted to. There are some notes on the Wikipedia that might be useful.\nrelweights::AbstractVector{<:Number} is a vector of length equal to that of models which contains the relative weights to apply to each model Hess diagram resulting from an externally-imposed age-metallicity relation and/or metallicity distribution function. Additional details on how to create these weights is provided in the notes below and in the online documentation.\n\nKeyword Arguments\n\nrelweightsmin truncates the input list of models based on the provided relweights, providing a speedup at the cost of precision by removing models that contribute least to the overall composite model. By default, no truncation of the input is performed and all provided models are used in the fit. We recommend this only be increased when fitting performance begins to impact workflow (e.g., when running massive Monte Carlo experiments). See StarFormationHistories.truncate_relweights for implementation details. \nx0 is the vector of initial guesses for the stellar mass coefficients per unique entry in logAge. You should basically always be calculating and passing this keyword argument. We provide StarFormationHistories.construct_x0_mdf to prepare x0 assuming constant star formation rate, which is typically a good initial guess. \n\nOther kws... are passed to Optim.options to set things like convergence criteria for the optimization.\n\nNotes\n\nAll metallicity-related weighting of the models is assumed to be captured in the provided relweights vector, which has the same length as the logAge, metallicities, and models vectors. Each entry in relweights is assumed to be a relative weight for the corresponding model. For example, for the model Hess diagram models[i], with log10(age [yr]) = logAge[i] and metallicity metallicities[i], the relative weight due to the model's age and metallicity w(logAge[i], metallicities[i]) is assumed to be relweights[i]. The sum of all relweights for each unique entry in logAge should be 1; i.e., the following condition should be met: all( sum(relweights[logAge .== la]) ≈ 1 for la in unique(logAge)). If this is not the case, this function will issue a warning and attempt to renormalize relweights by mutating the vector in place. More information on preparation of the relweights for input to this method is provided in our online documentation. \nThis function is designed to work best with a \"grid\" of stellar models, defined by the outer product of N unique entries in logAge and M unique entries in metallicities. See the examples for more information on usage.\n\n\n\n\n\n","category":"function"},{"location":"fitting/hierarchical/log_amr/#Logarithmic-Age-Metallicity-Relation","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"","category":"section"},{"location":"fitting/hierarchical/log_amr/#Definition","page":"Logarithmic Age-Metallicity Relation","title":"Definition","text":"","category":"section"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"This model differs from the linear age-metallicity relation (AMR) in its definition of the mean metallicity at lookback time t. In the linear model, we defined the mean metallicity as langle textMtextH rangle (t) = alpha  left( T_textmax - t_j right) + beta, whereas in this model we define the metal mass fraction Z to be linear with lookback time, such that [M/H] scales logarithmically with lookback time,","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nlangle Z rangle (t) = alpha  left( T_textmax - t right) + beta \nlangle textMtextHrangle (t) equiv textlog left( fraclangle Z rangle left(tright)X right) - textlog left( fracZ_odotX_odot right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"with T_textmax being the earliest lookback time under consideration, such that langle Z rangle (T_textmax) = beta. We choose this parameterization so that positive alpha and beta result in an age-metallicity relation that is monotonically increasing with decreasing lookback time t. If we model the spread in metallicities at fixed t as Gaussian in [M/H] with the GaussianDispersion dispersion model, this implies the spread is asymmetric in Z; this can be seen in the output of examples/log_amr/log_amr_example.jl, shown below, which illustrates the relative weights due to a logarithmic AMR across a grid of ages and metallicities.","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"This logarithmic AMR is implemented with the LogarithmicAMR type, which is a subtype of AbstractAMR.","category":"page"},{"location":"fitting/hierarchical/log_amr/#StarFormationHistories.LogarithmicAMR","page":"Logarithmic Age-Metallicity Relation","title":"StarFormationHistories.LogarithmicAMR","text":"LogarithmicAMR(α::Real,\n               β::Real,\n               T_max::Real = 137//10,\n               MH_func = MH_from_Z,\n               dMH_dZ = dMH_dZ,\n               free::NTuple{2, Bool} = (true, true))\n\nSubtype of AbstractAMR implementing the logarithmic age-metallicity relation where the mean metal mass fraction Z  at a lookback time t_j (in Gyr) is Z = α * (T_max - t_j) + β. α is therefore a slope describing the rate of change in the metal mass fraction per Gyr, and β is the mean metal mass fraction of stars being born at a lookback time of T_max, which has units of Gyr. MH_func must be a callable (e.g., a function) that takes a single argument Z and converts it to [M/H]; the default function is appropriate for PARSEC stellar models. dMH_dZ must be a callable that takes a single argument Z and returns the derivative of MH_func with respect to Z. free controls whether α and β should be freely fit or fixed when passed into fit_sfh; if free[1] == true then α will be freely fit, whereas it will fixed if free[1] == false. free[2] has the same effect but for β. \n\n\n\n\n\nLogarithmicAMR(constraint1, constraint2, T_max::Real=137//10,\n               MH_func = MH_from_Z, dMH_dZ = dMH_dZ, Z_func = Z_from_MH,\n               free::NTuple{2, Bool}=(true, true))\n\nConstruct an instance of LogarithmicAMR from MH constraints at two different lookback times. Each of constraint1 and constraint2 should be length-2 indexables (e.g., tuples) whose first element is a metallicity [M/H] and second element is a lookback time in Gyr. The order of the constraints does not matter.\n\nExamples\n\njulia> LogarithmicAMR((-2.5, 13.7), (-1.0, 0.0), 13.7) isa LogarithmicAMR{Float64}\ntrue\n\njulia> LogarithmicAMR((-2.5, 13.7), (-1.0, 0.0), 13.7) ==\n           LogarithmicAMR((-1.0, 0.0), (-2.5, 13.7), 13.7)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"The per-model coefficients (the r_jk above) implied by a such a logarithmic AMR can be calculated with calculate_coeffs and an example is shown below.","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"ENV[\"GKSwstype\"] = \"100\" # https://discourse.julialang.org/t/generation-of-documentation-fails-qt-qpa-xcb-could-not-connect-to-display/60988 # hide\ninclude(\"../../../../examples/log_amr/log_amr_example.jl\") # hide\nsavefig(\"log_amr_plot.svg\"); nothing # hide","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"(Image: Visualization of the relative weights across a grid of logAge and metallicity under a logarithmic age-metallicity relation.)","category":"page"},{"location":"fitting/hierarchical/log_amr/#Fitting-Functions","page":"Logarithmic Age-Metallicity Relation","title":"Fitting Functions","text":"","category":"section"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"fit_sfh and sample_sfh both work with this AMR model.","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"The method StarFormationHistories.construct_x0_mdf can be used to construct the stellar mass components R_j of the initial guess vector x0.","category":"page"},{"location":"fitting/hierarchical/log_amr/#Implementation","page":"Logarithmic Age-Metallicity Relation","title":"Implementation","text":"","category":"section"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"As the only part of the model that differs from the linear AMR case is the mean age-metallicity relation, most of the derivation for the linear AMR case is still valid here. In particular, only the partial derivatives of the relative weights A_jk equiv textexp left( -frac12  sigma^2  left( textMtextH_k - mu_j right)^2right) with respect to the fitting parameters alpha and beta need to be recalculated under the new model. The partial derivative with respect to sigma is the same, as the mean metallicity in time bin j, denoted mu_j, does not depend on sigma.","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nZ_j equiv langle Z left(t_jright) rangle = alpha  left( T_textmax - t_j right) + beta \n \nmu_j equiv langle textMtextH rangle left(t_jright) = textlog left( fraclangle Zleft(t_jright) rangleX_j right) - textlog left( fracZ_odotX_odot right) \n= textlog left frac alpha  left( T_textmax - t_j right) + betaX_j right - textlog left( fracZ_odotX_odot right)\nendaligned","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"We can use the chain rule to write","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nA_jk equiv textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nfracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial beta \nfracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial alpha \nendaligned ","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"By definition the hydrogen, helium, and metal mass fractions, X, Y, and Z respectively, must sum to 1. For PARSEC models, Y is a function of Z (see Y_from_Z) such that X_j is a function of Z_j and therefore also alpha and beta. Under the PARSEC model, Y = Y_p + gamma  Z, we have X(Z) = 1 - left( Y_p + gamma  Z right) - Z such that we can rewrite the mu_j as ","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"mu_j = textlog left( fracZ_j1 - left( Y_p + gamma  Z_j right) - Z_j right) - textlog left( fracZ_odotX_odot right)","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"and we can further expand the partial derivatives of mu_j as","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial mu_jpartial beta = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial beta \nfracpartial mu_jpartial alpha = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial alpha \nendaligned ","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"such that the model-dependent portion left( fracpartial Z_jpartial beta right) can be separated from what is essentially a calibration defining how [M/H] is calculated from Z left( fracpartial mu_jpartial Z_j right). Given our model Z_j = alpha  left( T_textmax - t_j right) + beta and the PARSEC calibration for conversion between Z_j and mu_j (i.e., [M/H]), we have","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial mu_jpartial Z_j = fracY_p - 1textln10  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) \nfracpartial Z_jpartial beta = fracpartial leftalpha  left( T_textmax - t_j right) + beta rightpartial beta = 1 \nfracpartial Z_jpartial alpha = fracpartial left alpha  left( T_textmax - t_j right) + beta rightpartial alpha = T_textmax - t_j \nendaligned","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"[M/H] as a function of Z for the PARSEC calibration is available as MH_from_Z and the partial derivative fracpartial mu_jpartial Z_j is available as dMH_dZ.","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"Which gives us final results","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial  A_jkpartial  mu_j = fracA_jk  left( textMtextH_k - mu_j right)sigma^2 \nfracpartial mu_jpartial beta = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial beta = left( fracY_p - 1textln(10)  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right)  left( 1 right) \nfracpartial mu_jpartial alpha = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial alpha = left( fracY_p - 1textln(10)  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right)  left( T_textmax - t_j right) \n\n fracpartial mu_jpartial beta = frac1left( t_j  alpha + beta right)  textln(10) \n fracpartial mu_jpartial alpha = fractleft( t_j  alpha + beta right)  textln(10) = t  fracpartial mu_jpartial beta \nendaligned","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"such that","category":"page"},{"location":"fitting/hierarchical/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial Z_j  fracpartial Z_jpartial beta \n= left( fracA_jk  left( textMtextH_k - mu_j right)sigma^2 right)  left( fracY_p - 1textln10  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right) \nfracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial Z_j  fracpartial Z_jpartial alpha \n= left( fracA_jk  left( textMtextH_k - mu_j right)sigma^2 right)  left( fracY_p - 1textln10  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right)  left( T_textmax - t_j right) \n= left( T_textmax - t_j right) fracpartial  A_jkpartial  beta \n\n fracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial beta = left( fracA_jk  left( textMtextH_k - mu_j right)sigma^2 right)  left( frac1left( t_j  alpha + beta right)  textln(10) right) \n = fracA_jk  left( textMtextH_k - mu_j right)textln(10)  sigma^2  left( t_j  alpha + beta right) \n fracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial alpha = t  fracpartial  A_jkpartial  beta\nendaligned","category":"page"},{"location":"#overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package enables many different kinds of analysis related to astrophysical star formation histories (SFHs). Core among these functionalities are generation of mock color-magnitude diagrams (CMDs) from input SFHs and fitting of SFHs from observed CMDs. The methods of this package have been designed to be simple to use but easy to extend. It is recommended that you use this package in conjunction with InitialMassFunctions.jl which provides implementations of the most popular stellar initial mass functions as new types which are natively supported by this package's methods.","category":"page"}]
}
