<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulating Color-Magnitude Diagrams · StarFormationHistories.jl</title><meta name="title" content="Simulating Color-Magnitude Diagrams · StarFormationHistories.jl"/><meta property="og:title" content="Simulating Color-Magnitude Diagrams · StarFormationHistories.jl"/><meta property="twitter:title" content="Simulating Color-Magnitude Diagrams · StarFormationHistories.jl"/><meta name="description" content="Documentation for StarFormationHistories.jl."/><meta property="og:description" content="Documentation for StarFormationHistories.jl."/><meta property="twitter:description" content="Documentation for StarFormationHistories.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StarFormationHistories.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Deriving Star Formation Histories from Hess Diagrams</span><ul><li><a class="tocitem" href="../fitting/fitting_intro/">Background and Template Construction</a></li><li><a class="tocitem" href="../fitting/unconstrained/">High-Level Methods for Unconstrained Fitting</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Metallicity Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fitting/hierarchical/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-3-2" type="checkbox"/><label class="tocitem" for="menuitem-2-3-2"><span class="docs-label">AMRs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fitting/hierarchical/linear_amr/">Linear Age-Metallicity Relation</a></li><li><a class="tocitem" href="../fitting/hierarchical/log_amr/">Logarithmic Age-Metallicity Relation</a></li><li><a class="tocitem" href="../fitting/hierarchical/fixed_amr/">Fixed Age-Metallicity Relations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3-3"><span class="docs-label">MZRs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fitting/hierarchical/MZR/MZR/">Mass-Metallicity Relations (MZRs)</a></li></ul></li><li><a class="tocitem" href="../fitting/hierarchical/dispersion_models/">Metallicity Dispersion Models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fitting/internals/">Low-Level Functions</a></li><li><a class="tocitem" href="../fitting/kernels/">Kernels</a></li></ul></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Simulating Color-Magnitude Diagrams</a><ul class="internal"><li><a class="tocitem" href="#Simple-Stellar-Populations"><span>Simple Stellar Populations</span></a></li><li><a class="tocitem" href="#Complex-Stellar-Populations"><span>Complex Stellar Populations</span></a></li><li><a class="tocitem" href="#Observational-Effects"><span>Observational Effects</span></a></li><li><a class="tocitem" href="#Developer-Internals"><span>Developer Internals</span></a></li></ul></li><li><a class="tocitem" href="../binaries/">Binary Systems</a></li><li><a class="tocitem" href="../helpers/">Helper Functions</a></li><li><a class="tocitem" href="../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simulating Color-Magnitude Diagrams</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulating Color-Magnitude Diagrams</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cgarling/StarFormationHistories.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cgarling/StarFormationHistories.jl/blob/main/docs/src/simulate.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="simulate"><a class="docs-heading-anchor" href="#simulate">Simulating Color-Magnitude Diagrams</a><a id="simulate-1"></a><a class="docs-heading-anchor-permalink" href="#simulate" title="Permalink"></a></h1><p>Modelling observations of resolved stellar populations (e.g., color-magnitude or Hess diagrams) with user-defined star formation histories can be useful for comparison to actual observations, but also enables a number of other scientific activities (e.g., making predictions to motivate observational proposals). To support these uses we offer methods for sampling stellar populations from isochrones using user-defined star formation histories, initial mass functions, and stellar binary models. These methods require data from user-provided isochrones (this package does not provide any), an initial mass function model (such as those provided in <a href="https://github.com/cgarling/InitialMassFunctions.jl">InitialMassFunctions.jl</a>), and a model specifying how (or if) to sample <a href="../binaries/#binaries">binary or multi-star systems</a>. </p><p>The simplest methods only sample stars from a single stellar population. We provide a method that samples up to a provided stellar mass, <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a> (e.g., <span>$10^7 \, \text{M}_\odot$</span>) and a method that samples up to a provided absolute magnitude <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a> (e.g., <span>$M_V=-10$</span>). These are documented under the first subsection below. These methods are single-threaded.</p><p>We also offer methods for sampling populations with complex star formation histories; these are implicitly multi-threaded across the separate populations if you start Julia with multiple threads (e.g., with <code>julia -t 4</code> or similar). We provide <a href="#StarFormationHistories.generate_stars_mass_composite"><code>generate_stars_mass_composite</code></a> for sampling such populations up to a provided stellar mass and <a href="#StarFormationHistories.generate_stars_mag_composite"><code>generate_stars_mag_composite</code></a> for sampling such populations up to a provided absolute magnitude. These are documented under the second subsection below.</p><h2 id="Simple-Stellar-Populations"><a class="docs-heading-anchor" href="#Simple-Stellar-Populations">Simple Stellar Populations</a><a id="Simple-Stellar-Populations-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Stellar-Populations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.generate_stars_mass" href="#StarFormationHistories.generate_stars_mass"><code>StarFormationHistories.generate_stars_mass</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_stars_mass(mini_vec::AbstractVector{&lt;:Number},
                    mags, mag_names::AbstractVector{String},
                    limit::Number,
                    imf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous};
                    dist_mod::Number=0,
                    rng::Random.AbstractRNG=Random.default_rng(),
                    mag_lim::Number = Inf,
                    mag_lim_name::String = &quot;V&quot;,
                    binary_model::StarFormationHistories.AbstractBinaryModel =
                        StarFormationHistories.RandomBinaryPairs(0.3))</code></pre><p>Generates a random sample of stars from an isochrone defined by the provided initial stellar masses <code>mini_vec</code>, absolute magnitudes <code>mags</code>, and filter names <code>mag_names</code> with total population birth stellar mass <code>limit</code> (e.g., 1e5 solar masses). Initial stellar masses are sampled from the provided <code>imf</code>. </p><p><strong>Arguments</strong></p><ul><li><code>mini_vec::AbstractVector{&lt;:Number}</code> contains the initial masses (in solar masses) for the stars in the isochrone; must be mutable as we call <code>Interpolations.deduplicate_knots!(mini_vec)</code>.</li><li><code>mags</code> contains the absolute magnitudes from the isochrone in the desired filters corresponding to the same stars as provided in <code>mini_vec</code>. <code>mags</code> is internally interpreted and converted into a standard format by <a href="#StarFormationHistories.ingest_mags"><code>StarFormationHistories.ingest_mags</code></a>. Valid inputs are:<ul><li><code>mags::AbstractVector{AbstractVector{&lt;:Number}}</code>, in which case the length of the outer vector <code>length(mags)</code> can either be equal to <code>length(mini_vec)</code>, in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to <code>length(mini_vec)</code>; this is the more common use-case.</li><li><code>mags::AbstractMatrix{&lt;:Number}</code>, in which case <code>mags</code> must be 2-dimensional. Valid shapes are <code>size(mags) == (length(mini_vec), nfilters)</code> or <code>size(mags) == (nfilters, length(mini_vec))</code>, with <code>nfilters</code> being the number of filters you are providing.</li></ul></li><li><code>mag_names::AbstractVector{String}</code> contains strings describing the filters you are providing in <code>mags</code>; an example might be <code>[&quot;B&quot;,&quot;V&quot;]</code>. These are used when <code>mag_lim</code> is finite to determine what filter you want to use to limit the faintest stars you want returned.</li><li><code>limit::Number</code> gives the total birth stellar mass of the population you want to sample. See the &quot;Notes&quot; section on population masses for more information.</li><li><code>imf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous}</code> is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined <code>rand(rng::Random.AbstractRNG, imf)</code> method to use for sampling masses. All instances of <code>Distributions.ContinuousUnivariateDistribution</code> are also valid. Implementations of commonly used IMFs are available in <a href="https://github.com/cgarling/InitialMassFunctions.jl">InitialMassFunctions.jl</a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_mod::Number=0</code> is the distance modulus (see <a href="../helpers/#StarFormationHistories.distance_modulus"><code>StarFormationHistories.distance_modulus</code></a>) you wish to have added to the returned magnitudes to simulate a population at a particular distance.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code> is the rng instance that will be used to sample the stellar initial masses from <code>imf</code>.</li><li><code>mag_lim::Number=Inf</code> gives the faintest apparent magnitude for stars you want to be returned in the output. Stars fainter than this magnitude will still be sampled and contribute properly to the total mass of the population, but they will not be returned.</li><li><code>mag_lim_name::String=&quot;V&quot;</code> gives the filter name (as contained in <code>mag_names</code>) to use when considering if a star is fainter than <code>mag_lim</code>. This is unused if <code>mag_lim</code> is infinite.</li><li><code>binary_model::StarFormationHistories.AbstractBinaryModel=StarFormationHistories.RandomBinaryPairs(0.3)</code> is an instance of a model for treating binaries; currently provided options are <a href="../binaries/#StarFormationHistories.NoBinaries"><code>NoBinaries</code></a>, <a href="../binaries/#StarFormationHistories.RandomBinaryPairs"><code>RandomBinaryPairs</code></a>, and <a href="../binaries/#StarFormationHistories.BinaryMassRatio"><code>BinaryMassRatio</code></a>.</li></ul><p><strong>Returns</strong></p><p><code>(sampled_masses, sampled_mags)</code> defined as</p><ul><li><code>sampled_masses::Vector{SVector{N,eltype(imf)}}</code> is a vector containing the initial stellar masses of the stars sampled by <a href="../binaries/#StarFormationHistories.sample_system"><code>sample_system</code></a>; see that method&#39;s documentation for details on format. In short, each <code>StaticArrays.SVector</code> represents one stellar system and each entry in each <code>StaticArrays.SVector</code> is one star in that system. Entries will be 0 when companions could have been sampled but were not (i.e., when using a <code>binary_model</code> that supports multi-star systems). </li><li><code>sampled_mags::Vector{SVector{N,&lt;:Number}}</code> is a vector containing <code>StaticArrays.SVectors</code> with the multi-band magnitudes of the sampled stars. To get the magnitude of star <code>i</code> in band <code>j</code>, you index as <code>sampled_mags[i][j]</code>. This can be reinterpreted as a 2-dimensional <code>Matrix</code> with <code>reduce(hcat,sampled_mags)</code>. </li></ul><p><strong>Notes</strong></p><p><strong>Population Masses</strong></p><p>Given a particular isochrone with an initial mass vector <code>mini_vec</code>, it will never cover the full range of stellar birth masses because stars that die before present-day are not included in the isochrone. However, these stars <em>were</em> born, and so contribute to the total birth mass of the system. There are two ways to properly account for this lost mass when sampling:</p><ol><li>Set the upper limit for masses that can be sampled from the <code>imf</code> distribution to a physical value for the maximum birth mass of stars (e.g., 100 solar masses). In this case, these stars will be sampled from <code>imf</code>, and will contribute their masses to the system, but they will not be returned if their birth mass is greater than <code>maximum(mini_vec)</code>. This is typically easiest for the user and only results in ∼15% loss of efficiency for 10 Gyr isochrones. <em>This approach is preferred when sampling with binaries.</em></li><li>Set the upper limit for masses that can be sampled from the <code>imf</code> distribution to <code>maximum(mini_vec)</code> and adjust <code>limit</code> to respect the amount of initial stellar mass lost by not sampling higher mass stars. This can be calculated as <code>new_limit = limit * ( QuadGK.quadgk(x-&gt;x*pdf(imf,x), minimum(mini_vec), maximum(mini_vec))[1] / QuadGK.quadgk(x-&gt;x*pdf(imf,x), minimum(imf), maximum(imf))[1] )</code>, with the multiplicative factor being the fraction of the population stellar mass contained in stars with initial masses between <code>minimum(mini_vec)</code> and <code>maximum(mini_vec)</code>; this factor is the ratio</li></ol><p class="math-container">\[\frac{\int_a^b \ m \times \frac{dN(m)}{dm} \ dm}{\int_0^∞ \ m \times \frac{dN(m)}{dm} \ dm}.\]</p><p>Note that, if binaries are included, this approach only forms binary pairs between stars whose masses are less than <code>maximum(mini_vec)</code>. This is probably not desired, so we recommend the previous approach when including binaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L260-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.generate_stars_mag" href="#StarFormationHistories.generate_stars_mag"><code>StarFormationHistories.generate_stars_mag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(sampled_masses, sampled_mags) =  generate_stars_mag(mini_vec::AbstractVector{&lt;:Number}, mags, mag_names::AbstractVector{String}, absmag::Real, absmag_name::String, imf::Distributions.Sampleable{Distributions.Univariate,Distributions.Continuous}; dist_mod::Number=0, rng::AbstractRNG=default_rng(), mag_lim::Number=Inf, mag_lim_name::String=&quot;V&quot;, binary_model::StarFormationHistories.AbstractBinaryModel=RandomBinaryPairs(0.3))</code></pre><p>Generates a mock stellar population from an isochrone defined by the provided initial stellar masses <code>mini_vec</code>, absolute magnitudes <code>mags</code>, and filter names <code>mag_names</code>. The population is sampled to a total absolute magnitude <code>absmag::Real</code> (e.g., -7 or -12) in the filter <code>absmag_name::String</code> (e.g., &quot;V&quot; or &quot;F606W&quot;) which is contained in the provided <code>mag_names::AbstractVector{String}</code>. Other arguments are shared with <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a>, which contains the main documentation.</p><p><strong>Notes</strong></p><p><strong>Population Magnitudes</strong></p><p>Unlike when sampling a population to a fixed initial birth mass, as is implemented in <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a>, when generating a population up to a fixed absolute magnitude, only stars that survive to present-day contribute to the flux of the population. If you choose to limit the apparent magnitude of stars returned by passing the <code>mag_lim</code> and <code>mag_lim_name</code> keyword arguments, stars fainter than your chosen limit will still be sampled and will still contribute their luminosity to the total population, but they will not be contained in the returned output. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L340-L348">source</a></section></article><h2 id="Complex-Stellar-Populations"><a class="docs-heading-anchor" href="#Complex-Stellar-Populations">Complex Stellar Populations</a><a id="Complex-Stellar-Populations-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Stellar-Populations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.generate_stars_mass_composite" href="#StarFormationHistories.generate_stars_mass_composite"><code>StarFormationHistories.generate_stars_mass_composite</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(sampled_masses, sampled_mags) = generate_stars_mass_composite(mini_vec::AbstractVector{&lt;:AbstractVector{&lt;:Number}}, mags::AbstractVector, mag_names::AbstractVector{String}, limit::Number, massfrac::AbstractVector{&lt;:Number}, imf::Sampleable{Univariate,Continuous}; kws...)</code></pre><p>Generates a random sample of stars with a complex star formation history using multiple isochrones. Very similar to <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a> except the isochrone-related arguments <code>mini_vec</code> and <code>mags</code> should now be vectors of vectors containing the relevant data for the full set of isochrones to be considered. The total birth stellar mass of the sampled population is given by <code>limit</code>. The proportion of this mass allotted to each of the individual isochrones is given by the entries of the <code>massfrac</code> vector. This basically just proportions <code>limit</code> according to <code>massfrac</code> and calls <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a> for each of the individual stellar populations; as such it is set up to multi-thread across the multiple stellar populations. </p><p><strong>Arguments</strong></p><ul><li><code>mini_vec::AbstractVector{&lt;:AbstractVector{&lt;:Number}}</code> contains the initial masses (in solar masses) for the stars in each isochrone; the internal vectors must be mutable as we will call <code>Interpolations.deduplicate_knots!</code> on each. The length of <code>mini_vec</code> should be equal to the number of isochrones. </li><li><code>mags</code> contains the absolute magnitudes from the isochrones in the desired filters corresponding to the same stars as provided in <code>mini_vec</code>. The length of <code>mags</code> should be equal to the number of isochrones. The individual elements of <code>mags</code> are each internally interpreted and converted into a standard format by <a href="#StarFormationHistories.ingest_mags"><code>StarFormationHistories.ingest_mags</code></a>. The valid formats for the individual elements of <code>mags</code> are:<ul><li><code>AbstractVector{AbstractVector{&lt;:Number}}</code>, in which case the length of the vector <code>length(mags[i])</code> can either be equal to <code>length(mini_vec[i])</code>, in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to <code>length(mini_vec[i])</code>; this is the more common use-case.</li><li><code>AbstractMatrix{&lt;:Number}</code>, in which case <code>mags[i]</code> must be 2-dimensional. Valid shapes are <code>size(mags[i]) == (length(mini_vec[i]), nfilters)</code> or <code>size(mags[i]) == (nfilters, length(mini_vec[i]))</code>, with <code>nfilters</code> being the number of filters you are providing.</li></ul></li><li><code>mag_names::AbstractVector{String}</code> contains strings describing the filters you are providing in <code>mags</code>; an example might be <code>[&quot;B&quot;,&quot;V&quot;]</code>. These are used when <code>mag_lim</code> is finite to determine what filter you want to use to limit the faintest stars you want returned. These are assumed to be the same for all isochrones.</li><li><code>limit::Number</code> gives the total birth stellar mass of the population you want to sample. </li><li><code>massfrac::AbstractVector{&lt;:Number}</code> is vector giving the relative fraction of mass allotted to each individual stellar population; length must be equal to the length of <code>mini_vec</code> and <code>mags</code>. </li><li><code>imf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous}</code> is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined <code>rand(rng::Random.AbstractRNG, imf)</code> method to use for sampling masses. All instances of <code>Distributions.ContinuousUnivariateDistribution</code> are also valid. Implementations of commonly used IMFs are available in <a href="https://github.com/cgarling/InitialMassFunctions.jl">InitialMassFunctions.jl</a>.</li></ul><p><strong>Keyword Arguments</strong></p><p>All keyword arguments <code>kws...</code> are passed to <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a>; you should refer to that method&#39;s documentation for more information. </p><p><strong>Returns</strong></p><ul><li><code>sampled_masses::Vector{Vector{SVector{N,eltype(imf)}}}</code> is a vector of vectors containing the initial stellar masses of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e., all of <code>sampled_masses[1]</code> were sampled from <code>mini_vec[1]</code> and so on. These can be concatenated into a single vector with <code>reduce(vcat,sampled_masses)</code>. The format of the contained <code>StaticArrays.SVector</code>s are as output from <a href="../binaries/#StarFormationHistories.sample_system"><code>sample_system</code></a>; see that method&#39;s documentation for more details. </li><li><code>sampled_mags::Vector{Vector{SVector{N,&lt;:Number}}}</code> is a vector of vectors containing <code>StaticArrays.SVectors</code> with the multi-band magnitudes of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e. all of <code>sampled_mags[1]</code> were sampled from <code>mags[1]</code> and so on. To get the magnitude of star <code>i</code> in band <code>j</code> sampled from isochrone <code>k</code>, you would do <code>sampled_mags[k][i][j]</code>. This can be concatenated into a <code>Vector{SVector}</code> with <code>reduce(vcat,sampled_mags)</code> and a 2-D <code>Matrix</code> with <code>reduce(hcat,reduce(vcat,sampled_mags))</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L405-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.generate_stars_mag_composite" href="#StarFormationHistories.generate_stars_mag_composite"><code>StarFormationHistories.generate_stars_mag_composite</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(sampled_masses, sampled_mags) = generate_stars_mag_composite(mini_vec::AbstractVector{&lt;:AbstractVector{&lt;:Number}}, mags::AbstractVector, mag_names::AbstractVector{String}, absmag::Number, absmag_name::String, fracs::AbstractVector{&lt;:Number}, imf::Sampleable{Univariate,Continuous}; frac_type::String=&quot;lum&quot;, kws...)</code></pre><p>Generates a random sample of stars with a complex star formation history using multiple isochrones. Very similar to <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a> except the isochrone-related arguments <code>mini_vec</code> and <code>mags</code> should now be vectors of vectors containing the relevant data for the full set of isochrones to be considered. The total absolute magnitude of the sampled population is given by <code>absmag</code>. The proportion of the luminosity allotted to each of the individual isochrones is given by the entries of the <code>frac</code> vector. This basically just proportions the luminosity according to <code>frac</code> and calls <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a> for each of the individual stellar populations; as such it is set up to multi-thread across the multiple stellar populations. </p><p><strong>Arguments</strong></p><ul><li><code>mini_vec::AbstractVector{&lt;:AbstractVector{&lt;:Number}}</code> contains the initial masses (in solar masses) for the stars in each isochrone; the internal vectors must be mutable as we will call <code>Interpolations.deduplicate_knots!</code> on each. The length of <code>mini_vec</code> should be equal to the number of isochrones. </li><li><code>mags</code> contains the absolute magnitudes from the isochrones in the desired filters corresponding to the same stars as provided in <code>mini_vec</code>. The length of <code>mags</code> should be equal to the number of isochrones. The individual elements of <code>mags</code> are each internally interpreted and converted into a standard format by <a href="#StarFormationHistories.ingest_mags"><code>StarFormationHistories.ingest_mags</code></a>. The valid formats for the individual elements of <code>mags</code> are:<ul><li><code>AbstractVector{AbstractVector{&lt;:Number}}</code>, in which case the length of the vector <code>length(mags[i])</code> can either be equal to <code>length(mini_vec[i])</code>, in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to <code>length(mini_vec[i])</code>; this is the more common use-case.</li><li><code>AbstractMatrix{&lt;:Number}</code>, in which case <code>mags[i]</code> must be 2-dimensional. Valid shapes are <code>size(mags[i]) == (length(mini_vec[i]), nfilters)</code> or <code>size(mags[i]) == (nfilters, length(mini_vec[i]))</code>, with <code>nfilters</code> being the number of filters you are providing.</li></ul></li><li><code>mag_names::AbstractVector{String}</code> contains strings describing the filters you are providing in <code>mags</code>; an example might be <code>[&quot;B&quot;,&quot;V&quot;]</code>. These are used when <code>mag_lim</code> is finite to determine what filter you want to use to limit the faintest stars you want returned. These are assumed to be the same for all isochrones.</li><li><code>absmag::Number</code> gives the total absolute magnitude of the complex population to be sampled. </li><li><code>fracs::AbstractVector{&lt;:Number}</code> is a vector giving the relative fraction of luminosity or mass (determined by the <code>frac_type</code> keyword argument) allotted to each individual stellar population; length must be equal to the length of <code>mini_vec</code> and <code>mags</code>. </li><li><code>imf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous}</code> is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined <code>rand(rng::Random.AbstractRNG, imf)</code> method to use for sampling masses. All instances of <code>Distributions.ContinuousUnivariateDistribution</code> are also valid. Implementations of commonly used IMFs are available in <a href="https://github.com/cgarling/InitialMassFunctions.jl">InitialMassFunctions.jl</a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>frac_type::String</code> either &quot;lum&quot;, in which case <code>fracs</code> is assumed to contain the relative luminosity fractions for each individual isochrone, or &quot;mass&quot;, in which case it is assumed that <code>fracs</code> contains mass fractions (&quot;mass&quot; is not yet implemented). </li></ul><p>All other keyword arguments <code>kws...</code> are passed to <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a>; you should refer to that method&#39;s documentation for more information. </p><p><strong>Returns</strong></p><ul><li><code>sampled_masses::Vector{Vector{SVector{N,eltype(imf)}}}</code> is a vector of vectors containing the initial stellar masses of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e., all of <code>sampled_masses[1]</code> were sampled from <code>mini_vec[1]</code> and so on. These can be concatenated into a single vector with <code>reduce(vcat,sampled_masses)</code>. The format of the contained <code>StaticArrays.SVector</code>s are as output from <a href="../binaries/#StarFormationHistories.sample_system"><code>sample_system</code></a>; see that method&#39;s documentation for more details. </li><li><code>sampled_mags::Vector{Vector{SVector{N,&lt;:Number}}}</code> is a vector of vectors containing <code>StaticArrays.SVectors</code> with the multi-band magnitudes of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e. all of <code>sampled_mags[1]</code> were sampled from <code>mags[1]</code> and so on. To get the magnitude of star <code>i</code> in band <code>j</code> sampled from isochrone <code>k</code>, you would do <code>sampled_mags[k][i][j]</code>. This can be concatenated into a <code>Vector{SVector}</code> with <code>reduce(vcat,sampled_mags)</code> and a 2-D <code>Matrix</code> with <code>reduce(hcat,reduce(vcat,sampled_mags))</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L448-L470">source</a></section></article><h2 id="Observational-Effects"><a class="docs-heading-anchor" href="#Observational-Effects">Observational Effects</a><a id="Observational-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Observational-Effects" title="Permalink"></a></h2><p>The output produced from the above methods are clean in the sense that they do not include any observational effects like photometric error or incompleteness. These effects should be implemented in a post-processing step. We provide a simple method <a href="#StarFormationHistories.model_cmd"><code>model_cmd</code></a> that accepts user-defined photometric error and completeness functions and applies them to the initial catalog, returning a Monte Carlo realization of a possible observed catalog. This method assumes Gaussian photometric errors and that the photometric error and completeness functions are separable by filter – these assumptions are not applicable for all types of data, but the source code for the method is exceedingly simple (~20 lines) and should provide an example for how you could write a similar method that more accurately reflects your data.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.model_cmd" href="#StarFormationHistories.model_cmd"><code>StarFormationHistories.model_cmd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">new_mags [, good_idxs] = model_cmd(mags::AbstractVector{&lt;:AbstractVector{&lt;:Number}}, errfuncs, completefuncs; rng::Random.AbstractRNG=Random.default_rng(), ret_idxs::Bool=false)</code></pre><p>Simple method for modelling photometric error and incompleteness to &quot;mock observe&quot; a pure catalog of stellar photometry, such as those produced by <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a> and <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a>. This method assumes Gaussian photometric errors and that the photometric error and completeness functions are separable by filter. </p><p><strong>Arguments</strong></p><ul><li><code>mags::AbstractVector{&lt;:AbstractVector{&lt;:Number}}</code>: a vector of vectors giving the magnitudes of each star to be modelled. The first index is the per-star index and the second index is the per-filter index (so <code>mags[10][2]</code> would give the magnitude of the tenth star in the second filter). This is the same format as the magnitudes returned by <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a> and <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a>; to use output from the composite versions, you must first <code>reduce(vcat,mags)</code> before passing to this function.</li><li><code>errfuncs</code>: an iterable (typically a vector or tuple) of callables (typically functions or interpolators) with length equal to the number of filters contained in the elements of <code>mags</code>. This iterable must contain callables that, when called with the associated magnitudes from <code>mags</code>, will return the expected 1-σ photometric error at that magnitude. The organization is such that the photometric error for star <code>i</code> in band <code>j</code> is <code>σ_ij = errfuncs[j](mags[i][j])</code>. </li><li><code>completefuncs</code>: an iterable (typically a vector or tuple) of callables (typically functions or interpolators) with length equal to the number of filters contained in the elements of <code>mags</code>. This iterable must contain callables that, when called with the associated magnitudes from <code>mags</code>, will return the probability that a star with that magnitude in that band will be found in your color-magnitude diagram (this should include the original detection probability and any post-detection quality, morphology, or other cuts). The organization is such that the detection probability for star <code>i</code> in band <code>j</code> is <code>c_ij = completefuncs[j](mags[i][j])</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::AbstractRNG=Random.default_rng()</code>: The object to use for random number generation.</li><li><code>ret_idxs::Bool</code>: whether to return the indices of the input <code>mags</code> for the stars that were successfully &quot;observed&quot; and are represented in the output <code>new_mags</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_mags</code>: an object similar to <code>mags</code> (i.e., a <code>Vector{Vector{&lt;:Number}}</code>, <code>Vector{SVector{N,&lt;:Number}}</code>, etc.) containing the magnitudes of the mock-observed stars. This will be shorter than the provided <code>mags</code> vector as we are modelling photometric incompleteness, and the magnitudes will also have random photometric errors added to them. This can be reinterpreted as a 2-dimensional <code>Matrix</code> with <code>reduce(hcat,new_mags)</code>.</li><li><code>good_idxs</code>: if <code>ret_idxs</code> is <code>true</code>, the vector of indices into the input <code>mags</code> for the stars that were successfully &quot;observed&quot; and are represented in the output <code>new_mags</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This is a simple implementation that seeks to show a simple example of how one can post-process catalogs of &quot;pure&quot; stars from methods like <a href="#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a> and <a href="#StarFormationHistories.generate_stars_mag"><code>generate_stars_mag</code></a> to include observational effects. This method assumes Gaussian photometric errors, which may not, in general, be accurate. It also assumes that the total detection probability can be modelled as the product of the single-filter detection probabilities as computed by <code>completefuncs</code> (i.e., that the completeness functions are separable across filters). This can be a reasonable assumption when you have separate photometric catalogs derived for each filter and you only collate them afterwards, but it is generally not a good assumption for detection algorithms that operate on simultaneously on multi-band photometry – the completeness functions for these types of algorithms are generally not separable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L501-L521">source</a></section></article><h2 id="Developer-Internals"><a class="docs-heading-anchor" href="#Developer-Internals">Developer Internals</a><a id="Developer-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.ingest_mags" href="#StarFormationHistories.ingest_mags"><code>StarFormationHistories.ingest_mags</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">new_mags = ingest_mags(mini_vec::AbstractVector, mags::AbstractVector{T}) where {S &lt;: Number, T &lt;: AbstractVector{S}}
new_mags = ingest_mags(mini_vec::AbstractVector, mags::AbstractMatrix{S}) where S &lt;: Number</code></pre><p>Reinterprets provided <code>mags</code> to be in the correct format for input to <code>Interpolations.interpolate</code>.</p><p><strong>Returns</strong></p><ul><li><code>new_mags::Base.ReinterpretArray{StaticArrays.SVector}</code>: a <code>length(mini_vec)</code> vector of <code>StaticArrays.SVectors</code> containing the same data as <code>mags</code> but formatted for input to <code>Interpolations.interpolate</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.sort_ingested" href="#StarFormationHistories.sort_ingested"><code>StarFormationHistories.sort_ingested</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(new_mini_vec, new_mags) = sort_ingested(mini_vec::AbstractVector, mags::AbstractVector)</code></pre><p>Takes <code>mini_vec</code> and <code>mags</code> and ensures that <code>mini_vec</code> is sorted (sometimes in PARSEC isochrones they are not) and calls <code>Interpolations.deduplicate_knots!</code> on <code>mini_vec</code> to ensure there are no repeat entries. Arguments must satisfy <code>length(mini_vec) == length(mags)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.mass_limits" href="#StarFormationHistories.mass_limits"><code>StarFormationHistories.mass_limits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(mmin, mmax) = mass_limits(mini_vec::AbstractVector{&lt;:Number}, mags::AbstractVector{T},
                 mag_names::AbstractVector{String}, mag_lim::Number,
                 mag_lim_name::String) where T &lt;: AbstractVector{&lt;:Number}</code></pre><p>Calculates initial mass limits that reflect a given faint-end magnitude limit.</p><p><strong>Arguments</strong></p><ul><li><code>mini_vec::AbstractVector{&lt;:Number}</code>: a length <code>nstars</code> vector containing initial stellar masses.</li><li><code>mags::AbstractVector{&lt;:AbstractVector{&lt;:Number}}</code>: a length <code>nstars</code> vector, with each element being a length <code>nfilters</code> vector giving the magnitudes of each star in the filters <code>mag_names</code>.</li><li><code>mag_names::AbstractVector{String}</code>: a vector giving the names of each filter as strings.</li><li><code>mag_lim::Number</code>: the faint-end magnitude limit you wish to use.</li><li><code>mag_lim_name::String</code>: the name of the filter in which <code>mag_lim</code> is to be applied. Must be contained in <code>mag_names</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>mmin::eltype(mini_vec)</code>: the initial mass corresponding to your requested <code>mag_lim</code> in the filter <code>mag_lim_name</code>. If all stars provided are brighter than your requested <code>mag_lim</code>, then this will be equal to <code>minimum(mini_vec)</code>.</li><li><code>mmax::eltype(mini_vec)</code>: the maximum valid mass in <code>mini_vec</code>; simply <code>maximum(mini_vec)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; mass_limits([0.05,0.1,0.2,0.3], [[4.0],[3.0],[2.0],[1.0]], [&quot;F090W&quot;], 2.5, &quot;F090W&quot;)
(0.15, 0.3)

julia&gt; mass_limits([0.05,0.1,0.2,0.3], [[4.0,3.0],[3.0,2.0],[2.0,1.0],[1.0,0.0]], [&quot;F090W&quot;,&quot;F150W&quot;], 2.5, &quot;F090W&quot;)
(0.15, 0.3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/bbef2284931261686612d5dd5eb54330267da35e/src/simulate.jl#L65-L91">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../binaries/">Binary Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 25 January 2025 15:54">Saturday 25 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
