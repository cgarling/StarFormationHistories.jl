var documenterSearchIndex = {"docs":
[{"location":"fitting/fitting_intro/#fitting","page":"Background and Template Construction","title":"Background and Template Construction","text":"","category":"section"},{"location":"fitting/fitting_intro/#Background","page":"Background and Template Construction","title":"Background","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"In the classic formulation of star formation history fitting from resolved-star photometry (Dolphin 2002), an observed color-magnitude diagram (CMD) is binned into a 2-D histogram known as a Hess diagram. Such a CMD and Hess diagram pair is shown below.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"(Image: Comparison of CMD and a Hess diagram generated from the same observational data.)","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The representation of the observations as a Hess diagram allows one to apply Poisson statistics, specifically the Poisson likelihood ratio (Equations 7–10 in Dolphin 2002), to model the observations. As the CMD of a complex stellar population is simply the sum of the CMDs of its sub-populations, one need only prepare a number of templates for each simple stellar population (SSP) which may make up the complex population in question and model the observed Hess diagram as a linear combination of these templates. Keeping the same notation as Dolphin 2002 (Equation 1), the complex model Hess diagram is simply","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"m_i = sum_j  r_j  c_ij","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"where m_i is the value of the complex model in bin i, c_ij is the value of simple template j in bin i, and r_j is the multiplicative coefficient determining how significant template j is to the complex population. In Dolphin 2002, he normalizes the templates to identical star formation rates (SFRs) and so the r_j are SFRs as well. In this package, we prefer to normalize our templates to identical population stellar masses, so our r_j are stellar masses, but the principal is the same.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Construction of the templates is, however, not a trivial exercise. Ideally, a template constructed to represent a particular SSP would accurately reflect the expectation of how such a population would be observed. Thus, these templates must be adjusted for photometric error, incompleteness, and other effects such as those caused by unresolved binary- and multi-star systems. Observational effects such as photometric error and incompleteness are best measured from artificial star tests (ASTs). It is worth mentioning that ASTs can often return \"best case\" results, as they typically neglect systematics like uncertainty in the point-spread model used for the photometry; as such it is sometimes necessary to add a systematic error floor to photometric error results from ASTs.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Such templates can be constructed by sampling many mock stars from an initial mass function (IMF), interpolating their absolute magnitudes from an isochrone of the relevant SSP, and \"mock observing\" them by applying photometric error and completeness functions (for example, by looking up the 1sigma photometric error and completeness value from a catalog of artificial stars). Such Monte Carlo templates can be slow to construct and exhibit Poisson shot-noise, requiring a statistical data–data comparison rather than a model–data comparison. Thus this method is non-optimal from both a practical and statistical perspective.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"It is better to form what Dolphin 2002 calls a \"blurred isochrone;\" in this form of template, the SSP isochrone is first interpolated in initial stellar mass to improve the point density along the isochrone. The number of interpolated points is generally a function of the size of the bins in the Hess diagram and the observational error; more points are required as the bin size or photometric errors become smaller. These points are then weighted according to the IMF and the photometric completeness, and this weight is distributed into the Hess diagram following the photometric error distribution determined by similar artificial stars. Dolphin 2002 also mentions interpolating across stellar age/metallicity when constructing such templates; for example, for an SSP with an age of 1 Gyr and a metallicity of [M/H]=-1.0, you could interpolate the isochrones to introduce a Gaussian metallicity spread of 0.05 dex or an age spread of 100 Myr. The general effects of this form of interpolation is to broaden the model templates, particularly features that are very sharp in true SSP models. We neglect this form of interpolation in our implementation as it adds significant complexity and requires users to provide more information about the isochrones that are providing. Such widening of the individual templates is most impactful when photometric errors in the observational data are low (perhaps <0.10 mag).","category":"page"},{"location":"fitting/fitting_intro/#templates","page":"Background and Template Construction","title":"Constructing Templates","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"While the above description summarizes the necessary components for constructing such a blurred isochrone, it can be a bit difficult to figure out how best to actually construct them. Specifically there are many ways that one could implement the observational effects of photometric error and incompleteness. We provide a method partial_cmd_smooth to construct such templates under the assumption of Gaussian photometric error distributions, which is often a good approximation in the high-completeness regime. This method makes use of user-defined functions for the mean photometric error and completeness as a function of magnitude and filter, such that these can be defined in a number of ways; for example, as direct lookups from a large table of ASTs or as simple function evaluations of analytic approximations or fits to the ASTs.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"This method begins by interpolating the provided SSP isochrone to increase point density. For every such point with i band apparent magnitude m_i, it calls a user-defined function to estimate the 1sigma photometric error as sigma_i = f_i(m_i). This is done for each provided photometric filter. These errors are used to define an asymmetric 2-D Gaussian kernel for each point in the interpolated isochrone. This kernel describes the probability distribution of where the isochrone point would be observed in the Hess diagram. The shape of the kernel is automatically adjusted to account for covariance when the magnitude on the y-axis of the Hess diagram also appears in the x-axis color, as occurs when only two filters of imaging are available (for example, an x-axis of B-V and a y-axis magnitude of V). Details on these kernels are given here. However, the kernel also must be normalized (weighted) according to the IMF and observational completeness functions.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Assume that the vector of initial stellar masses for the points in the interpolated isochrone are m_i and that they are sorted such that m_i  m_i+1. The IMF weight on point m_i can be approximated as the number fraction of stars born between m_i and m_i+1 divided by the mean mass per star born langle m rangle, such that the weight effectively represents the number of stars expected to be born with masses between m_i and m_i+1 per solar mass of star formation:","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"beginaligned\nw_itextIMF = frac int_0^m_i+1 fracdN(m)dm dm - int_0^m_i fracdN(m)dm dm int_0^infty m times fracdN(m)dm dm = frac int_m_i^m_i+1 fracdN(m)dm dm langle m rangle\nendaligned","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The numerator can either be calculated as the difference in the cumulative distribution function across the bin or approximated efficiently via the trapezoidal rule. The denominator is a function only of the IMF and need only be calculated once. Multiplying this weight by the probability of detection in the relevant bands gives the final weight.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"mv(\"../../../examples/templates/template_compare.svg\", \"figures/template_compare.svg\") # hide\nmv(\"../../../examples/templates/sigma_distribution.svg\", \"figures/sigma_distribution.svg\") # hide\nnothing # hide","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"A worked example comparing a sampled stellar population with a smooth Hess diagram template is available in examples/templates/smooth_template.jl. The smooth Hess diagram template is constructed with partial_cmd_smooth and the Monte Carlo population is sampled with generate_stars_mass, with observational effects modelled by model_cmd. The isochrone used comes from PARSEC and has an age of 12.6 Gyr and initial metallicity [M/H] of -2.8. The output figure is shown below. A distance modulus of 25 mag is used for this example, with photometric error and completeness functions roughly based on those we observe in the JWST/NIRCAM data of WLM (see Weisz et al. 2024).","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"(Image: Comparison of CMD-sampled population with smooth Hess diagram template.)","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"At left is a population of stars sampled from an SSP with the methods described in the section of the documentation on simulating CMDs. The points from the isochrone are colored orange. The next figure shows the binned Hess diagram derived from these data. The next figure shows our smooth Hess diagram template calculated for this SSP. The final figure at right shows the residual between the data and model in units of standard deviations. These are sometimes called Pearson residuals. Below we show the distribution of these residuals, which should be Gaussian with mean 0 and standard deviation 1 if the model were perfect. Note that, because all bins with 0 observed stars are excluded from the distribution and the observed Hess diagram contains Poisson error, the mean of our distribution will always be slightly higher than 0. We do, however, achieve a standard deviation of nearly 1, indicating that our model is robust. We show a Gaussian PDF with standard deviation 1 and mean equal to the observed mean of the residuals for comparison.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"(Image: Distribution of data - model residuals, in units of standard deviations.)","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The method used to create these smooth Hess diagram templates is partial_cmd_smooth.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"partial_cmd_smooth","category":"page"},{"location":"fitting/fitting_intro/#StarFormationHistories.partial_cmd_smooth","page":"Background and Template Construction","title":"StarFormationHistories.partial_cmd_smooth","text":"result::StatsBase.Histogram =\n    partial_cmd_smooth(m_ini::AbstractVector{<:Number},\n                       mags::AbstractVector{<:AbstractVector{<:Number}},\n                       mag_err_funcs,\n                       y_index,\n                       color_indices,\n                       imf,\n                       completeness_funcs=[one for i in mags];\n                       dmod::Number=0,\n                       normalize_value::Number=1,\n                       binary_model::AbstractBinaryModel=NoBinaries(),\n                       mean_mass=mean(imf),\n                       edges=nothing,\n                       xlim=nothing,\n                       ylim=nothing,\n                       nbins=nothing,\n                       xwidth=nothing,\n                       ywidth=nothing)\n\nMain function for generating template Hess diagrams from a simple stellar population of stars from an isochrone, including photometric error and completeness.\n\nArguments\n\nm_ini::AbstractVector{<:Number} is a vector containing the initial stellar masses of the stars from the isochrone.\nmags::AbstractVector{<:AbstractVector{<:Number}} is a vector of vectors. Each constituent vector with index i should have length(mags[i]) == length(m_ini), representing the magnitudes of the isochrone stars in each of the magnitudes considered. In most cases, mags should contain 2 (if y-axis mag is also involved in the x-axis color) or 3 vectors.\nmag_err_funcs must be an indexable object (e.g., a Vector or Tuple) that contains callables (e.g., a Function) to compute the 1σ photometric errors for the same filters provided in mags. Each callable must take a single argument (an apparent magnitude) and return a Number. The length mag_err_funcs must be equal to the length of mags.\ny_index gives a valid index (e.g., an Int or CartesianIndex) into mags for the filter you want to have on the y-axis of the Hess diagram. For example, if the mags argument contains the B and V band magnitudes as mags=[B, V] and you want V on the y-axis, you would set y_index as 2. \ncolor_indices is a length-2 indexable object giving the indices into mags that are to be used to compute the x-axis color. For example, if the mags argument contains the B and V band magnitudes as mags=[B, V], and you want B-V to be the x-axis color, then color_indices should be [1,2] or (1,2) or similar.\nimf is a callable that takes an initial stellar mass as its sole argument and returns the (properly normalized) probability density of your initial mass function model. All the models from InitialMassFunctions.jl are valid for imf.\ncompleteness_functions must be an indexable object (e.g., a Vector or Tuple) that contains callables (e.g., a Function) to compute the single-filter completeness fractions as a function of apparent magnitude. Each callable in this argument must correspond to the matching filter provided in mags.\n\nKeyword Arguments\n\ndmod::Number=0 is the distance modulus in magnitudes to apply to the input mags. Leave at 0 if you are providing apparent magnitudes in mags.\nnormalize_value::Number=1 is the total stellar mass of the population you wish to model.\nbinary_model::AbstractBinaryModel=NoBinaries() is the model to use for including binary systems. Currently only StarFormationHistories.NoBinaries and StarFormationHistories.RandomBinaryPairs are supported.\nmean_mass::Number is the expectation value of the initial mass for a random star drawn from your provided imf. This will be computed for you if your provided imf is a valid continuous, univariate Distributions.Distribution object.\nedges is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: (-1.0:0.1:1.5, 22:0.1:27.2). If edges is provided, it overrides the following keyword arguments that offer other ways to specify the extent of the Hess diagram.\nxlim is a length-2 indexable object (e.g., a Vector or Tuple) giving the lower and upper bounds on the x-axis corresponding to the provided colors array. Example: (-1.0, 1.5). This is only used if edges is not provided. \nylim is as xlim but for the y-axis corresponding to the provided mags array. Example (25.0, 20.0). This is only used if edges is not provided.\nnbins::NTuple{2, <:Integer} is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if edges is not provided.\nxwidth is the bin width along the x-axis for the colors array. This is only used if edges and nbins are not provided. Example: 0.1.\nywidth is as xwidth but for the y-axis corresponding to the provided mags array. Example: 0.1.\n\nReturns\n\nThis method returns the Hess diagram as a StatsBase.Histogram; you should refer to the StatsBase documentation for more information. In short, if the output of this method is result, then the Hess diagram represented as a Matrix is available as result.weights (this is what you would want for fit_templates and similar functions) and the edges of the histogram are available as result.edges.\n\n\n\n\n\n","category":"function"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"The user-provided functions returning magnitude errors (mag_err_funcs) and completeness values (completness_functions) given a star's intrinsic apparent magnitude are important for deriving good templates. These are typically derived from catalogs of artificial star tests. Some helper functions for constructing these are provided here.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"We note that in many cases it can also be helpful to add in a foreground/background template that models contamination of the Hess diagram from stars not in your population of interest – this is often done using observations of parallel fields though there are several other possible methods.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Photometric catalogs can be processed into Hess diagrams meeting our formatting requirements with the method bin_cmd.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"StarFormationHistories.bin_cmd","category":"page"},{"location":"fitting/fitting_intro/#StarFormationHistories.bin_cmd","page":"Background and Template Construction","title":"StarFormationHistories.bin_cmd","text":"result::StatsBase.Histogram =\n   bin_cmd(colors::AbstractVector{<:Number},\n           mags::AbstractVector{<:Number};\n           weights::AbstractVector{<:Number} = ones(promote_type(eltype(colors),\n                                                    eltype(mags)), size(colors)),\n           edges  = nothing,\n           xlim   = extrema(colors),\n           ylim   = extrema(mags),\n           nbins  = nothing,\n           xwidth = nothing,\n           ywidth = nothing)\n\nReturns a StatsBase.Histogram type containing the Hess diagram from the provided x-axis photometric colors and y-axis photometric magnitudes mags. These must all be vectors equal in length. You can either specify the bin edges directly via the edges keyword (e.g., edges = (range(-0.5, 1.6, length=100), range(17.0, 26.0, length=100))), or you can set the x- and y-limits via xlim and ylim and the number of bins as nbins, or you can omit nbins and instead pass the bin width in the x and y directions, xwidth and ywidth. See below for more info on the keyword arguments. To plot this with PyPlot.jl you should do PyPlot.imshow(permutedims(result.weights), origin=\"lower\", extent=(extrema(result.edges[1])..., extrema(result.edges[2]), kws...) where kws... are any other keyword arguments you wish to pass to PyPlot.imshow.\n\nKeyword Arguments\n\nweights::AbstractVector{<:Number} is a array of length equal to colors and mags that contains the probabilistic weights associated with each point. This is passed to StatsBase.fit as StatsBase.Weights(weights). The following keyword arguments are passed to StarFormationHistories.calculate_edges to determine the bin edges of the histogram.\nedges is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: (-1.0:0.1:1.5, 22:0.1:27.2). If edges is provided, weights is the only other keyword that will be read; edges supercedes the other construction methods. \nxlim is a length-2 indexable object (e.g., a vector or tuple) giving the lower and upper bounds on the x-axis corresponding to the provided colors array. Example: [-1.0, 1.5]. This is only used if edges is not provided. \nylim is like xlim but  for the y-axis corresponding to the provided mags array. Example [25.0, 20.0]. This is only used if edges is not provided.\nnbins::NTuple{2, <:Integer} is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if edges is not provided.\nxwidth is the bin width along the x-axis for the colors array. This is only used if edges and nbins are not provided. Example: 0.1. \nywidth is like xwidth but for the y-axis corresponding to the provided mags array. Example: 0.1.\n\n\n\n\n\n","category":"function"},{"location":"fitting/fitting_intro/#A-Note-on-Array-Formatting","page":"Background and Template Construction","title":"A Note on Array Formatting","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"It is expected that the user will typically have model templates stored as two-dimensional matrices as these are the obvious choice for representing a binned two-dimensional histogram. We fully support supplying the list of model templates as a list of matrices (e.g., a Vector{Matrix{<:Number}}) to the fitting functions discussed below. The important computational kernels composite! and ∇loglikelihood! have custom loops for these input types.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"However, additional optimizations are possible by flattening the data. By flattening each matrix in the list of model templates into a column vector and concatenating them such that the list of model templates becomes a single matrix, we can compute the complex model Hess diagram as a single matrix-vector product rather than using a custom loop. The same optimization can be made when computing the gradient of the loglikelihood (discussed more below). The majority of all computation for the fitting methods below is spent in these two functions, so optimizing their performance translates directly to improved fitting runtimes. With this flattened memory arrangement we can use the highly optimized LinearAlgbera.mul! method to do the in-place matrix-vector product. This will typically be translated into a call to a BLAS function like gemv!. As such, we can benefit from Julia's ability to switch BLAS implementations at runtime to use Intel's Math Kernel Library, Apple's Accelerate, and others.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"Most of the fitting methods below support both the natural and flattened data layouts. We provide the stack_models method to produce the optimized layout for the list of model templates.","category":"page"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"StarFormationHistories.stack_models","category":"page"},{"location":"fitting/fitting_intro/#StarFormationHistories.stack_models","page":"Background and Template Construction","title":"StarFormationHistories.stack_models","text":"stack_models(models::AbstractVector{<:AbstractMatrix{<:Number}}) = reduce(hcat,map(vec,models))\n\nTransforms a vector of matrices into a single matrix, with each matrix from models being transcribed into a single column in the output matrix. This data layout enables more efficient calculations in some of our internal functions like composite! and ∇loglikelihood!.\n\nExamples\n\njulia> stack_models([rand(5,5) for i in 1:10])\n25×10 Matrix{Float64}:\n...\n\n\n\n\n\n","category":"function"},{"location":"fitting/fitting_intro/#A-Note-on-Threading","page":"Background and Template Construction","title":"A Note on Threading","text":"","category":"section"},{"location":"fitting/fitting_intro/","page":"Background and Template Construction","title":"Background and Template Construction","text":"While generally the methods using BLAS routines offer significant performance improvements, there is a caveat when multithreading from within Julia. By default Julia will allow BLAS to use multiple threads even if Julia itself is started with a single thread (i.e., by running julia -t 1). BLAS threads do not compose with Julia threads. That is, if you start Julia with N>1 threads (julia -t N) and write a threaded workload where each Julia thread is doing BLAS operations concurrently, you can easily oversubscribe the CPU. Specific recommendations vary depending on BLAS vendor (see this page and the linked discourse threads), but generally this package is in the regime of doing many small calculations that do not individually benefit much from BLAS threading (e.g., performance for OpenBLAS with 8 threads is only ~2x the 1 thread performance). As such it is often sufficient to set BLAS to use a single thread (via LinearAlgbera.BLAS.set_num_threads(1) or environment variables; see above link).","category":"page"},{"location":"doc_index/#index","page":"Index","title":"Index","text":"","category":"section"},{"location":"doc_index/","page":"Index","title":"Index","text":"Modules = [StarFormationHistories]","category":"page"},{"location":"fitting/fixed_amr/#Fixed-Age-Metallicity-Relations","page":"Fixed Age-Metallicity Relations","title":"Fixed Age-Metallicity Relations","text":"","category":"section"},{"location":"fitting/fixed_amr/","page":"Fixed Age-Metallicity Relations","title":"Fixed Age-Metallicity Relations","text":"It is often the case that one may want to fit for star formation rates under a fixed age-metallicity relation or other metallicity evolution model with no degrees of freedom. Such functionality is provided by fixed_amr, which takes as input the relative weights (relweights in the function call, equivalently the r_jk in the above derivation) on each template due to a predetermined metallicity model and fits only the per-age-bin coefficients (R_j in the above derivation). ","category":"page"},{"location":"fitting/fixed_amr/","page":"Fixed Age-Metallicity Relations","title":"Fixed Age-Metallicity Relations","text":"StarFormationHistories.fixed_amr","category":"page"},{"location":"fitting/fixed_amr/#StarFormationHistories.fixed_amr","page":"Fixed Age-Metallicity Relations","title":"StarFormationHistories.fixed_amr","text":"fixed_amr(models::AbstractVector{T},\n          data::AbstractMatrix{<:Number},\n          logAge::AbstractVector{<:Number},\n          metallicities::AbstractVector{<:Number},\n          relweights::AbstractVector{<:Number};\n          relweightsmin::Number=0, \n          x0=construct_x0_mdf(logAge, convert(S,13.7)),\n          kws...) where {S <: Number, T <: AbstractMatrix{S}}\nfixed_amr(models::AbstractMatrix{S},\n          data::AbstractVector{<:Number},\n          logAge::AbstractVector{<:Number},\n          metallicities::AbstractVector{<:Number},\n          relweights::AbstractVector{<:Number};\n          relweightsmin::Number=0,\n          x0=construct_x0_mdf(logAge, convert(S,13.7)),\n          kws...) where S <: Number\n\nMethod that fits a linear combination of the provided Hess diagrams models to the observed Hess diagram data, under an externally-imposed age-metallicity relation (AMR) and/or metallicity distribution function (MDF). As such, a number of coefficients equal to length(unique(logAge)) are returned; that is, only one coefficient is derived per unique entry in logAge.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. This is most commonly a logarithmic abundance like [M/H] or [Fe/H], but you could use a linear abundance like the metal mass fraction Z if you wanted to. There are some notes on the Wikipedia that might be useful.\nrelweights::AbstractVector{<:Number} is a vector of length equal to that of models which contains the relative weights to apply to each model Hess diagram resulting from an externally-imposed age-metallicity relation and/or metallicity distribution function. Additional details on how to create these weights is provided in the notes below and in the online documentation.\n\nKeyword Arguments\n\nrelweightsmin truncates the input list of models based on the provided relweights, providing a speedup at the cost of precision by removing models that contribute least to the overall composite model. By default, no truncation of the input is performed and all provided models are used in the fit. We recommend this only be increased when fitting performance begins to impact workflow (e.g., when running massive Monte Carlo experiments). See StarFormationHistories.truncate_relweights for implementation details. \nx0 is the vector of initial guesses for the stellar mass coefficients per unique entry in logAge. You should basically always be calculating and passing this keyword argument. We provide StarFormationHistories.construct_x0_mdf to prepare x0 assuming constant star formation rate, which is typically a good initial guess. \n\nOther kws... are passed to Optim.options to set things like convergence criteria for the optimization.\n\nNotes\n\nAll metallicity-related weighting of the models is assumed to be captured in the provided relweights vector, which has the same length as the logAge, metallicities, and models vectors. Each entry in relweights is assumed to be a relative weight for the corresponding model. For example, for the model Hess diagram models[i], with log10(age [yr]) = logAge[i] and metallicity metallicities[i], the relative weight due to the model's age and metallicity w(logAge[i], metallicities[i]) is assumed to be relweights[i]. The sum of all relweights for each unique entry in logAge should be 1; i.e., the following condition should be met: all( sum(relweights[logAge .== la]) ≈ 1 for la in unique(logAge)). If this is not the case, this function will issue a warning and attempt to renormalize relweights by mutating the vector in place. More information on preparation of the relweights for input to this method is provided in our online documentation. \nThis function is designed to work best with a \"grid\" of stellar models, defined by the outer product of N unique entries in logAge and M unique entries in metallicities. See the examples for more information on usage.\n\n\n\n\n\n","category":"function"},{"location":"fitting/linear_amr/#linear_amr_section","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"","category":"section"},{"location":"fitting/linear_amr/#metal_evo_intro","page":"Linear Age-Metallicity Relation","title":"Why Should Metallicity Evolutions Be Constrained?","text":"","category":"section"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"While the above methods work well for optimizing the per-template r_j as a means for fitting SFHs, these methods can produce metallicity evolutions that could be considered unphysical, with large changes in the mean metallicity over small changes in time. An example of this type of behavior is shown in the SFH fit below.","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"(Image: Example of a SFH fit with variations in the metallicity evolution.)","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"While some metallicity variation in the star-forming gas is to be expected, these variations in the SFH fit can end up being quite large depending on the data and isochrone grid adopted. A solution is to construct a more physically-motivated model.","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"We can do this using a hierarchical model with a parameterized metallicity distribution function (MDF) where the the r_j are not the parameters directly optimized. Rather, we can optimize one stellar mass (or star formation rate) parameter per age bin, and then a number of MDF parameters that determine how that stellar mass is split between models with different metallicities at fixed age. An example for one such MDF model is a linear mean metallicity relation langle textMtextH rangle (t) = alpha  left( T_textmax - t right) + beta with a Gaussian distribution in metallicity at fixed age. T_textmax here is the earliest lookback time under consideration such that langle textMtextH rangle (T_textmax) = beta. If the per-age-bin stellar mass coefficients are R_j, the age of the stellar population j is t_j, and the metallicity of population k is textMtextH_k, then we can write the per-model r_jk (where we are now using separate indices for age and metallicity) as","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nmu_j = alpha  left( T_textmax - t_j right) + beta \nr_jk = R_j  frac textexp left( - left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - left( frac textMtextH_k - mu_jsigma right)^2 right)\nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"where the numerator is the MDF at fixed age evaluated at metallicity textMtextH_k and the denominator is a normalizing coefficient that ensures sum_k r_jk = R_j. In this notation, bin i of the complex model Hess diagram (equation 1 of Dolphin 2002) is","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"m_i = sum_jk  r_jk  c_ijk","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Below we show a fit using this hierarchical model to the same data as above. ","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"(Image: Example of a SFH fit with a linear metallicity evolution.)","category":"page"},{"location":"fitting/linear_amr/#Fitting-Functions","page":"Linear Age-Metallicity Relation","title":"Fitting Functions","text":"","category":"section"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"We provide the method StarFormationHistories.fit_templates_mdf to fit this model to an observed Hess diagram.","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"StarFormationHistories.fit_templates_mdf\nStarFormationHistories.LogTransformMDFσResult\nStarFormationHistories.LogTransformMDFResult","category":"page"},{"location":"fitting/linear_amr/#StarFormationHistories.fit_templates_mdf","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.fit_templates_mdf","text":"fit_templates_mdf(models::AbstractVector{<:AbstractMatrix{S}},\n                  data::AbstractMatrix{<:Number},\n                  logAge::AbstractVector{<:Number},\n                  metallicities::AbstractVector{<:Number},\n                  T_max::Number\n                  [, σ::Number];\n                  x0 = vcat(construct_x0_mdf(logAge, convert(S,13.7)),\n                            [0.05, -2.0, 0.2]),\n                  kws...) where {S <: Number}\nfit_templates_mdf(models::AbstractMatrix{S},\n                  data::AbstractVector{<:Number},\n                  logAge::AbstractVector{<:Number},\n                  metallicities::AbstractVector{<:Number},\n                  T_max::Number\n                  [, σ::Number];\n                  x0 = vcat(construct_x0_mdf(logAge, convert(S,13.7)),\n                            [0.05, -2.0, 0.2]),\n                  kws...) where {S <: Number}\n\nMethod that fits a linear combination of the provided Hess diagrams models to the observed Hess diagram data, constrained to have a linear age-metallicity relation with the mean metallicity of element i of unique(logAge) being μ[i] = α * (T_max - exp10(unique(logAge)[i]) / 1e9) + β. α is therefore a slope in the units of metallicities per Gyr, and β is the mean metallicity value of stars being born at a lookback time of T_max, which has units of Gyr. Individual weights for each isochrone template are then determined via Gaussian weighting with the above mean and the standard deviation σ, which can either be fixed or fit.\n\nThis function is designed to work best with a \"grid\" of stellar models, defined by the outer product of N unique entries in logAge and M unique entries in metallicities. See the examples for more information on usage.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels are the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram. \ndata is the Hess diagram for the observed data. \nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. This is most commonly a logarithmic abundance like [M/H] or [Fe/H], but you could use a linear abundance like the metal mass fraction Z if you wanted to. There are some notes on the Wikipedia that might be useful.\nT_max::Number is the time at which the age-metallicity relation has a value of \beta in Gyr. For example, if the oldest stellar populations in your isochrone grid are 12 Gyr old, you could set T_max = 12.0. \n\nOptional Arguments\n\nIf provided, σ::Number is the fixed width of the Gaussian the defines the metallicity distribution function (MDF) at fixed logAge. If this argument is omitted, σ will be a free parameter in the fit. \n\nKeyword Arguments\n\nx0 is the vector of initial guesses for the stellar mass coefficients per unique entry in logAge, plus the variables that define the metallicity evolution model. You should basically always be calculating and passing this keyword argument. We provide StarFormationHistories.construct_x0_mdf to prepare the first part of x0 assuming constant star formation rate, which is typically a good initial guess. You then have to concatenate that result with an initial guess for the metallicity evolution parameters. For example, x0=vcat(construct_x0_mdf(logAge, 13.7; normalize_value=1e4), [0.05,-2.0,0.2]), where logAge is a valid argument for this function (see above), and the initial guesses on the parameters are [α, β, σ] = [0.05, -2.0, 0.2]. If the provided metallicities are, for example, [M/H] values, then this mean metallicity evolution is μ(t) [dex] = 0.05 [dex/Gyr] * (T_max - t) [Gyr] - 2.0 [dex], and at fixed time, the metallicity distribution function is Gaussian with mean μ(t) and standard deviation σ. If you provide σ as an optional argument, then you should not include an entry for it in x0.\nOther kws... are passed to Optim.options to set things like convergence criteria for the optimization.\n\nReturns\n\nThis function returns an object (say, result) of similar structure to the object returned by fit_templates. Specifically, this method will return a NamedTuple with entries result.mle and result.map for the maximum likelihood and maximum a posteriori estimates, respectively. If you provide a fixed σ, those objects will be instances of StarFormationHistories.LogTransformMDFσResult. If you allow σ to be freely fit, those objects will be instances of StarFormationHistories.LogTransformMDFResult. Both of these types support sampling via, e.g., rand(result.map, 10). \n\nNotes\n\nα and σ are optimized under a logarithmic transformation, so they are constrained to be positive. β is not and may be negative. This method also uses the BFGS method from Optim.jl internally just like fit_templates; please see the notes section of that method. \n\n\n\n\n\n","category":"function"},{"location":"fitting/linear_amr/#StarFormationHistories.LogTransformMDFσResult","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.LogTransformMDFσResult","text":"LogTransformMDFσResult(μ::AbstractVector{<:Number},\n                       σ::AbstractVector{<:Number},\n                       invH::AbstractMatrix{<:Number},\n                       result)\n\nType for containing the maximum likelihood estimate (MLE) and maximum a posteriori (MAP) results from fit_templates_mdf for fixed σ. The fitted coefficients are available in the μ field. Estimates of the standard errors are available in the σ field. These have both been transformed from the native logarithmic fitting space into natural units (i.e., stellar mass or star formation rate). The linear age-metallicity relation parameters α (slope [dex/Gyr]) and β (intercept at T_max [dex]) are available in the second-to-last and last elements of μ and σ, respectively. \n\ninvH contains the estimated inverse Hessian of the likelihood / posterior at the maximum point in the logarithmic fitting units. result is the full result object returned by the optimization routine.\n\nThis type is implemented as a subtype of Distributions.Sampleable{Multivariate, Continuous} to enable sampling from an estimate of the likelihood / posterior distribution. We approximate the distribution as a multivariate Gaussian in the native (logarithmically transformed) fitting variables with covariance matrix invH and means log.(μ). We find this approximation is good for the MAP result but less robust for the MLE. You can obtain N::Integer samples from the distribution by rand(R, N) where R is an instance of this type; this will return a size (length(μ)+2) x N matrix, or fail if invH is not positive definite.\n\nExamples\n\njulia> result = fit_templates_mdf(models, data, model_logAge, model_MH, 0.3);\n\njulia> typeof(result.map)\nStarFormationHistories.LogTransformMDFσResult{...}\n\njulia> size(rand(result.map, 3)) == (length(models)+2,3)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/linear_amr/#StarFormationHistories.LogTransformMDFResult","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.LogTransformMDFResult","text":"LogTransformMDFResult(μ::AbstractVector{<:Number},\n                      σ::AbstractVector{<:Number},\n                      invH::AbstractMatrix{<:Number},\n                      result)\n\nType for containing the maximum likelihood estimate (MLE) and maximum a posteriori (MAP) results from fit_templates_mdf when freely fitting σ. The fitted coefficients are available in the μ field. Estimates of the standard errors are available in the σ field. These have both been transformed from the native logarithmic fitting space into natural units (i.e., stellar mass or star formation rate). The linear age-metallicity relation parameters α (slope [dex/Gyr]) and β (intercept at T_max [dex]) are available in the third-to-last and second-to-last elements of μ and σ, respectively. The static Gaussian width of the MDF at fixed age is provided in the last element of μ and σ. \n\ninvH contains the estimated inverse Hessian of the likelihood / posterior at the maximum point in the logarithmic fitting units. result is the full result object returned by the optimization routine.\n\nThis type is implemented as a subtype of Distributions.Sampleable{Multivariate, Continuous} to enable sampling from an estimate of the likelihood / posterior distribution. We approximate the distribution as a multivariate Gaussian in the native (logarithmically transformed) fitting variables with covariance matrix invH and means log.(μ). We find this approximation is good for the MAP result but less robust for the MLE. You can obtain N::Integer samples from the distribution by rand(R, N) where R is an instance of this type; this will return a size (length(μ)+3) x N matrix, or fail if invH is not positive definite.\n\nExamples\n\njulia> result = fit_templates_mdf(models, data, model_logAge, model_MH);\n\njulia> typeof(result.map)\nStarFormationHistories.LogTransformMDFσResult{...}\n\njulia> size(rand(result.map, 3)) == (length(models)+3,3)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"The method StarFormationHistories.construct_x0_mdf can be used to construct the stellar mass components R_j of the initial guess vector x0","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"StarFormationHistories.construct_x0_mdf","category":"page"},{"location":"fitting/linear_amr/#StarFormationHistories.construct_x0_mdf","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.construct_x0_mdf","text":"x0::Vector = construct_x0_mdf(logAge::AbstractVector{T},\n                              T_max::Number;\n                              normalize_value::Number = one(T)) where T <: Number\n\nGenerates a vector of initial stellar mass normalizations for input to StarFormationHistories.fit_templates_mdf or StarFormationHistories.hmc_sample_mdf with a total stellar mass of normalize_value such that the implied star formation rate is constant across the provided logAge vector that contains the log10(Age [yr]) of each isochrone that you are going to input as models. For the purposes of computing the constant star formation rate, the provided logAge are treated as left-bin edges, with the final right-bin edge being T_max, which has units of Gyr. For example, you might have logAge=[6.6, 6.7, 6.8] in which case a final logAge of 6.9 would give equal bin widths. In this case you would set T_max = exp10(6.9) / 1e9 ≈ 0.0079 so that the width of the final bin for the star formation rate calculation has the same log10(Age [yr]) step as the other bins.\n\nThe difference between this function and StarFormationHistories.construct_x0 is that this function generates an x0 vector that is of length length(unique(logage)) (that is, a single normalization factor for each unique entry in logAge) while StarFormationHistories.construct_x0 returns an x0 vector that is of length length(logAge); that is, a normalization factor for every entry in logAge. The order of the coefficients is such that the coefficient x[i] corresponds to the entry unique(logAge)[i]. \n\nNotes\n\nExamples\n\njulia> construct_x0_mdf([9.0,8.0,7.0], 10.0; normalize_value=5.0)\n3-element Vector{Float64}:\n 4.504504504504504\n 0.4504504504504504\n 0.04504504504504504\n\njulia> construct_x0_mdf(repeat([9.0,8.0,7.0,8.0];inner=3), 10.0; normalize_value=5.0)\n3-element Vector{Float64}:\n 4.504504504504504\n 0.4504504504504504\n 0.04504504504504504\n\njulia> construct_x0_mdf(repeat([9.0,8.0,7.0,8.0],3), 10.0; normalize_value=5.0) ≈ construct_x0([9.0,8.0,7.0], 10.0; normalize_value=5.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"and StarFormationHistories.calculate_coeffs_mdf can be used to calculate per-template stellar mass coefficients (the r_jk above) given the results of a fit (which will be the R_j in the equations above)","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"StarFormationHistories.calculate_coeffs_mdf","category":"page"},{"location":"fitting/linear_amr/#StarFormationHistories.calculate_coeffs_mdf","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.calculate_coeffs_mdf","text":"calculate_coeffs_mdf(variables::AbstractVector{<:Number},\n                     logAge::AbstractVector{<:Number},\n                     metallicities::AbstractVector{<:Number},\n                     T_max::Number\n                     α::Number,\n                     β::Number,\n                     σ::Number,)\ncalculate_coeffs_mdf(variables::AbstractVector{<:Number},\n                     logAge::AbstractVector{<:Number},\n                     metallicities::AbstractVector{<:Number},\n                     T_max::Number)\n\nCalculates per-model stellar mass coefficients coeffs from the fitting parameters of StarFormationHistories.fit_templates_mdf and StarFormationHistories.hmc_sample_mdf. The variables returned by these functions is of length length(unique(logAge))+3. The first length(logAge) entries are stellar mass coefficients, one per unique entry in logAge. The final three elements are α, β, and σ defining a metallicity evolution such that the mean for element i of unique(logAge) is μ[i] = α * (T_max - exp10(unique(logAge)[i]) / 1e9) + β. The individual weights per each isochrone are then determined via Gaussian weighting with the above mean and the provided σ. The second call signature can be used on samples that include α, β, and σ.\n\nExamples\n\njulia> calculate_coeffs_mdf([1,1], [7,7,8,8], [-2,-1,-2,-1], 12, 0.05, -2.0, 0.2) ≈ [ 0.07673913563377144, 0.9232608643662287, 0.08509904500701986, 0.9149009549929802 ]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"fitting/linear_amr/#Sampling-Methods","page":"Linear Age-Metallicity Relation","title":"Sampling Methods","text":"","category":"section"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"We additionally offer a sampling method for this linear age-metallicity relation using HMC:","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"StarFormationHistories.hmc_sample_mdf","category":"page"},{"location":"fitting/linear_amr/#StarFormationHistories.hmc_sample_mdf","page":"Linear Age-Metallicity Relation","title":"StarFormationHistories.hmc_sample_mdf","text":"hmc_sample_mdf(models::AbstractVector{T},\n               data::AbstractMatrix{<:Number},\n               logAge::AbstractVector{<:Number},\n               metallicities::AbstractVector{<:Number},\n               T_max::Number,\n               nsteps::Integer;\n               composite=Matrix{S}(undef,size(data)),\n               rng::Random.AbstractRNG=Random.default_rng(),\n               kws...) where {S <: Number, T <: AbstractMatrix{S}}\n\nMethod to sample the posterior of the star formation history coefficients constrained to have a linear age-metallicity relation with the mean metallicity of element i of unique(logAge) being μ[i] = α * (T_max - exp10(unique(logAge)[i]) / 1e9) + β. α is therefore a slope in the units of metallicities per Gyr, and β is the mean metallicity value of stars born at lookback time T_max which has units of Gyr. Individual weights for each isochrone template are then determined via Gaussian weighting with the above mean and the standard deviation σ, which can either be fixed or fit. This method is essentially an analog of StarFormationHistories.fit_templates_mdf that samples the posterior rather than using optimization methods to find the maximum likelihood estimate. This method uses the No-U-Turn sampler as implemented in DynamicHMC.jl, which is a form of dynamic Hamiltonian Monte Carlo.\n\nThis function is designed to work best with a \"grid\" of stellar models, defined by the outer product of N unique entries in logAge and M unique entries in metallicities. See the examples for more information on usage.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. This is most commonly a logarithmic abundance like [M/H] or [Fe/H], but you could use a linear abundance like the metal mass fraction Z if you wanted to. There are some notes on the Wikipedia that might be useful.\nT_max::Number is the time at which the age-metallicity relation has a value of \beta in Gyr. For example, if the oldest stellar populations in your isochrone grid are 12 Gyr old, you could set T_max = 12.0. \nnsteps::Integer is the number of samples to draw per chain.\n\nOptional Arguments (NOT YET IMPLEMENTED)\n\nnchains::Integer: If this argument is not provided, this method will return a single chain. If this argument is provided, it will sample nchains chains using all available threads and will return a vector of the individual chains. If nchains is set, composite must be a vector of matrices containing a working matrix for each chain. \n\nKeyword Arguments\n\ncomposite is the working matrix (or vector of matrices, if the argument nchains is provided) that will be used to store the composite Hess diagram model during computation; must be of the same size as the templates contained in models and the observed Hess diagram data.\nrng::Random.AbstractRNG is the random number generator that will be passed to DynamicHMC.jl. If nchains is provided this method will attempt to sample in parallel, requiring a thread-safe rng such as that provided by Random.default_rng(). \n\nAll other keyword arguments kws... will be passed to DynamicHMC.mcmc_with_warmup or DynamicHMC.mcmc_keep_warmup depending on whether nchains is provided.\n\nReturns (NEEDS UPDATED)\n\nIf nchains is not provided, returns a NamedTuple as summarized in DynamicHMC.jl's documentation. In short, the matrix of samples can be extracted and transformed as exp.( result.posterior_matrix ). Statistics about the chain can be obtained with DynamicHMC.Diagnostics.summarize_tree_statistics(result.tree_statistics); you want to see a fairly high acceptance rate (>0.5) and the majority of samples having termination criteria being \"turning.\" See DynamicHMC.jl's documentation for more information.\nIf nchains is provided, returns a vector of length nchains of the same NamedTuples described above. The samples from each chain in the returned vector can be stacked to a single (nsamples, nchains, length(models)) matrix with DynamicHMC.stack_posterior_matrices(result).\n\n\n\n\n\n","category":"function"},{"location":"fitting/linear_amr/#linear_amr_implementation","page":"Linear Age-Metallicity Relation","title":"Implementation","text":"","category":"section"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"While one could optimize the above model without an analytic gradient, such gradient-free methods are typically slower and less robust. One could also calculate the gradient numerically using finite differences or auto-differentiation, but these are still slower than analytic calculations. We will show that the gradient of this hierarchical model is analytic, allowing us to design an efficient optimization scheme.","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Equation 21 in Dolphin 2001 gives the gradient of our objective function with respect to the underlying coefficients","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nF equiv - textln  mathscrL = sum_i m_i - n_i times left( 1 - textln  left( fracn_im_i right) right) \nfracpartial  Fpartial  r_jk = sum_i c_ijk left( 1 - fracn_im_i right)\nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"where c_ijk is the value of template jk in bin i and n_i is bin i of the observed Hess diagram. These partial derivatives are easy to obtain, but we need partials with respect to the per-age-bin fitting parameters R_j. Given the above relation between r_jk and R_j, we can calculate these derivatives as","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  R_j = sum_k  fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  R_j \nfracpartial  r_jkpartial  R_j = frac textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) = fracr_jkR_j\nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Then we need only the partial derivatives of the objective function F with respect to the MDF parameters, which in this case are alpha beta sigma. For convenience we will rewrite","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"r_jk = R_j  frac textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right)sum_k textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) = R_j  fracA_jksum_k A_jk","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"as many different types of models can be expressed via this simplified notation by substituting the A_jk with different distributions. This allows us to write ","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  beta = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta \nfracpartial  r_jkpartial  beta = R_j left( frac1sum_k  A_jk  fracpartial  A_jkpartial  beta - fracA_jkleft( sum_k  A_jk right)^2  fracpartial  sum_k  A_jkpartial  beta right)  \n= fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  beta - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  beta right) \nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Given our specific definition of A_jk being a Gaussian distribution, we have","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nmu_j = alpha  left( T_textmax - t_j right) + beta \nfracpartial  A_jkpartial  beta = fracpartialpartial  beta  left textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) right \n= fracA_jksigma^2 left( textMtextH_k - mu_j right)\nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"We can now substitute this result into the above expressions to write","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  beta = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta \n= sum_jk fracpartial  Fpartial  r_jk  fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  beta - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  beta right) \n= sum_jk fracpartial  Fpartial  r_jk  fracR_jsigma^2  sum_k  A_jk left( A_jk left( textMtextH_k - mu_j right) - fracA_jksum_k  A_jk sum_k A_jk left( textMtextH_k - mu_j right) right)\nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"It can be shown that the partial derivative of F with respect to alpha is simply","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"fracpartial  Fpartial  alpha = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  alpha = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  beta times left( T_textmax - t_j right) ","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"The partial derivative with respect to sigma is slightly more complicated, but we can start identically to how we started above when deriving fracpartial  Fpartial  beta with","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"beginaligned\nfracpartial  Fpartial  sigma = sum_jk fracpartial  Fpartial  r_jk  fracpartial  r_jkpartial  sigma \nfracpartial  r_jkpartial  sigma = R_j left( frac1sum_k  A_jk  fracpartial  A_jkpartial  sigma - fracA_jkleft( sum_k  A_jk right)^2  fracpartial  sum_k  A_jkpartial  sigma right)  \n= fracR_jsum_k  A_jk left( fracpartial  A_jkpartial  sigma - fracA_jksum_k  A_jk sum_k fracpartial  A_jkpartial  sigma right) \nendaligned","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"Then all we need is","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"fracpartial  A_jkpartial  sigma = fracA_jk  left( textMtextH_k - mu_j right)^2sigma^3","category":"page"},{"location":"fitting/linear_amr/","page":"Linear Age-Metallicity Relation","title":"Linear Age-Metallicity Relation","text":"which we can substitute into the above expressions to find fracpartial  Fpartial  sigma.","category":"page"},{"location":"simulate/#simulate","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"Modelling observations of resolved stellar populations (e.g., color-magnitude or Hess diagrams) with user-defined star formation histories can be useful for comparison to actual observations, but also enables a number of other scientific activities (e.g., making predictions to motivate observational proposals). To support these uses we offer methods for sampling stellar populations from isochrones using user-defined star formation histories, initial mass functions, and stellar binary models. These methods require data from user-provided isochrones (this package does not provide any), an initial mass function model (such as those provided in InitialMassFunctions.jl), and a model specifying how (or if) to sample binary or multi-star systems. ","category":"page"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"The simplest methods only sample stars from a single stellar population. We provide a method that samples up to a provided stellar mass, generate_stars_mass (e.g., 10^7  textM_odot) and a method that samples up to a provided absolute magnitude generate_stars_mag (e.g., M_V=-10). These are documented under the first subsection below. These methods are single-threaded.","category":"page"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"We also offer methods for sampling populations with complex star formation histories; these are implicitly multi-threaded across the separate populations if you start Julia with multiple threads (e.g., with julia -t 4 or similar). We provide generate_stars_mass_composite for sampling such populations up to a provided stellar mass and generate_stars_mag_composite for sampling such populations up to a provided absolute magnitude. These are documented under the second subsection below.","category":"page"},{"location":"simulate/#Simple-Stellar-Populations","page":"Simulating Color-Magnitude Diagrams","title":"Simple Stellar Populations","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"generate_stars_mass\ngenerate_stars_mag","category":"page"},{"location":"simulate/#StarFormationHistories.generate_stars_mass","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mass","text":"generate_stars_mass(mini_vec::AbstractVector{<:Number},\n                    mags, mag_names::AbstractVector{String},\n                    limit::Number,\n                    imf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous};\n                    dist_mod::Number=0,\n                    rng::Random.AbstractRNG=Random.default_rng(),\n                    mag_lim::Number = Inf,\n                    mag_lim_name::String = \"V\",\n                    binary_model::StarFormationHistories.AbstractBinaryModel =\n                        StarFormationHistories.RandomBinaryPairs(0.3))\n\nGenerates a random sample of stars from an isochrone defined by the provided initial stellar masses mini_vec, absolute magnitudes mags, and filter names mag_names with total population birth stellar mass limit (e.g., 1e5 solar masses). Initial stellar masses are sampled from the provided imf. \n\nArguments\n\nmini_vec::AbstractVector{<:Number} contains the initial masses (in solar masses) for the stars in the isochrone; must be mutable as we call Interpolations.deduplicate_knots!(mini_vec).\nmags contains the absolute magnitudes from the isochrone in the desired filters corresponding to the same stars as provided in mini_vec. mags is internally interpreted and converted into a standard format by StarFormationHistories.ingest_mags. Valid inputs are:\nmags::AbstractVector{AbstractVector{<:Number}}, in which case the length of the outer vector length(mags) can either be equal to length(mini_vec), in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to length(mini_vec); this is the more common use-case.\nmags::AbstractMatrix{<:Number}, in which case mags must be 2-dimensional. Valid shapes are size(mags) == (length(mini_vec), nfilters) or size(mags) == (nfilters, length(mini_vec)), with nfilters being the number of filters you are providing.\nmag_names::AbstractVector{String} contains strings describing the filters you are providing in mags; an example might be [\"B\",\"V\"]. These are used when mag_lim is finite to determine what filter you want to use to limit the faintest stars you want returned.\nlimit::Number gives the total birth stellar mass of the population you want to sample. See the \"Notes\" section on population masses for more information.\nimf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous} is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined rand(rng::Random.AbstractRNG, imf) method to use for sampling masses. All instances of Distributions.ContinuousUnivariateDistribution are also valid. Implementations of commonly used IMFs are available in InitialMassFunctions.jl.\n\nKeyword Arguments\n\ndist_mod::Number=0 is the distance modulus (see StarFormationHistories.distance_modulus) you wish to have added to the returned magnitudes to simulate a population at a particular distance.\nrng::Random.AbstractRNG=Random.default_rng() is the rng instance that will be used to sample the stellar initial masses from imf.\nmag_lim::Number=Inf gives the faintest apparent magnitude for stars you want to be returned in the output. Stars fainter than this magnitude will still be sampled and contribute properly to the total mass of the population, but they will not be returned.\nmag_lim_name::String=\"V\" gives the filter name (as contained in mag_names) to use when considering if a star is fainter than mag_lim. This is unused if mag_lim is infinite.\nbinary_model::StarFormationHistories.AbstractBinaryModel=StarFormationHistories.RandomBinaryPairs(0.3) is an instance of a model for treating binaries; currently provided options are NoBinaries, RandomBinaryPairs, and BinaryMassRatio.\n\nReturns\n\n(sampled_masses, sampled_mags) defined as\n\nsampled_masses::Vector{SVector{N,eltype(imf)}} is a vector containing the initial stellar masses of the stars sampled by sample_system; see that method's documentation for details on format. In short, each StaticArrays.SVector represents one stellar system and each entry in each StaticArrays.SVector is one star in that system. Entries will be 0 when companions could have been sampled but were not (i.e., when using a binary_model that supports multi-star systems). \nsampled_mags::Vector{SVector{N,<:Number}} is a vector containing StaticArrays.SVectors with the multi-band magnitudes of the sampled stars. To get the magnitude of star i in band j, you index as sampled_mags[i][j]. This can be reinterpreted as a 2-dimensional Matrix with reduce(hcat,sampled_mags). \n\nNotes\n\nPopulation Masses\n\nGiven a particular isochrone with an initial mass vector mini_vec, it will never cover the full range of stellar birth masses because stars that die before present-day are not included in the isochrone. However, these stars were born, and so contribute to the total birth mass of the system. There are two ways to properly account for this lost mass when sampling:\n\nSet the upper limit for masses that can be sampled from the imf distribution to a physical value for the maximum birth mass of stars (e.g., 100 solar masses). In this case, these stars will be sampled from imf, and will contribute their masses to the system, but they will not be returned if their birth mass is greater than maximum(mini_vec). This is typically easiest for the user and only results in ∼15% loss of efficiency for 10 Gyr isochrones. This approach is preferred when sampling with binaries.\nSet the upper limit for masses that can be sampled from the imf distribution to maximum(mini_vec) and adjust limit to respect the amount of initial stellar mass lost by not sampling higher mass stars. This can be calculated as new_limit = limit * ( QuadGK.quadgk(x->x*pdf(imf,x), minimum(mini_vec), maximum(mini_vec))[1] / QuadGK.quadgk(x->x*pdf(imf,x), minimum(imf), maximum(imf))[1] ), with the multiplicative factor being the fraction of the population stellar mass contained in stars with initial masses between minimum(mini_vec) and maximum(mini_vec); this factor is the ratio\n\nfracint_a^b  m times fracdN(m)dm  dmint_0^  m times fracdN(m)dm  dm\n\nNote that, if binaries are included, this approach only forms binary pairs between stars whose masses are less than maximum(mini_vec). This is probably not desired, so we recommend the previous approach when including binaries.\n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.generate_stars_mag","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mag","text":"(sampled_masses, sampled_mags) =  generate_stars_mag(mini_vec::AbstractVector{<:Number}, mags, mag_names::AbstractVector{String}, absmag::Real, absmag_name::String, imf::Distributions.Sampleable{Distributions.Univariate,Distributions.Continuous}; dist_mod::Number=0, rng::AbstractRNG=default_rng(), mag_lim::Number=Inf, mag_lim_name::String=\"V\", binary_model::StarFormationHistories.AbstractBinaryModel=RandomBinaryPairs(0.3))\n\nGenerates a mock stellar population from an isochrone defined by the provided initial stellar masses mini_vec, absolute magnitudes mags, and filter names mag_names. The population is sampled to a total absolute magnitude absmag::Real (e.g., -7 or -12) in the filter absmag_name::String (e.g., \"V\" or \"F606W\") which is contained in the provided mag_names::AbstractVector{String}. Other arguments are shared with generate_stars_mass, which contains the main documentation.\n\nNotes\n\nPopulation Magnitudes\n\nUnlike when sampling a population to a fixed initial birth mass, as is implemented in generate_stars_mass, when generating a population up to a fixed absolute magnitude, only stars that survive to present-day contribute to the flux of the population. If you choose to limit the apparent magnitude of stars returned by passing the mag_lim and mag_lim_name keyword arguments, stars fainter than your chosen limit will still be sampled and will still contribute their luminosity to the total population, but they will not be contained in the returned output. \n\n\n\n\n\n","category":"function"},{"location":"simulate/#Complex-Stellar-Populations","page":"Simulating Color-Magnitude Diagrams","title":"Complex Stellar Populations","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"generate_stars_mass_composite\ngenerate_stars_mag_composite","category":"page"},{"location":"simulate/#StarFormationHistories.generate_stars_mass_composite","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mass_composite","text":"(sampled_masses, sampled_mags) = generate_stars_mass_composite(mini_vec::AbstractVector{<:AbstractVector{<:Number}}, mags::AbstractVector, mag_names::AbstractVector{String}, limit::Number, massfrac::AbstractVector{<:Number}, imf::Sampleable{Univariate,Continuous}; kws...)\n\nGenerates a random sample of stars with a complex star formation history using multiple isochrones. Very similar to generate_stars_mass except the isochrone-related arguments mini_vec and mags should now be vectors of vectors containing the relevant data for the full set of isochrones to be considered. The total birth stellar mass of the sampled population is given by limit. The proportion of this mass allotted to each of the individual isochrones is given by the entries of the massfrac vector. This basically just proportions limit according to massfrac and calls generate_stars_mass for each of the individual stellar populations; as such it is set up to multi-thread across the multiple stellar populations. \n\nArguments\n\nmini_vec::AbstractVector{<:AbstractVector{<:Number}} contains the initial masses (in solar masses) for the stars in each isochrone; the internal vectors must be mutable as we will call Interpolations.deduplicate_knots! on each. The length of mini_vec should be equal to the number of isochrones. \nmags contains the absolute magnitudes from the isochrones in the desired filters corresponding to the same stars as provided in mini_vec. The length of mags should be equal to the number of isochrones. The individual elements of mags are each internally interpreted and converted into a standard format by StarFormationHistories.ingest_mags. The valid formats for the individual elements of mags are:\nAbstractVector{AbstractVector{<:Number}}, in which case the length of the vector length(mags[i]) can either be equal to length(mini_vec[i]), in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to length(mini_vec[i]); this is the more common use-case.\nAbstractMatrix{<:Number}, in which case mags[i] must be 2-dimensional. Valid shapes are size(mags[i]) == (length(mini_vec[i]), nfilters) or size(mags[i]) == (nfilters, length(mini_vec[i])), with nfilters being the number of filters you are providing.\nmag_names::AbstractVector{String} contains strings describing the filters you are providing in mags; an example might be [\"B\",\"V\"]. These are used when mag_lim is finite to determine what filter you want to use to limit the faintest stars you want returned. These are assumed to be the same for all isochrones.\nlimit::Number gives the total birth stellar mass of the population you want to sample. \nmassfrac::AbstractVector{<:Number} is vector giving the relative fraction of mass allotted to each individual stellar population; length must be equal to the length of mini_vec and mags. \nimf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous} is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined rand(rng::Random.AbstractRNG, imf) method to use for sampling masses. All instances of Distributions.ContinuousUnivariateDistribution are also valid. Implementations of commonly used IMFs are available in InitialMassFunctions.jl.\n\nKeyword Arguments\n\nAll keyword arguments kws... are passed to generate_stars_mass; you should refer to that method's documentation for more information. \n\nReturns\n\nsampled_masses::Vector{Vector{SVector{N,eltype(imf)}}} is a vector of vectors containing the initial stellar masses of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e., all of sampled_masses[1] were sampled from mini_vec[1] and so on. These can be concatenated into a single vector with reduce(vcat,sampled_masses). The format of the contained StaticArrays.SVectors are as output from sample_system; see that method's documentation for more details. \nsampled_mags::Vector{Vector{SVector{N,<:Number}}} is a vector of vectors containing StaticArrays.SVectors with the multi-band magnitudes of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e. all of sampled_mags[1] were sampled from mags[1] and so on. To get the magnitude of star i in band j sampled from isochrone k, you would do sampled_mags[k][i][j]. This can be concatenated into a Vector{SVector} with reduce(vcat,sampled_mags) and a 2-D Matrix with reduce(hcat,reduce(vcat,sampled_mags)). \n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.generate_stars_mag_composite","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.generate_stars_mag_composite","text":"(sampled_masses, sampled_mags) = generate_stars_mag_composite(mini_vec::AbstractVector{<:AbstractVector{<:Number}}, mags::AbstractVector, mag_names::AbstractVector{String}, absmag::Number, absmag_name::String, fracs::AbstractVector{<:Number}, imf::Sampleable{Univariate,Continuous}; frac_type::String=\"lum\", kws...)\n\nGenerates a random sample of stars with a complex star formation history using multiple isochrones. Very similar to generate_stars_mag except the isochrone-related arguments mini_vec and mags should now be vectors of vectors containing the relevant data for the full set of isochrones to be considered. The total absolute magnitude of the sampled population is given by absmag. The proportion of the luminosity allotted to each of the individual isochrones is given by the entries of the frac vector. This basically just proportions the luminosity according to frac and calls generate_stars_mag for each of the individual stellar populations; as such it is set up to multi-thread across the multiple stellar populations. \n\nArguments\n\nmini_vec::AbstractVector{<:AbstractVector{<:Number}} contains the initial masses (in solar masses) for the stars in each isochrone; the internal vectors must be mutable as we will call Interpolations.deduplicate_knots! on each. The length of mini_vec should be equal to the number of isochrones. \nmags contains the absolute magnitudes from the isochrones in the desired filters corresponding to the same stars as provided in mini_vec. The length of mags should be equal to the number of isochrones. The individual elements of mags are each internally interpreted and converted into a standard format by StarFormationHistories.ingest_mags. The valid formats for the individual elements of mags are:\nAbstractVector{AbstractVector{<:Number}}, in which case the length of the vector length(mags[i]) can either be equal to length(mini_vec[i]), in which case the length of the inner vectors must all be equal to the number of filters you are providing, or the length of the outer vector can be equal to the number of filters you are providing, and the length of the inner vectors must all be equal to length(mini_vec[i]); this is the more common use-case.\nAbstractMatrix{<:Number}, in which case mags[i] must be 2-dimensional. Valid shapes are size(mags[i]) == (length(mini_vec[i]), nfilters) or size(mags[i]) == (nfilters, length(mini_vec[i])), with nfilters being the number of filters you are providing.\nmag_names::AbstractVector{String} contains strings describing the filters you are providing in mags; an example might be [\"B\",\"V\"]. These are used when mag_lim is finite to determine what filter you want to use to limit the faintest stars you want returned. These are assumed to be the same for all isochrones.\nabsmag::Number gives the total absolute magnitude of the complex population to be sampled. \nfracs::AbstractVector{<:Number} is a vector giving the relative fraction of luminosity or mass (determined by the frac_type keyword argument) allotted to each individual stellar population; length must be equal to the length of mini_vec and mags. \nimf::Distributions.Sampleable{Distributions.Univariate, Distributions.Continuous} is a sampleable continuous univariate distribution implementing a stellar initial mass function with a defined rand(rng::Random.AbstractRNG, imf) method to use for sampling masses. All instances of Distributions.ContinuousUnivariateDistribution are also valid. Implementations of commonly used IMFs are available in InitialMassFunctions.jl.\n\nKeyword Arguments\n\nfrac_type::String either \"lum\", in which case fracs is assumed to contain the relative luminosity fractions for each individual isochrone, or \"mass\", in which case it is assumed that fracs contains mass fractions (\"mass\" is not yet implemented). \n\nAll other keyword arguments kws... are passed to generate_stars_mag; you should refer to that method's documentation for more information. \n\nReturns\n\nsampled_masses::Vector{Vector{SVector{N,eltype(imf)}}} is a vector of vectors containing the initial stellar masses of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e., all of sampled_masses[1] were sampled from mini_vec[1] and so on. These can be concatenated into a single vector with reduce(vcat,sampled_masses). The format of the contained StaticArrays.SVectors are as output from sample_system; see that method's documentation for more details. \nsampled_mags::Vector{Vector{SVector{N,<:Number}}} is a vector of vectors containing StaticArrays.SVectors with the multi-band magnitudes of the sampled stars. The outer vectors are separated by the isochrone the stars were generated from; i.e. all of sampled_mags[1] were sampled from mags[1] and so on. To get the magnitude of star i in band j sampled from isochrone k, you would do sampled_mags[k][i][j]. This can be concatenated into a Vector{SVector} with reduce(vcat,sampled_mags) and a 2-D Matrix with reduce(hcat,reduce(vcat,sampled_mags)). \n\n\n\n\n\n","category":"function"},{"location":"simulate/#Observational-Effects","page":"Simulating Color-Magnitude Diagrams","title":"Observational Effects","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"The output produced from the above methods are clean in the sense that they do not include any observational effects like photometric error or incompleteness. These effects should be implemented in a post-processing step. We provide a simple method model_cmd that accepts user-defined photometric error and completeness functions and applies them to the initial catalog, returning a Monte Carlo realization of a possible observed catalog. This method assumes Gaussian photometric errors and that the photometric error and completeness functions are separable by filter – these assumptions are not applicable for all types of data, but the source code for the method is exceedingly simple (~20 lines) and should provide an example for how you could write a similar method that more accurately reflects your data.","category":"page"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"model_cmd","category":"page"},{"location":"simulate/#StarFormationHistories.model_cmd","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.model_cmd","text":"new_mags = model_cmd(mags::AbstractVector{<:AbstractVector{<:Number}}, errfuncs, completefuncs; rng::Random.AbstractRNG=Random.default_rng())\n\nSimple method for modelling photometric error and incompleteness to \"mock observe\" a pure catalog of stellar photometry, such as those produced by generate_stars_mass and generate_stars_mag. This method assumes Gaussian photometric errors and that the photometric error and completeness functions are separable by filter. \n\nArguments\n\nmags::AbstractVector{<:AbstractVector{<:Number}}: a vector of vectors giving the magnitudes of each star to be modelled. The first index is the per-star index and the second index is the per-filter index (so mags[10][2] would give the magnitude of the tenth star in the second filter). This is the same format as the magnitudes returned by generate_stars_mass and generate_stars_mag; to use output from the composite versions, you must first reduce(vcat,mags) before passing to this function.\nerrfuncs: an iterable (typically a vector or tuple) of callables (typically functions or interpolators) with length equal to the number of filters contained in the elements of mags. This iterable must contain callables that, when called with the associated magnitudes from mags, will return the expected 1-σ photometric error at that magnitude. The organization is such that the photometric error for star i in band j is σ_ij = errfuncs[j](mags[i][j]). \ncompletefuncs: an iterable (typically a vector or tuple) of callables (typically functions or interpolators) with length equal to the number of filters contained in the elements of mags. This iterable must contain callables that, when called with the associated magnitudes from mags, will return the probability that a star with that magnitude in that band will be found in your color-magnitude diagram (this should include the original detection probability and any post-detection quality, morphology, or other cuts). The organization is such that the detection probability for star i in band j is c_ij = completefuncs[j](mags[i][j]).\n\nKeyword Arguments\n\nrng::AbstractRNG=Random.default_rng(): The object to use for random number generation.\n\nReturns\n\nnew_mags: an object similar to mags (i.e., a Vector{Vector{<:Number}}, Vector{SVector{N,<:Number}}, etc.) containing the magnitudes of the mock-observed stars. This will be shorter than the provided mags vector as we are modelling photometric incompleteness, and the magnitudes will also have random photometric errors added to them. This can be reinterpreted as a 2-dimensional Matrix with reduce(hcat,new_mags). \n\nNotes\n\nThis is a simple implementation that seeks to show a simple example of how one can post-process catalogs of \"pure\" stars from methods like generate_stars_mass and generate_stars_mag to include observational effects. This method assumes Gaussian photometric errors, which may not, in general, be accurate. It also assumes that the total detection probability can be modelled as the product of the single-filter detection probabilities as computed by completefuncs (i.e., that the completeness functions are separable across filters). This can be a reasonable assumption when you have separate photometric catalogs derived for each filter and you only collate them afterwards, but it is generally not a good assumption for detection algorithms that operate on simultaneously on multi-band photometry – the completeness functions for these types of algorithms are generally not separable.\n\n\n\n\n\n","category":"function"},{"location":"simulate/#Developer-Internals","page":"Simulating Color-Magnitude Diagrams","title":"Developer Internals","text":"","category":"section"},{"location":"simulate/","page":"Simulating Color-Magnitude Diagrams","title":"Simulating Color-Magnitude Diagrams","text":"StarFormationHistories.ingest_mags\nStarFormationHistories.sort_ingested\nStarFormationHistories.mass_limits","category":"page"},{"location":"simulate/#StarFormationHistories.ingest_mags","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.ingest_mags","text":"new_mags = ingest_mags(mini_vec::AbstractVector, mags::AbstractVector{T}) where {S <: Number, T <: AbstractVector{S}}\nnew_mags = ingest_mags(mini_vec::AbstractVector, mags::AbstractMatrix{S}) where S <: Number\n\nReinterprets provided mags to be in the correct format for input to Interpolations.interpolate.\n\nReturns\n\nnew_mags::Base.ReinterpretArray{StaticArrays.SVector}: a length(mini_vec) vector of StaticArrays.SVectors containing the same data as mags but formatted for input to Interpolations.interpolate.\n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.sort_ingested","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.sort_ingested","text":"(new_mini_vec, new_mags) = sort_ingested(mini_vec::AbstractVector, mags::AbstractVector)\n\nTakes mini_vec and mags and ensures that mini_vec is sorted (sometimes in PARSEC isochrones they are not) and calls Interpolations.deduplicate_knots! on mini_vec to ensure there are no repeat entries. Arguments must satisfy length(mini_vec) == length(mags). \n\n\n\n\n\n","category":"function"},{"location":"simulate/#StarFormationHistories.mass_limits","page":"Simulating Color-Magnitude Diagrams","title":"StarFormationHistories.mass_limits","text":"(mmin, mmax) = mass_limits(mini_vec::AbstractVector{<:Number}, mags::AbstractVector{T},\n                 mag_names::AbstractVector{String}, mag_lim::Number,\n                 mag_lim_name::String) where T <: AbstractVector{<:Number}\n\nCalculates initial mass limits that reflect a given faint-end magnitude limit.\n\nArguments\n\nmini_vec::AbstractVector{<:Number}: a length nstars vector containing initial stellar masses.\nmags::AbstractVector{<:AbstractVector{<:Number}}: a length nstars vector, with each element being a length nfilters vector giving the magnitudes of each star in the filters mag_names.\nmag_names::AbstractVector{String}: a vector giving the names of each filter as strings.\nmag_lim::Number: the faint-end magnitude limit you wish to use.\nmag_lim_name::String: the name of the filter in which mag_lim is to be applied. Must be contained in mag_names.\n\nReturns\n\nmmin::eltype(mini_vec): the initial mass corresponding to your requested mag_lim in the filter mag_lim_name. If all stars provided are brighter than your requested mag_lim, then this will be equal to minimum(mini_vec).\nmmax::eltype(mini_vec): the maximum valid mass in mini_vec; simply maximum(mini_vec).\n\nExamples\n\njulia> mass_limits([0.05,0.1,0.2,0.3], [[4.0],[3.0],[2.0],[1.0]], [\"F090W\"], 2.5, \"F090W\")\n(0.15, 0.3)\n\njulia> mass_limits([0.05,0.1,0.2,0.3], [[4.0,3.0],[3.0,2.0],[2.0,1.0],[1.0,0.0]], [\"F090W\",\"F150W\"], 2.5, \"F090W\")\n(0.15, 0.3)\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#Low-Level-Functions","page":"Low-Level Functions","title":"Low-Level Functions","text":"","category":"section"},{"location":"fitting/internals/","page":"Low-Level Functions","title":"Low-Level Functions","text":"StarFormationHistories.composite!\nStarFormationHistories.loglikelihood\nStarFormationHistories.∇loglikelihood\nStarFormationHistories.∇loglikelihood!\nStarFormationHistories.fg!\nStarFormationHistories.truncate_relweights\nStarFormationHistories.calculate_edges","category":"page"},{"location":"fitting/internals/#StarFormationHistories.composite!","page":"Low-Level Functions","title":"StarFormationHistories.composite!","text":" composite!(composite::AbstractMatrix{<:Number},\n            coeffs::AbstractVector{<:Number},\n            models::AbstractVector{T})\n            where T <: AbstractMatrix{<:Number}\n\nUpdates the composite matrix in place with the linear combination of sum( coeffs .* models ); this is equation 1 in Dolphin 2002, m_i = sum_j  r_j  c_ij.\n\nExamples\n\njulia> C = zeros(5,5);\njulia> models = [rand(size(C)...) for i in 1:5];\njulia> coeffs = rand(length(models));\njulia> composite!(C, coeffs, models);\njulia> C ≈ sum( coeffs .* models)\ntrue\n\n\n\n\n\ncomposite!(composite::AbstractVector{<:Number},\n           coeffs::AbstractVector{<:Number},\n           models::AbstractMatrix{<:Number})\n\nUpdates the composite vector with the matrix-vector product of models * coeffs. This is equation 1 in Dolphin 2002, m_i = sum_j  r_j  c_ij.\n\nExamples\n\njulia> hist_size = (5,10);\njulia> models = reduce(hcat,rand(prod(hist_size)) for i in 1:20);\njulia> coeffs = rand(length(axes(models,2)));\njulia> C = zeros(length(axes(models,1)));\njulia> composite!(C, coeffs, models);\njulia> C ≈ models * coeffs\ntrue\n\nNotes\n\nWhile the other call signature for this function more closely mirrors the natural data structure for Hess diagrams (2D matrices for composite and each entry in models), this method operates on the same data but flattened. Thus composite becomes a vector rather than a matrix and models becomes a single matrix rather than a vector of matrices. The method StarFormationHistories.stack_models is provided to stack the models into this format. This data layout enables us to use the highly optimized LinearAlgebra.mul! function to perform the matrix-vector product which typically achieves >30% speedup relative to the more natural formulation. Additionally, as mul! will typically call to a BLAS matrix-vector product function like gemv! for our use-case, we can switch out Julia's default OpenBLAS at runtime for other BLAS libraries with Julia bindings like MKL and Apple Accelerate, enabling even greater performance improvements.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.loglikelihood","page":"Low-Level Functions","title":"StarFormationHistories.loglikelihood","text":"loglikelihood(composite::AbstractArray{<:Number}, data::AbstractArray{<:Number})\n\nReturns the logarithm of the Poisson likelihood ratio given by equation 10 in Dolphin 2002,\n\ntextln  mathscrL = sum_i -m_i + n_i times left( 1 - textln  left( fracn_im_i right) right)\n\nwith composite being the complex Hess model diagram m_i (see StarFormationHistories.composite!) and data being the observed Hess diagram n_i.\n\nPerformance Notes\n\n~18.57 μs for composite=Matrix{Float64}(undef,99,99) and data=similar(composite).\n~20 μs for composite=Matrix{Float64}(undef,99,99) and data=Matrix{Int64}(undef,99,99).\n~9.3 μs for composite=Matrix{Float32}(undef,99,99) and data=similar(composite).\n~9.6 μs for composite=Matrix{Float32}(undef,99,99) and data=Matrix{Int64}(undef,99,99).\n\n\n\n\n\nloglikelihood(coeffs::AbstractVector{<:Number}, models::AbstractVector{T}, data::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\nloglikelihood(coeffs::AbstractVector{<:Number}, models::AbstractMatrix{<:Number}, data::AbstractVector{<:Number})\n\nReturns the logarithm of the Poisson likelihood ratio, but constructs the complex Hess diagram model as sum(coeffs .* models) rather than taking composite directly as an argument. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.∇loglikelihood","page":"Low-Level Functions","title":"StarFormationHistories.∇loglikelihood","text":"∇loglikelihood(model::AbstractArray{<:Number}, composite::AbstractArray{<:Number}, data::AbstractArray{<:Number})\n\nReturns the partial derivative of the logarithm of the Poisson likelihood ratio (StarFormationHistories.loglikelihood) with respect to the coefficient r_j on the provided model. If the complex Hess diagram model is m_i = sum_j  r_j  c_ij, then model is c_ij, and this function computes the partial derivative of textlog  mathscrL with respect to the coefficient r_j. This is given by equation 21 in Dolphin 2002,\n\nfracpartial  textlog  mathscrLpartial  r_j = sum_i c_ij left( fracn_im_i - 1 right)\n\nwhere n_i is bin i of the observed Hess diagram data. \n\nPerformance Notes\n\n~4.1 μs for model, composite, data all being Matrix{Float64}(undef,99,99).\n~1.3 μs for model, composite, data all being Matrix{Float32}(undef,99,99). \n\n\n\n\n\n∇loglikelihood(models::AbstractVector{T}, composite::AbstractMatrix{<:Number}, data::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\n∇loglikelihood(models::AbstractMatrix{<:Number}, composite::AbstractVector{<:Number}, data::AbstractVector{<:Number})\n\nComputes the gradient of the logarithm of the Poisson likelihood ratio with respect to the coefficients by calling the single-model ∇loglikelihood for every model in models. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n∇loglikelihood(coeffs::AbstractVector{<:Number}, models::AbstractVector{T}, data::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\n∇loglikelihood(coeffs::AbstractVector{<:Number}, models::AbstractMatrix{<:Number}, data::AbstractVector{<:Number})\n\nForms the composite matrix from coefficients coeffs and model templates models and returns the gradient of the loglikelihood with respect to the coefficients. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.∇loglikelihood!","page":"Low-Level Functions","title":"StarFormationHistories.∇loglikelihood!","text":" ∇loglikelihood!(G::AbstractVector, composite::AbstractMatrix{<:Number}, models::AbstractVector{S}, data::AbstractMatrix{<:Number}) where S <: AbstractMatrix{<:Number}\n\nEfficiently computes the gradient of StarFormationHistories.loglikelihood with respect to all coefficients by updating G with the gradient. This will overwrite composite with the result of 1 .- (data ./ composite) so it shouldn't be reused after being passed to this function. \n\nArguments\n\nG::AbstractVector is the vector that  will be mutated in-place with the computed gradient values.\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is the vector of matrices giving the model Hess diagrams.\ncomposite::AbstractMatrix{<:Number} is a matrix that contains the composite model sum(coeffs .* models).\ndata::AbstractMatrix{<:Number} contains the observed Hess diagram that is being fit.\n\n\n\n\n\nG = ∇loglikelihood!(G::AbstractVector, composite::AbstractVector{<:Number}, models::AbstractMatrix{<:Number}, data::AbstractVector{<:Number})\n\nUpdates and returns G with the gradient of the loglikelihood with respect to all coefficients. This call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.fg!","page":"Low-Level Functions","title":"StarFormationHistories.fg!","text":"-logL = fg!(F, G, coeffs::AbstractVector{<:Number}, models::AbstractVector{T}, data::AbstractMatrix{<:Number}, composite::AbstractMatrix{<:Number}) where T <: AbstractMatrix{<:Number}\n-logL = fg!(F, G, coeffs::AbstractVector{<:Number}, models::AbstractMatrix{<:Number}, data::AbstractVector{<:Number}, composite::AbstractVector{<:Number})\n\nComputes -loglikelihood and its gradient simultaneously for use with Optim.jl and other optimization APIs. See documentation here. Second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.truncate_relweights","page":"Low-Level Functions","title":"StarFormationHistories.truncate_relweights","text":"keep_idx::Vector{Int} = truncate_relweights(relweightsmin::Number, relweights::AbstractVector{<:Number}, logAge::AbstractVector{<:Number})\n\nMethod to truncate an isochrone grid with log10(age [yr]) values logAge and relative weights relweights due to an age-metallicity relation to only include models with relweights greater than relweightsmin times the maximum relative weight for each unique entry in logAge. The input vectors are the same as those for StarFormationHistories.fixed_amr, which includes more information. Returns a vector of the indices into relweights and logAge of the isochrone models whose relative weights are significant given the provided relweightsmin.\n\nExamples\n\nWhen using a fixed input age-metallicity relation as enabled by, for example, StarFormationHistories.fixed_amr, only the star formation rate (or total stellar mass) coefficients need to be fit, as the metallicity distribution is no longer a free parameter in the model. As such, the relative weights of each model with identical logAge but different metallicities only need to be computed once at the start of the optimization. As the metallicity distribution is not a free parameter, it is also possible to truncate the list of models to only those that contribute significantly to the final composite model to improve runtime performance. That is what this method does.\n\nA simple isochrone grid will be two-dimensional, encompassing age and metallicity. Consider a subset of the model grid with the same age such that unique(logAge) = [10.0] but a series of different metallicities, metallicities = -2.5:0.25:0. If we model the metallicity distribution function for this age as having a mean [M/H] of -2.0 and a Gaussian spread of 0.2 dex, then the relative weights of these models can be approximated as \n\nimport Distributions: Normal, pdf\nmetallicities = -2.5:0.25:0\nrelweights = pdf.(Normal(-2.0, 0.2), metallicities)\nrelweights ./= sum(relweights) # Normalize the relative weights to unity sum\n\n11-element Vector{Float64}:\n 0.021919934465195145\n 0.2284109622221623\n 0.4988954088848224\n 0.2284109622221623\n 0.021919934465195145\n 0.0004409368867815243\n 1.8592101580561089e-6\n 1.6432188478108614e-9\n 3.0442281937632026e-13\n 1.1821534989089337e-17\n 9.622444440364979e-23\n\nSeveral of these models with very low relative weights are unlikely to contribute significantly to the final composite model. We can select out only the significant ones with, say, relative weights greater than 10% of the maximum as StarFormationHistories.truncate_relweights(0.1, relweights, fill(10.0,length(metallicities))) which will return indices into relweights whose values are greater than 0.1 * maximum(relweights) = 0.04988954088848224,\n\n3-element Vector{Int64}:\n 2\n 3\n 4\n\nwhich correspond to relweights[2,3,4] = [ 0.2284109622221623, 0.4988954088848224, 0.2284109622221623 ]. If we use only these 3 templates in the fit, instead of the original 11, we will achieve a speedup of almost 4x with a minor loss in precision which, in most cases, will be less than the numerical uncertainties on the individual star formation rate parameters. However, as fits of these sort are naturally quite fast, we recommend use of this type of truncation only in applications where many fits are required (e.g., Monte Carlo experiments). For most applications, this level of optimization is not necessary.\n\n\n\n\n\n","category":"function"},{"location":"fitting/internals/#StarFormationHistories.calculate_edges","page":"Low-Level Functions","title":"StarFormationHistories.calculate_edges","text":"calculate_edges(edges, xlim, ylim, nbins, xwidth, ywidth)\n\nFunction to calculate the bin edges for 2D histograms. Returns (xbins, ybins) with both entries being ranges.\n\nKeyword Arguments\n\nedges is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: (-1.0:0.1:1.5, 22:0.1:27.2). If edges is provided, it will simply be returned.\nxlim is a length-2 indexable object (e.g., a Vector{Float64} or NTuple{2,Float64)) giving the lower and upper bounds on the x-axis corresponding to the provided colors array. Example: [-1.0, 1.5]. This is only used if edges==nothing.\nylim is like xlim but  for the y-axis corresponding to the provided mags array. Example [25, 20]. This is only used if edges==nothing.\nnbins::NTuple{2,<:Integer} is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if edges==nothing.\nxwidth is the bin width along the x-axis for the colors array. This is only used if edges==nothing and nbins==nothing. Example: 0.1. \nywidth is like xwidth but for the y-axis corresponding to the provided mags array. Example: 0.1.\n\n\n\n\n\n","category":"function"},{"location":"fitting/log_amr/#Logarithmic-Age-Metallicity-Relation","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"","category":"section"},{"location":"fitting/log_amr/#Definition","page":"Logarithmic Age-Metallicity Relation","title":"Definition","text":"","category":"section"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"This model differs from the linear age-metallicity relation (AMR) in its definition of the mean metallicity at lookback time t. In the linear model, we defined the mean metallicity as langle textMtextH rangle (t) = alpha  left( T_textmax - t_j right) + beta, whereas in this model we define the metal mass fraction Z to be linear with lookback time, such that [M/H] scales logarithmically with lookback time,","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nlangle Z rangle (t) = alpha  left( T_textmax - t right) + beta \nlangle textMtextHrangle (t) equiv textlog left( fraclangle Z rangle left(tright)X right) - textlog left( fracZ_odotX_odot right)\nendaligned","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"with T_textmax being the earliest lookback time under consideration, such that langle Z rangle (T_textmax) = beta. We choose this parameterization so that positive alpha and beta result in an age-metallicity relation that is monotonically increasing with decreasing lookback time t. We model the spread in metallicities at fixed t as Gaussian in [M/H], identically to how it is modelled in the linear AMR case. This implies the spread is asymmetric in Z; this can be seen in the output of examples/log_amr/log_amr_example.jl, shown below, which illustrates the relative weights due to a logarithmic AMR across a grid of ages and metallicities. The per-model coefficients implied by a such a logarithmic AMR can be calculated with calculate_coeffs_logamr.","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"ENV[\"GKSwstype\"] = \"100\" # https://discourse.julialang.org/t/generation-of-documentation-fails-qt-qpa-xcb-could-not-connect-to-display/60988 # hide\ninclude(\"../../../examples/log_amr/log_amr_example.jl\") # hide\nsavefig(\"log_amr_plot.svg\"); nothing # hide","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"(Image: Visualization of the relative weights across a grid of logAge and metallicity under a logarithmic age-metallicity relation.)","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"StarFormationHistories.calculate_coeffs_logamr","category":"page"},{"location":"fitting/log_amr/#StarFormationHistories.calculate_coeffs_logamr","page":"Logarithmic Age-Metallicity Relation","title":"StarFormationHistories.calculate_coeffs_logamr","text":"calculate_coeffs_logamr(variables::AbstractVector{<:Number},\n                        logAge::AbstractVector{<:Number},\n                        metallicities::AbstractVector{<:Number},\n                        T_max::Number\n                        [, α::Number, β::Number, σ::Number];\n                        MH_func = StarFormationHistories.MH_from_Z)\n\nCalculates per-model stellar mass coefficients coeffs from the fitting parameters of StarFormationHistories.fit_templates_logamr and StarFormationHistories.hmc_sample_logamr. The variables returned by these functions is of length length(unique(logAge))+3. The first length(logAge) entries are stellar mass coefficients, one per unique entry in logAge. The final three elements are α, β, and σ defining a metallicity evolution such that the mean metal mass fraction Z for element i of unique(logAge) is μ_Z[i] = α * (T_max - exp10(unique(logAge)[i]) / 1e9) + β. This is converted to a mean metallicity in [M/H] via the provided callable keyword argument MH_func which defaults to StarFormationHistories.MH_from_Z. The individual weights per each isochrone are then determined via Gaussian weighting with the above mean [M/H] and the provided σ in dex. The provided metallicities vector should be in [M/H]. \n\nNotes\n\nPhysically, the metal mass fraction Z must always be positive. Under the above model, this means α and β must be greater than or equal to 0. With σ being a Gaussian width, it must be positive.\nIf T_max is lower than the maximum of the logAge argument you provide, a warning will be raised which may be ignored if it does not result in any of the mean metal mass fractions Z being less than 0 for any of the provided logAge.\nAn error will be thrown if the provided age-metallicity relation variables (α, β) and T_max  argument result in a mean metal mass fraction less than 0 for any time in the provided logAge vector. \n\n\n\n\n\n","category":"function"},{"location":"fitting/log_amr/#Fitting-Functions","page":"Logarithmic Age-Metallicity Relation","title":"Fitting Functions","text":"","category":"section"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"The main function we provide to fit star formation histories to Hess diagrams under the logarithmic age-metallicity relation is fit_templates_logamr. This function operates similarly to the fitting function for the linear AMR model, fit_templates_mdf. ","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"StarFormationHistories.fit_templates_logamr","category":"page"},{"location":"fitting/log_amr/#StarFormationHistories.fit_templates_logamr","page":"Logarithmic Age-Metallicity Relation","title":"StarFormationHistories.fit_templates_logamr","text":"result = fit_templates_logamr(models::AbstractVector{<:AbstractMatrix{S}},\n                              data::AbstractMatrix{<:Number},\n                              logAge::AbstractVector{<:Number},\n                              metallicities::AbstractVector{<:Number},\n                              T_max::Number\n                              [, σ::Number];\n                              x0 = vcat(construct_x0_mdf(logAge, convert(S,13.7)),\n                                        [1e-4, 5e-5, 0.2]),\n                              MH_func = StarFormationHistories.MH_from_Z,\n                              MH_deriv_Z = StarFormationHistories.dMH_dZ,\n                              kws...) where {S <: Number}\nresult = fit_templates_logamr(models::AbstractMatrix{S},\n                              data::AbstractVector{<:Number},\n                              logAge::AbstractVector{<:Number},\n                              metallicities::AbstractVector{<:Number}\n                              T_max::Number\n                              [, σ::Number];\n                              x0 = vcat(construct_x0_mdf(logAge, convert(S,13.7)),\n                                        [1e-4, 5e-5, 0.2]),\n                              MH_func = StarFormationHistories.MH_from_Z,\n                              MH_deriv_Z = StarFormationHistories.dMH_dZ,\n                              kws...) where {S <: Number}\n\nMethod that fits a linear combination of the provided Hess diagrams models to the observed Hess diagram data, constrained to have a logarithmic age-metallicity relation with the mean metal mass fraction μ_Z of element i of unique(logAge) being μ_Z[i] = α * (T_max - exp10(unique(logAge)[i]) / 1e9) + β. This is converted to a mean metallicity in [M/H] via the provided callable keyword argument MH_func which defaults to MH_from_Z. α is therefore a slope in the units of inverse Gyr, and β is the mean metal mass fraction of stars born at the earliest valid lookback time, determined by keyword argument T_max which has units of Gyr. Individual weights for each isochrone template are then determined via Gaussian weighting with the above mean [M/H] and the standard deviation σ in dex, which can either be fixed or fit.\n\nThis function is designed to work best with a \"grid\" of stellar models, defined by the outer product of N unique entries in logAge and M unique entries in metallicities. See the examples for more information on usage.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels are the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram. \ndata is the Hess diagram for the observed data. \nlogAge::AbstractVector{<:Number} is the vector containing the effective ages of the stellar populations used to create the templates in models, in units of log10(age [yr]). For example, if a population has an age of 1 Myr, its entry in logAge should be log10(10^6) = 6.0.\nmetallicities::AbstractVector{<:Number} is the vector containing the effective metallicities of the stellar populations used to create the templates in models. This should be a logarithmic abundance like [M/H] or [Fe/H].\nT_max::Number is the maximum lookback time in Gyr for which the age-metallicity relation is to be valid. In most cases this should just be the maximum of the logAge vector argument maximum(logAge) or slightly larger. By definition, this is the lookback time at which μ_Z = β. \n\nOptional Arguments\n\nIf provided, σ::Number is the fixed width of the Gaussian the defines the metallicity distribution function (MDF) at fixed logAge. If this argument is omitted, σ will be a free parameter in the fit. \n\nKeyword Arguments\n\nx0 is the vector of initial guesses for the stellar mass coefficients per unique entry in logAge, plus the variables that define the metallicity evolution model. You should basically always be calculating and passing this keyword argument. We provide construct_x0_mdf to prepare the first part of x0 assuming constant star formation rate, which is typically a good initial guess. You then have to concatenate that result with an initial guess for the metallicity evolution parameters. For example, x0=vcat(construct_x0_mdf(logAge, 13.7; normalize_value=1e4), [1e-4, 5e-5, 0.2]), where logAge is a valid argument for this function (see above), and the initial guesses on the parameters are [α, β, σ] = [1e-4, 5e-5, 0.2]. If you provide σ as an optional argument, then you should not include an entry for it in x0.\nMH_func is a callable that takes a metal mass fraction Z and returns the logarithmic abundance [M/H]; by default uses MH_from_Z.\nMH_deriv_Z is a callable that takes a metal mass fraction Zj and returns the derivative of MH_func with respect to the metal mass fraction Z evaluated at Zj. For the default value of MH_func, dMH_dZ provides the correct derivative. You only need to change this if you use an alternate MH_func.\nOther kws... are passed to Optim.options to set things like convergence criteria for the optimization.\n\n\n\n\n\n","category":"function"},{"location":"fitting/log_amr/#Sampling-Functions","page":"Logarithmic Age-Metallicity Relation","title":"Sampling Functions","text":"","category":"section"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"StarFormationHistories.hmc_sample_logamr","category":"page"},{"location":"fitting/log_amr/#StarFormationHistories.hmc_sample_logamr","page":"Logarithmic Age-Metallicity Relation","title":"StarFormationHistories.hmc_sample_logamr","text":"Not yet implemented \n\n\n\n\n\n","category":"function"},{"location":"fitting/log_amr/#Fixed-Logarithmic-Age-Metallicity-Relation","page":"Logarithmic Age-Metallicity Relation","title":"Fixed Logarithmic Age-Metallicity Relation","text":"","category":"section"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"We support fitting only the star formation parameters by adopting fixed values for alpha, beta, and sigma through the fixed_log_amr method.","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"StarFormationHistories.fixed_log_amr","category":"page"},{"location":"fitting/log_amr/#StarFormationHistories.fixed_log_amr","page":"Logarithmic Age-Metallicity Relation","title":"StarFormationHistories.fixed_log_amr","text":"fixed_log_amr(models,\n              data,\n              logAge::AbstractVector{<:Number},\n              metallicities::AbstractVector{<:Number},\n              T_max::Number,\n              α::Number,\n              β::Number,\n              σ::Number;\n              MH_func = StarFormationHistories.MH_from_Z,\n              kws...)\n\nGiven a fully specified logarithmic age-metallicity relation with parameters (α, β, σ), fits maximum likelihood and maximum a posteriori star formation parameters. MH_func is a callable that returns a logarithmic metallicity [M/H] for a metal mass fraction argument and defaults to MH_from_Z. T_max is the lookback time in Gyr at which the mean metal mass fraction is \beta. See fixed_amr for info on format of returned result.\n\n\n\n\n\nfixed_log_amr(models,\n              data,\n              logAge::AbstractVector{<:Number},\n              metallicities::AbstractVector{<:Number},\n              T_max::Number,\n              constraint1,\n              constraint2,\n              σ::Number;\n              Z_func = StarFormationHistories.Z_from_MH,\n              kws...)\n\nCall signature that takes two fixed points low_constraint and high_constraint that define points that must lie on the logarithmic age-metallicity relation and calculates the slope paramters α and β for you. Format is ([M/H], age [Gyr]), i.e. constraint1 = (-2.5, 13.7) for the first point at [M/H] = -2.5 at 13.7 Gyr lookback time and constraint2 = (-0.8, 0.0) for the second point at [M/H] = -0.8 at present-day (0.0 Gyr lookback time). The AMR is normalized so that the mean metal mass fraction at a lookback time in Gyr of T_max is Z = β. Metallicities in [M/H] are converted to metal mass fractions Z via the provided callable keyword argument Z_func which defaults to Z_from_MH. See fixed_amr for info on format of returned result.\n\n\n\n\n\n","category":"function"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"We provide the calculate_αβ_logamr convenience function to calculate the slope alpha and intercept beta from two points on the age-metallicity relation.","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"StarFormationHistories.calculate_αβ_logamr","category":"page"},{"location":"fitting/log_amr/#StarFormationHistories.calculate_αβ_logamr","page":"Logarithmic Age-Metallicity Relation","title":"StarFormationHistories.calculate_αβ_logamr","text":"(α, β) = calculate_αβ_logamr(low_constraint,\n                             high_constraint,\n                             T_max,\n                             Z_func=Z_from_MH)\n\nCalculates linear Z (log [M/H]) age-metallicity relation (AMR) slope α and intercept β from two points on the line with form ([M/H], age [Gyr]) given by the first two arguments. The AMR is normalized so that the mean metal mass fraction at a lookback time in Gyr of T_max is Z = β. More info given in fixed_log_amr. \n\n\n\n\n\n","category":"function"},{"location":"fitting/log_amr/#Implementation","page":"Logarithmic Age-Metallicity Relation","title":"Implementation","text":"","category":"section"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"As the only part of the model that differs from the linear AMR case is the mean age-metallicity relation, most of the derivation for the linear AMR case is still valid here. In particular, only the partial derivatives of the relative weights A_jk equiv textexp left( -frac12  sigma^2  left( textMtextH_k - mu_j right)^2right) with respect to the fitting parameters alpha and beta need to be recalculated under the new model. The partial derivative with respect to sigma is the same, as the mean metallicity in time bin j, denoted mu_j, does not depend on sigma.","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nZ_j equiv langle Z left(t_jright) rangle = alpha  left( T_textmax - t_j right) + beta \n \nmu_j equiv langle textMtextH rangle left(t_jright) = textlog left( fraclangle Zleft(t_jright) rangleX_j right) - textlog left( fracZ_odotX_odot right) \n= textlog left frac alpha  left( T_textmax - t_j right) + betaX_j right - textlog left( fracZ_odotX_odot right)\nendaligned","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"We can use the chain rule to write","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nA_jk equiv textexp left( - frac12 left( frac textMtextH_k - mu_jsigma right)^2 right) \nfracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial beta \nfracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial alpha \nendaligned ","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"By definition the hydrogen, helium, and metal mass fractions, X, Y, and Z respectively, must sum to 1. For PARSEC models, Y is a function of Z (see Y_from_Z) such that X_j is a function of Z_j and therefore also alpha and beta. Under the PARSEC model, Y = Y_p + gamma  Z, we have X(Z) = 1 - left( Y_p + gamma  Z right) - Z such that we can rewrite the mu_j as ","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"mu_j = textlog left( fracZ_j1 - left( Y_p + gamma  Z_j right) - Z_j right) - textlog left( fracZ_odotX_odot right)","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"and we can further expand the partial derivatives of mu_j as","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial mu_jpartial beta = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial beta \nfracpartial mu_jpartial alpha = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial alpha \nendaligned ","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"such that the model-dependent portion left( fracpartial Z_jpartial beta right) can be separated from what is essentially a calibration defining how [M/H] is calculated from Z left( fracpartial mu_jpartial Z_j right). Given our model Z_j = alpha  left( T_textmax - t_j right) + beta and the PARSEC calibration for conversion between Z_j and mu_j (i.e., [M/H]), we have","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial mu_jpartial Z_j = fracY_p - 1textln10  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) \nfracpartial Z_jpartial beta = fracpartial leftalpha  left( T_textmax - t_j right) + beta rightpartial beta = 1 \nfracpartial Z_jpartial alpha = fracpartial left alpha  left( T_textmax - t_j right) + beta rightpartial alpha = T_textmax - t_j \nendaligned","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"[M/H] as a function of Z for the PARSEC calibration is available as MH_from_Z and the partial derivative fracpartial mu_jpartial Z_j is available as dMH_dZ.","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"Which gives us final results","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial  A_jkpartial  mu_j = fracA_jk  left( textMtextH_k - mu_j right)sigma^2 \nfracpartial mu_jpartial beta = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial beta = left( fracY_p - 1textln(10)  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right)  left( 1 right) \nfracpartial mu_jpartial alpha = fracpartial mu_jpartial Z_j  fracpartial Z_jpartial alpha = left( fracY_p - 1textln(10)  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right)  left( T_textmax - t_j right) \n\n fracpartial mu_jpartial beta = frac1left( t_j  alpha + beta right)  textln(10) \n fracpartial mu_jpartial alpha = fractleft( t_j  alpha + beta right)  textln(10) = t  fracpartial mu_jpartial beta \nendaligned","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"such that","category":"page"},{"location":"fitting/log_amr/","page":"Logarithmic Age-Metallicity Relation","title":"Logarithmic Age-Metallicity Relation","text":"beginaligned\nfracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial Z_j  fracpartial Z_jpartial beta \n= left( fracA_jk  left( textMtextH_k - mu_j right)sigma^2 right)  left( fracY_p - 1textln10  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right) \nfracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial Z_j  fracpartial Z_jpartial alpha \n= left( fracA_jk  left( textMtextH_k - mu_j right)sigma^2 right)  left( fracY_p - 1textln10  Z_j  left( Y_p + Z_j + gamma  Z_j - 1 right) right)  left( T_textmax - t_j right) \n= left( T_textmax - t_j right) fracpartial  A_jkpartial  beta \n\n fracpartial  A_jkpartial  beta = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial beta = left( fracA_jk  left( textMtextH_k - mu_j right)sigma^2 right)  left( frac1left( t_j  alpha + beta right)  textln(10) right) \n = fracA_jk  left( textMtextH_k - mu_j right)textln(10)  sigma^2  left( t_j  alpha + beta right) \n fracpartial  A_jkpartial  alpha = fracpartial  A_jkpartial  mu_j  fracpartial mu_jpartial alpha = t  fracpartial  A_jkpartial  beta\nendaligned","category":"page"},{"location":"binaries/#binaries","page":"Binary Systems","title":"Binary Systems","text":"","category":"section"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"Here we review the API for including binary systems in our population models. Our Monte Carlo sampling methods supports all three models, while our smooth template modelling procedure only supports NoBinaries and RandomBinaryPairs. A comparison between a Monte Carlo population and a smooth template model for a RandomBinaryPairs model with binary fraction of 70% is shown below. The redward shift of the lower main sequence typical of populations with high binary fractions is clearly evident and robustly modelled.","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"mv(\"../../examples/templates/template_compare_binaries.svg\", \"template_compare_binaries.svg\") # hide\nmv(\"../../examples/templates/sigma_distribution_binaries.svg\", \"sigma_distribution_binaries.svg\") # hide\nnothing # hide","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"(Image: Comparison of CMD-sampled population with smooth Hess diagram template, with binaries.)","category":"page"},{"location":"binaries/#Types","page":"Binary Systems","title":"Types","text":"","category":"section"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"StarFormationHistories.AbstractBinaryModel\nStarFormationHistories.NoBinaries\nStarFormationHistories.RandomBinaryPairs\nStarFormationHistories.BinaryMassRatio","category":"page"},{"location":"binaries/#StarFormationHistories.AbstractBinaryModel","page":"Binary Systems","title":"StarFormationHistories.AbstractBinaryModel","text":"StarFormationHistories.AbstractBinaryModel is the abstract supertype for all types that are used to model multi-star systems in the package. All concrete subtypes should implement the following methods to support all features:\n\nStarFormationHistories.sample_system\nStarFormationHistories.binary_system_fraction\nStarFormationHistories.binary_mass_fraction\nBase.length, which should return an integer indicating the number of stars per system that can be sampled by the model; this is equivalent to the length of the mass vector returned by sample_system.\n\nNote that all quantities relating to binary populations (e.g., binary_system_fraction) should be defined for the population at birth. As the stars in a binary system evolve, the more massive star may die before the system is observed at present-day. Of course, the stars in single-star systems can also die. If the rate at which binary systems become single-star systems is not equal to the rate at which single-star systems die, then there can be net transfer between these populations over time. Therefore the observed, present-day binary system fraction of an evolved population is not necessarily equal to the fraction at birth, which is the more fundamental quantity.\n\n\n\n\n\n","category":"type"},{"location":"binaries/#StarFormationHistories.NoBinaries","page":"Binary Systems","title":"StarFormationHistories.NoBinaries","text":"NoBinaries()\n\nThe NoBinaries type indicates that no binaries of any kind should be created. \n\n\n\n\n\n","category":"type"},{"location":"binaries/#StarFormationHistories.RandomBinaryPairs","page":"Binary Systems","title":"StarFormationHistories.RandomBinaryPairs","text":"RandomBinaryPairs(fraction::Real)\n\nThe RandomBinaryPairs type takes one argument 0 <= fraction::Real <= 1 that denotes the number fraction of stellar systems that are binaries (e.g., 0.3 for 30% binary fraction) and will sample binaries as random pairs of two stars drawn from the same single-star IMF. This model will ONLY generate up to one additional star – it will not generate any 3+ star systems. This model typically incurs a 10–20% speed penalty relative to NoBinaries. \n\n\n\n\n\n","category":"type"},{"location":"binaries/#StarFormationHistories.BinaryMassRatio","page":"Binary Systems","title":"StarFormationHistories.BinaryMassRatio","text":"BinaryMassRatio(fraction::Real,\n                qdist::Distributions.ContinuousUnivariateDistribution =\n                    Distributions.Uniform(0.1, 1.0))\n\nThe BinaryMassRatio type takes two arguments; the number fraction of stellar systems that are binaries 0 <= fraction::Real <= 1 and a continuous univariate distribution qdist from which to sample binary mass ratios, defined as the ratio of the secondary mass to the primary mass: q = textM_S  textM_P. The provided qdist must have the proper support of (minimum(qdist) >= 0) & (maximum(qdist) <= 1). Users may find the Distributions.truncated method useful for enforcing this support on more general distributions. The default qdist is a uniform distribution from 0.1 to 1, which appears to give reasonably good agreement to observations (see, e.g., Goodwin 2013).\n\n\n\n\n\n","category":"type"},{"location":"binaries/#Methods","page":"Binary Systems","title":"Methods","text":"","category":"section"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"StarFormationHistories.binary_system_fraction\nStarFormationHistories.binary_number_fraction\nStarFormationHistories.binary_mass_fraction\nStarFormationHistories.sample_system","category":"page"},{"location":"binaries/#StarFormationHistories.binary_system_fraction","page":"Binary Systems","title":"StarFormationHistories.binary_system_fraction","text":"binary_system_fraction(model::T) where T <: AbstractBinaryModel\n\nReturns the number fraction of stellar systems that are binaries for the given concrete subtype T <: AbstractBinaryModel. Has a default implementation of binary_system_fraction(model::AbstractBinaryModel) = model.fraction.\n\n\n\n\n\n","category":"function"},{"location":"binaries/#StarFormationHistories.binary_number_fraction","page":"Binary Systems","title":"StarFormationHistories.binary_number_fraction","text":"binary_number_fraction(model::T) where T <: AbstractBinaryModel\n\nReturns the number fraction of stars that in binary pairs for the given concrete subtype T <: AbstractBinaryModel. Has a default implementation of 2b / (1+b), where b is the result of StarFormationHistories.binary_system_fraction.\n\n\n\n\n\n","category":"function"},{"location":"binaries/#StarFormationHistories.binary_mass_fraction","page":"Binary Systems","title":"StarFormationHistories.binary_mass_fraction","text":"binary_mass_fraction(model::T, imf) where T <: AbstractBinaryModel\n\nReturns the fraction of stellar mass in binary systems for the given concrete subtype T <: AbstractBinaryModel and initial mass function imf. imf must be a properly normalized probability distribution such that the number fraction of stars/systems between mass m1 and m2 is given by the integral of dispatch_imf(imf, x) from m1 to m2. \n\n\n\n\n\nbinary_mass_fraction(m::RandomBinaryPairs, imf)\n\nThe RandomBinaryPairs model uses a single-star imf. If a system is chosen to be a binary pair, two stars are drawn from the single-star imf and the more massive star is made the primary. Given this model, it can be shown that the expectation value for the mass of a binary system is twice the expectation value for single star systems:\n\n2int_textM_textmin^textM_textmax textM fracdtextN left( textM right)dtextM  dtextM  =  int_textM_textmin^textM_textmax int_textM_textmin^textM_textmax left( textM_P + textM_S right) fracdtextN left( textM_S right)dtextM fracdtextN left( textM_P right)dtextM dtextM_S  dtextM_P\n\nfor primary mass textM_P, secondary mass textM_S, and single-star IMF dtextN  dtextM. As such, the fraction of total stellar mass in binaries is equal to the number fraction of all stars in binary pairs, which is given by StarFormationHistories.binary_number_fraction.\n\n\n\n\n\nbinary_mass_fraction(m::BinaryMassRatio, imf)\n\nThis binary model requires an imf that is defined by stellar system mass. If a system with a randomly sampled mass M is is a binary, the primary and secondary mass are determined based on a binary mass ratio q sampled from a user-defined distribution. By definition, the expectation value for the total mass of a binary system is equal to the expectation value for single-star systems. In this case the binary mass fraction is equal the binary system number fraction as given by StarFormationHistories.binary_system_fraction.\n\n\n\n\n\n","category":"function"},{"location":"binaries/#StarFormationHistories.sample_system","page":"Binary Systems","title":"StarFormationHistories.sample_system","text":"masses = sample_system(imf, rng::AbstractRNG, binarymodel::StarFormationHistories.AbstractBinaryModel)\n\nSimulates the effects of non-interacting, unresolved stellar companions on stellar photometry. Implementation depends on the choice of binarymodel.\n\nArguments\n\nimf: an object implementing rand(imf) to draw a random mass for a single star or a stellar system (depends on choice of binarymodel)\nrng::AbstractRNG: the random number generator to use when sampling stars\nbinarymodel::StarFormationHistories.AbstractBinaryModel: an instance of a binary model that determines which implementation will be used; currently provided options are NoBinaries, RandomBinaryPairs, and BinaryMassRatio.\n\nReturns\n\nmasses::SVector{N,eltype(imf)}: the masses of the individual stars sampled in the system in descending order where N is the maximum number of stars that can be sampled by the provided binarymodel as given by Base.length(binarymodel). \n\n\n\n\n\n","category":"function"},{"location":"binaries/#Notes","page":"Binary Systems","title":"Notes","text":"","category":"section"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"The trickiest part of including binaries in the smooth template modelling procedure is deriving the IMF weights. Let M_p be the sorted list of initial masses for primary stars and M_s be the sorted list of initial masses for secondary stars. Conceptually, the IMF weight for a binary system with primary mass M_pi and secondary mass M_sj should compute the number fraction of binary systems born with primary masses between M_pi and M_pi+1 and secondary masses between M_sj and M_sj+1 per unit solar mass formed. ","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"In the case of the RandomBinaryPairs model, the IMF weights are calculated as follows, with dN(M)dM being the IMF for single stars, langle M rangle being the mean mass of single stars over the full range of possible initial masses, and the integral in the denominator being over the range of initial masses in the isochrone. The integral in the denominator accounts for losses due to stellar evolution.","category":"page"},{"location":"binaries/","page":"Binary Systems","title":"Binary Systems","text":"  w_textIMFij = fracint_M_pi^M_pi+1 int_M_sj^M_sj+1 fracdN(M_p)dM fracdN(M_s)dM  dM_p  dM_slangle M rangle  int_M_textmin^M_textmax fracdN(M)dM  dM","category":"page"},{"location":"helpers/#helpers","page":"Helper Functions","title":"Helper Functions","text":"","category":"section"},{"location":"helpers/#Distances-and-Sizes","page":"Helper Functions","title":"Distances and Sizes","text":"","category":"section"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"StarFormationHistories.arcsec_to_pc\nStarFormationHistories.pc_to_arcsec\nStarFormationHistories.distance_modulus\nStarFormationHistories.distance_modulus_to_distance","category":"page"},{"location":"helpers/#StarFormationHistories.arcsec_to_pc","page":"Helper Functions","title":"StarFormationHistories.arcsec_to_pc","text":"arcsec_to_pc(arcsec, dist_mod)\n\nConverts on-sky angle in arcseconds to physical separation based on distance modulus under the small-angle approximation.\n\nr  10^μ5 + 1 times textatan(θ3600)\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.pc_to_arcsec","page":"Helper Functions","title":"StarFormationHistories.pc_to_arcsec","text":"pc_to_arcsec(pc, dist_mod)\n\nInverse of arcsec_to_pc.\n\nθ  texttanleft( r  10^μ5 + 1 right) times 3600\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.distance_modulus","page":"Helper Functions","title":"StarFormationHistories.distance_modulus","text":"distance_modulus(distance)\n\nFinds distance modulus for distance in parsecs.\n\nμ = 5 times log_10(d) - 5\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.distance_modulus_to_distance","page":"Helper Functions","title":"StarFormationHistories.distance_modulus_to_distance","text":"distance_modulus_to_distance(dist_mod)\n\nConverts distance modulus to distance in parsecs.\n\nd = 10^μ5 + 1\n\n\n\n\n\n","category":"function"},{"location":"helpers/#Magnitudes-and-Luminosities","page":"Helper Functions","title":"Magnitudes and Luminosities","text":"","category":"section"},{"location":"helpers/#metallicity_helpers","page":"Helper Functions","title":"Metallicities","text":"","category":"section"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"StarFormationHistories.Y_from_Z\nStarFormationHistories.X_from_Z\nStarFormationHistories.MH_from_Z\nStarFormationHistories.dMH_dZ\nStarFormationHistories.Z_from_MH\nStarFormationHistories.mdf_amr","category":"page"},{"location":"helpers/#StarFormationHistories.Y_from_Z","page":"Helper Functions","title":"StarFormationHistories.Y_from_Z","text":"Y_from_Z(Z, Y_p=0.2485, γ=1.78)\n\nCalculates the helium mass fraction (Y) for a star given its metal mass fraction (Z) using the approximation Y = Y_p + γ * Z, with Y_p being the primordial helium abundance Y_p=0.2485 as assumed for PARSEC isochrones and γ=1.78 matching the input scaling for PARSEC as well. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.X_from_Z","page":"Helper Functions","title":"StarFormationHistories.X_from_Z","text":"X_from_Z(Z[, Yp, γ])\n\nCalculates the hydrogen mass fraction (X) for a star given its metal mass fraction (Z) via X = 1 - (Z + Y), with the helium mass fraction Y approximated via StarFormationHistories.Y_from_Z. You may also provide the primordial helium abundance Y_p and γ such that Y = Y_p + γ * Z; these are passed through to X_from_Z. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.MH_from_Z","page":"Helper Functions","title":"StarFormationHistories.MH_from_Z","text":"MH_from_Z(Z, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nCalculates [M/H] = log(Z/X) - log(Z/X)⊙. Given the provided solar metal mass fraction solZ, it calculates the hydrogen mass fraction X for both the Sun and the provided Z with StarFormationHistories.X_from_Z. You may also provide the primordial helium abundance Y_p and γ such that Y = Y_p + γ * Z; these are passed through to X_from_Z. \n\nThe present-day solar Z is measured to be 0.01524 (Caffau et al. 2011), but for PARSEC isochrones an [M/H] of 0 corresponds to Z=0.01471. This is because of a difference between the Sun's initial and present helium content caused by diffusion. If you want to reproduce PARSEC's scaling, you should set solZ=0.01471.\n\nThis function is an approximation and may not be suitable for precision calculations.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.dMH_dZ","page":"Helper Functions","title":"StarFormationHistories.dMH_dZ","text":"dMH_dZ(Z, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nPartial derivative of MH_from_Z with respect to the input metal mass fraction Z. Used for some optimizations. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.Z_from_MH","page":"Helper Functions","title":"StarFormationHistories.Z_from_MH","text":"Z_from_MH(MH, solZ=0.01524; Y_p = 0.2485, γ = 1.78)\n\nCalculates metal mass fraction Z assuming\n\nthe PARSEC relation for the helium mass fraction Y = Y_p + γ * Z with primordial helium abundance Y_p = 0.2485, and γ = 1.78, and\nthe solar metal mass fraction solZ = 0.01524.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.mdf_amr","page":"Helper Functions","title":"StarFormationHistories.mdf_amr","text":"(unique_MH, mass_mdf) =\nmdf_amr(coeffs::AbstractVector{<:Number},\n        logAge::AbstractVector{<:Number},\n        metallicities::AbstractVector{<:Number})\n\nCalculates the mass-weighted metallicity distribution function given a set of stellar mass coefficients coeffs for stellar populations with logarithmic ages logAge=log10(age [yr]) and metallicities given by metallicities. This is calculated as\n\nP_j = frac sum_k r_jk  textM  textH_ksum_jk r_jk  textM  textH_k\n\nwhere r_jk are the elements of coeffs where j indexes over unique entries in logAge and k indexes over unique entries in metallicities. This is the same nomenclature used in the the documentation on constrained metallicity evolutions.\n\nExamples\n\njulia> mdf_amr([1.0, 2.0, 1.0], [10, 10, 10], [-2, -1.5, -1])\n([-2.0, -1.5, -1.0], [0.25, 0.5, 0.25])\n\n\n\n\n\n","category":"function"},{"location":"helpers/#phot_helpers","page":"Helper Functions","title":"Photometric Error and Completeness Models","text":"","category":"section"},{"location":"helpers/","page":"Helper Functions","title":"Helper Functions","text":"StarFormationHistories.Martin2016_complete\nStarFormationHistories.exp_photerr\nStarFormationHistories.process_ASTs","category":"page"},{"location":"helpers/#StarFormationHistories.Martin2016_complete","page":"Helper Functions","title":"StarFormationHistories.Martin2016_complete","text":"η(m) = Martin2016_complete(m, A, m50, ρ)\n\nCompleteness model of Martin et al. 2016 implemented as their Equation 7:\n\neta(m) = fracA1 + textexp left( fracm - m_50rho right)\n\nm is the magnitude of interest, A is the maximum completeness, m50 is the magnitude at which the data are 50% complete, and ρ is an effective slope modifier.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.exp_photerr","page":"Helper Functions","title":"StarFormationHistories.exp_photerr","text":"exp_photerr(m, a, b, c, d)\n\nExponential model for photometric errors of the form\n\nsigma(m) = a^b times left( m-c right) + d\n\nReported values for some HST data were a=1.05, b=10.0, c=32.0, d=0.01. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#StarFormationHistories.process_ASTs","page":"Helper Functions","title":"StarFormationHistories.process_ASTs","text":"process_ASTs(ASTs::Union{DataFrames.DataFrame,\n                         TypedTables.Table},\n             inmag::Symbol,\n             outmag::Symbol,\n             bins::AbstractVector{<:Real},\n             selectfunc;\n             statistic=StatsBase.median)\n\nProcesses a table of artificial stars to calculate photometric completeness, bias, and error across the provided bins. This method has no default implementation and is implemented in package extensions that rely on either DataFrames.jl or TypedTables.jl being loaded into your Julia session to load the relevant method. This method therefore requires Julia 1.9 or greater to use.\n\nArguments\n\nASTs is the table of artificial stars to be analyzed.\ninmag is the column name in symbol format (e.g., :F606Wi) that corresponds to the intrinsic (input) magnitudes of the artificial stars.\noutmag is the column name in symbol format (e.g., :F606Wo) that corresponds to the measured (output) magnitude of the artificial stars.\nbins give the bin edges to be used when computing the binned statistics.\nselectfunc is a method that takes a single row from ASTs, corresponding to a single artificial star, and returns a boolean that is true if the star is considered successfully measured.\n\nKeyword Arguments\n\nstatistic is the method that will be used to determine the bias and error, i.e., bias = statistic(out .- in) and error = statistic(abs.(out .- in)). By default we use StatsBase.median, but you could instead use a simple or sigma-clipped mean if so desired.\n\nReturns\n\nThis method returns a result of type NTuple{4,Vector{Float64}}. Each vector is of length length(bins)-1. result contains the following elements, each of which are computed over the provided bins considering only artificial stars for which selectfunc returned true:\n\nresult[1] contains the mean input magnitude of the stars in each bin.\nresult[2] contains the completeness value measured for each bin, defined as the fraction of input stars in each bin for which selectfunc returned true.\nresult[3] contains the photometric bias measured for each bin, defined as statistic(out .- in), where out are the measured (output) magnitudes and in are the intrinsic (input) magnitudes.\nresult[4] contains the photometric error measured for each bin, defined as statistic(abs.(out .- in)), with out and in defined as above.\n\nExamples\n\nLet\n\nF606Wi be a vector containing the input magnitudes of your artificial stars\nF606Wo be a vector containing the measured magnitudes of the artificial stars, where a value of 99.999 indicates a non-detection.\nflag be a vector of booleans that indicates whether the artificial star passed additional quality cuts (star-galaxy separation, etc.)\n\nYou could call this method as\n\nimport TypedTables: Table\nprocess_ASTs(Table(input=F606Wi, output=F606Wo, good=flag),\n             :input, :output, minimum(F606Wi):0.1:maximum(F606Wi),\n             x -> (x.good==true) & (x.output != 99.999))\n\nSee also the tests in test/utilities/process_ASTs_test.jl.\n\n\n\n\n\n","category":"function"},{"location":"fitting/kernels/#kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"One of the most important parts of our method is modelling the 2-D probability distribution of observing a star with particular intrinsic magnitudes in the Hess diagram space. We refer to these 2-D probability distributions as \"kernels\" throughout, as our process is conceptually similar to constructing a kernel density estimate. This document describes how these kernels are constructed and what assumptions are made to do so.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"Our implementation is underpinned by the assumption that all kernels can be described the family of 2-D Gaussian probability distributions. To derive these 2-D distributions, we begin with 1-D distributions for each photometric filter used in the analysis.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We assume random photometric errors in the observed photometric catalog can be approximated as Gaussian. This is generally a good assumption for the space-based imaging used for resolved SFHs (e.g., HST and JWST) as long as the photometric completeness is high (greater than, perhaps, 50%). At low completeness, the error distributions become skewed and would be better modelled by something like a skew-normal distribution, which we do not presently consider.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We additionally require that the user can construct functions for each observed photomeric filter which, given a star's input intrinsic magnitude in a single filter m_i, return reliable measures for the average single-band photometric error; sigma(m_i). Assuming that the photometric errors in each band can be modelled as independent, we can derive, for a given m_i, the probability distribution of the observed magnitude m_o. We therefore have the 1-D probability distributions P(m_om_i) for all filters.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"In the case that imaging in three photometric filters are available and are used to construct a Hess diagram with a magnitude on the y-axis that does not appear on the x-axis (e.g., y=R and x=B-V), then there is no covariance between the x and y axes and the 2-D Gaussian kernel is fully separable. We call this the \"non-covariant\" case.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"In order to inject the kernel into the model Hess diagram, it must be integrated across the grid that defines the discretization. The integral of the non-covariant kernel across the Hess diagram pixel grid is entirely analytic, making evaluation easy and efficient. By integrating the kernel over the grid, the numerical precision is nearly independent of the grid resolution, which is not true of Monte Carlo (MC) based template construction algorithms.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"In the case that imaging in only two photometric filters are available and are used to construct a Hess diagram with a magnitude on the y-axis that does appear on the x-axis (e.g., y=B and x=B-V), then there is covariance between x and y axes. The initial implementation of this method neglected this covariance, and while the result was not catastrophic, it was certainly suboptimal. We now model the covariance explicitly. The covariance pattern does not permit a fully analytic integral as in the non-covariant case; instead, the inner integral (over, say, the x-axis) can be calculated analytically but the outer integral cannot. We therefore use Gauss-Legendre quadtrature to finish the integration over the second axis.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"The types representing these kernels are not part of our public API, but we provide an example script examples/templates/kernels_example.jl which illustrates the performance of these kernels. The output of this script is reproduced and explained below.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"Consider a star taken from an isochrone with intrinsic magnitudes B=20, V=19, and R=18 with expected random photometric errors sigma_B=002, sigma_V=003, and sigma_R=005. Our example randomly samples a large population of possible observed magnitudes given these intrinsic properties and compares the distribution of the MC sample to our kernels.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We consider first the non-covariant case:","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"mv(\"../../../examples/templates/covar_0.svg\", \"figures/covar_0.svg\") # hide\nmv(\"../../../examples/templates/covar_1.svg\", \"figures/covar_1.svg\") # hide\nmv(\"../../../examples/templates/covar_m1.svg\", \"figures/covar_m1.svg\") # hide\nnothing # hide","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"(Image: noncovariant)","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"which has the expected, non-rotated morphology.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"We next consider the covariant case with the covariance pattern y=B and x=B-V:","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"(Image: covariantm1)","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"which we can see correctly models the covariance pattern.","category":"page"},{"location":"fitting/kernels/","page":"Kernels","title":"Kernels","text":"And finally, the covariant case with the covariance pattern y=V and x=B-V: (Image: covariant1)","category":"page"},{"location":"fitting/unconstrained/#High-Level-Methods-for-Unconstrained-Fitting","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"","category":"section"},{"location":"fitting/unconstrained/#Maximum-Likelihood-Optimization","page":"High-Level Methods for Unconstrained Fitting","title":"Maximum Likelihood Optimization","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Template construction is by far the most complicated step in the fitting procedure. Once your templates have been constructed, fitting them to an observed Hess diagram amounts to maximization of the Poisson likelihood ratio (Dolphin 2002). It is possible to construct more complicated hierarchical models including things like metallicity distribution functions; we discuss these in the next section. In this section we discuss methods for fitting where the only constraint is that star formation rates cannot be negative. We provide the StarFormationHistories.construct_x0 method to help with setting the initial guess for this optimization. ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.construct_x0","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.construct_x0","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.construct_x0","text":"x0::typeof(logage) = construct_x0(logAge::AbstractVector{T},\n                                  T_max::Number;\n                                  normalize_value::Number=one(T)) where T <: Number\n\nGenerates a vector of initial stellar mass normalizations for input to fit_templates or hmc_sample with a total stellar mass of normalize_value such that the implied star formation rate is constant across the provided logAge vector that contains the log10(Age [yr]) of each isochrone that you are going to input as models. For the purposes of computing the constant star formation rate, the provided logAge are treated as left-bin edges, with the final right-bin edge being T_max, which has units of Gyr. For example, you might have logAge=[6.6, 6.7, 6.8] in which case a final logAge of 6.9 would give equal bin widths. In this case you would set T_max = exp10(6.9) / 1e9 ≈ 0.0079 so that the width of the final bin for the star formation rate calculation has the same log10(Age [yr]) step as the other bins.\n\nExamples\n\njulia> x0 = construct_x0(repeat([7.0,8.0,9.0],3), 10.0; normalize_value=5.0)\n9-element Vector{Float64}: ...\n\njulia> sum(x0)\n4.99... # Close to `normalize_value`.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"When it comes to performing the optimization, the simplest method we offer is StarFormationHistories.fit_templates_lbfgsb. This will optimize one coefficient per template; there is no overarching metallicity evolution or other constraint, besides that the stellar masses of the populations cannot be negative. This performs a maximum likelihood optimization with the bounded quasi-Newton LBFGS method as implemented in L-BFGS-B and wrapped in LBFGS.jl with analytic gradients. It is fast and converges fairly reliably, even when the initial guess is not particularly close to the maximum likelihood estimate. It provides no uncertainty estimation. It is normal for some of the coefficients to converge to zero.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.fit_templates_lbfgsb","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.fit_templates_lbfgsb","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.fit_templates_lbfgsb","text":"(-logL, coeffs) = \nfit_templates_lbfgsb(models::AbstractVector{T},\n                     data::AbstractMatrix{<:Number};\n                     x0::AbstractVector{<:Number} = ones(S,length(models)),\n                     factr::Number=1e-12,\n                     pgtol::Number=1e-5,\n                     iprint::Integer=0,\n                     kws...) where {S <: Number, T <: AbstractMatrix{S}}\n\nFinds the coefficients coeffs that maximize the Poisson likelihood ratio (equations 7–10 in Dolphin 2002) for the composite Hess diagram model sum(models .* coeffs) given the provided templates models and the observed Hess diagram data using the box-constrained LBFGS method provided by LBFGSB.jl. \n\nArguments\n\nmodels::AbstractVector{AbstractMatrix{<:Number}}: the list of template Hess diagrams for the simple stellar populations (SSPs) being considered; all must have the same size.\ndata::AbstractMatrix{<:Number}: the observed Hess diagram; must match the size of the templates contained in models.\n\nKeyword Arguments\n\nx0: The vector of initial guesses for the stellar mass coefficients. You should basically always be calculating and passing this keyword argument; we provide StarFormationHistories.construct_x0 to prepare x0 assuming constant star formation rate, which is typically a good initial guess.\nfactr::Number: Keyword argument passed to LBFGSB.lbfgsb; essentially a relative tolerance for convergence based on the inter-iteration change in the objective function.\npgtol::Number: Keyword argument passed to LBFGSB.lbfgsb; essentially a relative tolerance for convergence based on the inter-iteration change in the projected gradient of the objective.\niprint::Integer: Keyword argument passed to LBFGSB.lbfgsb controlling how much information is printed to the terminal. Setting to 1 can sometimes be helpful to diagnose convergence issues. Setting to -1 will disable printing.\n\nOther kws... are passed to LBFGSB.lbfgsb.\n\nReturns\n\n-logL::Number: the minimum negative log-likelihood found by the optimizer.\ncoeffs::Vector{<:Number}: the maximum likelihood estimate for the coefficient vector. \n\nNotes\n\nIt can be helpful to normalize your models to contain realistic total stellar masses to aid convergence stability; for example, if the total stellar mass of your population is 10^7 solar masses, then you might normalize your templates to contain 10^3 solar masses. If you are using partial_cmd_smooth to construct the templates, you can specify this normalization via the normalize_value keyword. \n\n\n\n\n\nfit_templates_lbfgsb(models::AbstractMatrix{S},\n                     data::AbstractVector{<:Number};\n                     x0::AbstractVector{<:Number} = ones(S,size(models,2)),\n                     factr::Number=1e-12,\n                     pgtol::Number=1e-5,\n                     iprint::Integer=0,\n                     kws...) where S <: Number\n\nThis call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"This method simply minimizes the negative logarithm of the Poisson likelihood ratio (Equation 10 in Dolphin 2002),","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"- textln  mathscrL = sum_i m_i - n_i times left( 1 - textln  left( fracn_im_i right) right)","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where m_i is bin i of the complex model and n_i is bin i of the observed Hess diagram; this can therefore be thought of as computing the maximum likelihood estimate.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"We also provide StarFormationHistories.fit_templates_fast, which is the fastest method we offer for deriving a maximum likelihood estimate for the type of model described above.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.fit_templates_fast","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.fit_templates_fast","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.fit_templates_fast","text":"(coeffs::Vector{::eltype(x0)}, result::Optim.MultivariateOptimizationResults) =\nfit_templates_fast(models::AbstractVector{T},\n                   data::AbstractMatrix{<:Number};\n                   x0::AbstractVector{<:Number} = ones(S,length(models)),\n                   kws...)\n                   where {S <: Number, T <: AbstractMatrix{S}}\n\nFinds only the maximum likelihood estimate (MLE) for the coefficients coeffs given the provided data such that the best-fit composite Hess diagram model is sum(models .* coeffs). This is a simplification of the main fit_templates function, which will return the MLE as well as the maximum a posteriori estimate, and further supports uncertainty quantification. For additional details on arguments to this method, see the documentation for fit_templates. \n\nThis method optimizes parameters θ such that coeffs = θ.^2 – this allows for faster convergence than both the fit_templates_lbfgsb method, which does not use a variable transformation, and the logarithmic transformation used in fit_templates. However, the inverse Hessian is not useful for uncertainty estimation under this transformation. As such this method only returns the MLE for coeffs as a vector and the result object returned by Optim.optimize. While this method offers fewer features than fit_templates, this method's runtime is typically half as long (or less). As such, this method is recommended for use in performance-sensitive applications like hierarchical models or hyperparameter estimation where the additional features of fit_templates are unnecessary. In these applications, the value of the objective function at the derived MLE is typically desired as well; this can be obtained the from result::Optim.MultivariateOptimizationResults object as Optim.minimum(result). Note that this will return the negative loglikelihood, which is what is minimized in this application.\n\nNotes\n\nBy passing additional convergence keyword arguments supported by Optim.Options (see this guide), it is possible to converge to the MLE in fewer than 30 iterations with fewer than 100 calls to the likelihood and gradient methods. For example, the main convergence criterion is typically the magnitude of the gradient vector, which by default is g_abstol=1e-8, terminating the optimization when the magnitude of the gradient is less than 1e-8. We find results are typically sufficiently accurate with g_abstol=1e-3, which often uses half as many objective evaluations as the default value.\n\n\n\n\n\nfit_templates_fast(models::AbstractMatrix{S},\n                   data::AbstractVector{<:Number};\n                   x0::AbstractVector{<:Number} = ones(S,size(models,2)),\n                   kws...)\n                   where S <: Number\n\nThis call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/#Posterior-Sampling:-MCMC","page":"High-Level Methods for Unconstrained Fitting","title":"Posterior Sampling: MCMC","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"For low-dimensional problems, Markov Chain Monte Carlo (MCMC) methods can be an efficient way to sample the posterior and obtain uncertainty estimates on the fitting coefficients r_j. We provide StarFormationHistories.mcmc_sample for this purpose. Internally this uses the multi-threaded affine-invariant MCMC sampler from KissMCMC.jl to perform the sampling, which is based on the same algorithm as Python's emcee (specifically, their emcee.moves.StretchMove). There are other MCMC packages like AdvancedMH.jl that offer additional features like distributed execution. ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.mcmc_sample","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.mcmc_sample","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.mcmc_sample","text":"result::MCMCChains.Chains =\nmcmc_sample(models::AbstractVector{<:AbstractMatrix{T}},\n            data::AbstractMatrix{S},\n            x0::Union{AbstractVector{<:AbstractVector{<:Number}}, AbstractMatrix{<:Number}},\n            nwalkers::Integer,\n            nsteps::Integer;\n            nburnin::Integer=0,\n            nthin::Integer=1,\n            a_scale::Number=2.0,\n            use_progress_meter::Bool=true)\nmcmc_sample(models::AbstractMatrix{<:Number},\n            data::AbstractVector{<:Number},\n            args...; kws...)\n\nSamples the posterior of the coefficients coeffs such that the full model of the observational data is sum(models .* coeffs). Uses the Poisson likelihood ratio as defined by equations 7–10 of Dolphin 2002. Sampling is done using the affine-invariant MCMC sampler implemented in KissMCMC.jl, which is analogous to Python's emcee.moves.StretchMove. This method will automatically parallelize over threads. If you need distributed execution, you may want to look into AdvancedMH.jl.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nx0::Union{AbstractVector{<:AbstractVector{<:Number}}, AbstractMatrix{<:Number}} are the initial positions for the MCMC walkers. If providing a vector of vectors, it must be a vector of length nwalkers with each internal vector having length equal to length(models). You can alternatively provide a matrix of size (nwalkers, length(models)) or (length(models), nwalkers).\nnwalkers::Integer is the number of unique walkers or chains to use.\nnsteps::Integer is the number of steps evolve the walkers for.\n\nKeyword Arguments\n\nnburnin::Integer=0 is the number of steps to discard from the start of each chain.\nnthin::Integer=1 is the factor by which to thin the chain; walker positions will only be saved every nthin steps.\na_scale::Number=2.0 is the scale parameter for the stretch move; probably shouldn't need to be changed.\nuse_progress_Meter::Bool=true indicates whether or not to show a progress bar during the MCMC procedure.\n\nReturns\n\nresult is a MCMCChains.Chains instance which enables easy calculation of diagnostic and summary statistics. This type can be indexed and used like a 3-D array of samples with shape (nsteps, length(models), nwalkers).\n\nNotes\n\nWhen displaying result to the terminal it will display summary statistics (MCMCChains.summarystats) and quantiles (MCMCChains.quantile) by calling the MCMCChains.describe method. This can take a second but is nice to have as an option.\nThe highest posterior density interval, which is the narrowest credible interval that includes the posterior mode, can be calculated with the MCMCChains.hpd method. \nIf you want to extract the array of samples from the MCMCChains.Chains object, you can index result.value – this will return an AxisArray but can be converted to a normal array with Array(result.value).\n\nExamples\n\nimport Distributions: Poisson\ncoeffs = rand(10) # SFH coefficients we want to sample\nmodels = [rand(100,100) .* 100 for i in 1:length(coeffs)] # Vector of model Hess diagrams\ndata = rand.(Poisson.( sum(models .* coeffs) ) ) # Poisson-sample the model `sum(models .* coeffs)`\nnwalkers = 1000\nnsteps = 400\nx0 = rand(nwalkers, length(coeffs)) # Initial walker positions\nresult = mcmc_sample(models, data, x0, nwalkers, nsteps) # Sample\nChains MCMC chain (400×10×1000 Array{Float64, 3}) ...\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/#Posterior-Sampling:-Change-of-Variables-and-HMC","page":"High-Level Methods for Unconstrained Fitting","title":"Posterior Sampling: Change of Variables and HMC","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Dolphin 2013 examined methods for obtaining uncertainties on the fitted coefficients (the r_j in Equation 1 of Dolphin 2002) and found that the Hamiltonian Monte Carlo (HMC) approach allowed for relatively efficient sampling of the posterior distribution when considering many isochrones in the modelling process. HMC requires that the variables to be fit are continuous over the real numbers and so requires a change of variables. Rather than sampling the variables r_j directly, we can sample theta_j = textln left( r_j right) such that the sampled variables are continuous over the real numbers -infty  theta_j  infty while the r_j=textexp left( theta_j right) coefficients are bounded from 0  r_j  infty. Using a logarithmic transformation has the additional benefit that the gradient of the Poisson likelihood ratio is still continuous and easy to compute analytically.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"While maximum likelihood estimates are invariant under variable transformations, sampling methods like HMC are not, as formally the posterior being sampled from is a distribution and therefore must be integrable over the sampling coefficients. We can write the posterior from which we wish to sample as","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\np(r_j  D) = fracp(D  r_j)  p(r_j)Z \np(boldsymbolr  D) = frac1Z  prod_j p(D  r_j)  p(r_j) \n-textln  p(boldsymbolr  D) = textln  Z - sum_j  textln  p(D  r_j) + textln  p(r_j) \n= textln  Z - textln  mathscrL + sum_j textln  p(r_j)\nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where Z is the Bayesian evidence (a constant that can be neglected for sampling methods), p left( r_j right) is the prior on the star formation history, and mathscrL is the Poisson likelihood ratio discussed above. An uninformative (and unnormalized) prior on the coefficients r_j could take the form of","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"p(r_j) = begincases\n1  r_j geq 0\n0  r_j  0\nendcases","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"such that, if the coefficients r_j are guaranteed to be positive, the final term becomes zero (since textln(1)=0) and","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"-textln  p(boldsymbolr  D) = textln  Z - textln  mathscrL","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"When sampling with methods like HMC, constants like textln  Z can be neglected and -textln  p(boldsymbolr  D) propto - textln  mathscrL such that the posterior is approximated by the likelihood surface.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Let us consider now what happens when we wish to do a variable transformation from r_j to theta_j = textln (r_j). From above we can write the posterior as","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"p(r_j  D) = fracp(D  r_j)  p(r_j)Z ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Under the change of variables formula we can write","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\np(theta_j  D) = p(r_j  D) left fracd r_jd theta_j right \n= p(r_j  D) left fracd theta_jd r_j right^-1\nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where left fracd theta_jd r_j right^-1 is often called the Jacobian correction. We choose theta_j such that","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\ntheta_j = textln ( r_j ) \nleft fracd theta_jd r_j right = frac1r_j \nr_j = textexp (theta_j) \nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"which leads to a posterior of","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"p(theta_j  D) = textexp (theta_j) times p(textexp (theta_j)  D) = r_j times p(r_j  D) ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"We can then write the product over the theta_j as","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"beginaligned\np(boldsymboltheta  D) = frac1Z  prod_j r_j  p(D  r_j)  p(r_j) \n-textln  p(boldsymboltheta  D) = textln  Z - sum_j textln  (r_j) + textln  p(D  r_j) + textln  p(r_j) \n= textln  Z - sum_j textln  p(D  r_j) + textln  p(r_j) - sum_j theta_j \n= -textln  p(boldsymbolr  D) - sum_j theta_j \n= -textln  p(boldsymbolr  D) - sum_j textln  (r_j)\nendaligned","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"The choice of a logarithmic transformation means that the negative logarithm of the posterior (which is what HMC uses for its objective function) has this very simple form which allows for simple analytic gradients as well. Once samples of theta have been obtained from this distribution via HMC or any other sampling method, they can be directly transformed back to the standard coefficients r_j = textexp(theta_j).","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"The method hmc_sample implements this approach for sampling the theta_j coefficients; these samples can then be used to estimate random uncertainties on the derived star formation history.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.hmc_sample","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.hmc_sample","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.hmc_sample","text":"hmc_sample(models::AbstractVector{T},\n           data::AbstractMatrix{<:Number},\n           nsteps::Integer [, nchains::Integer];\n           rng::Random.AbstractRNG=Random.default_rng(),\n           kws...)\n           where {S <: Number, T <: AbstractMatrix{S}}\nhmc_sample(models::AbstractMatrix{S},\n           data::AbstractVector{<:Number},\n           nsteps::Integer;\n           rng::AbstractRNG=default_rng(),\n           kws...)\n           where S <: Number\n\nFunction to sample the posterior of the coefficients coeffs such that the full model of the observational data is sum(models .* coeffs). Uses the Poisson likelihood ratio as defined by equations 7–10 of Dolphin 2002 along with a logarithmic transformation of the coeffs so that the fitting variables are continuous and differentiable over all reals. Sampling is done using the No-U-Turn sampler as implemented in DynamicHMC.jl, which is a form of dynamic Hamiltonian Monte Carlo.\n\nThe second call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\nArguments\n\nmodels::AbstractVector{<:AbstractMatrix{<:Number}} is a vector of equal-sized matrices that represent the template Hess diagrams for the simple stellar populations that compose the observed Hess diagram.\ndata::AbstractMatrix{<:Number} is the Hess diagram for the observed data.\nnsteps::Integer is the number of samples to draw per chain.\n\nOptional Arguments\n\nnchains::Integer: If this argument is not provided, this method will return a single chain. If this argument is provided, it will sample nchains chains using all available Julia threads and will return a vector of the individual chains.\n\nKeyword Arguments\n\nrng::Random.AbstractRNG is the random number generator that will be passed to DynamicHMC.jl. If nchains is provided this method will attempt to sample in parallel, requiring a thread-safe rng such as that provided by Random.default_rng(). \n\nAll other keyword arguments kws... will be passed to DynamicHMC.mcmc_with_warmup or DynamicHMC.mcmc_keep_warmup depending on whether nchains is provided.\n\nReturns\n\nIf nchains is not provided, returns a NamedTuple as summarized in DynamicHMC.jl's documentation. In short, the matrix of samples can be extracted and transformed as exp.( result.posterior_matrix ). Statistics about the chain can be obtained with DynamicHMC.Diagnostics.summarize_tree_statistics(result.tree_statistics); you want to see a fairly high acceptance rate (>0.5) and the majority of samples having termination criteria being \"turning.\" See DynamicHMC.jl's documentation for more information.\nIf nchains is provided, returns a vector of length nchains of the same NamedTuples described above. The samples from each chain in the returned vector can be stacked to a single (nsamples, nchains, length(models)) matrix with DynamicHMC.stack_posterior_matrices(result). \n\nExamples\n\nimport DynamicHMC\nimport StatFormationHistories: hmc_sample\nimport Statistics: mean\n# Run sampler using progress meter to monitor progress\n# assuming you have constructed some templates `models` and your observational Hess diagram `data`\nresult = hmc_sample( models, data, 1000; reporter=DynamicHMC.ProgressMeterReport())\n# The chain values are stored in result.posterior matrix; extract them with `result.posterior_matrix`\n# An exponential transformation is needed since the optimization internally uses a logarithmic \n# transformation and samples log(θ) rather than θ directly. \nmc_matrix = exp.( result.posterior_matrix )\n# We can look at some statistics from the chain; want to see high acceptance rate (>0.5) and large % of\n# \"turning\" for termination criteria. \nDynamicHMC.Diagnostics.summarize_tree_statistics(result.tree_statistics)\n    Hamiltonian Monte Carlo sample of length 1000\n      acceptance rate mean: 0.92, 5/25/50/75/95%: 0.65 0.88 0.97 1.0 1.0\n      termination: divergence => 0%, max_depth => 0%, turning => 100%\n      depth: 0 => 0%, 1 => 64%, 2 => 36%\n# mc_matrix has size `(length(models), nsteps)` so each column is an independent\n# sample of the SFH as defined by the coefficients and the rows contain the samples\n# for each parameter. \nmstar_tot = sum.(eachcol(mc_matrix)) # Total stellar mass of the modelled system per sample\nmc_means = mean.(eachrow(mc_matrix)) # Mean of each coefficient evaluated across all samples\n# Example with multiple chains sampled in parallel via multi-threading\nimport Threads\nt_result = hmc_sample( models, data, 1000, Threads.nthreads(); reporter=DynamicHMC.ProgressMeterReport())\n# Combine the multiple chains into a single matrix and transform\n# Can then use the same way as `mc_matrix` above\nmc_matrix = exp.( DynamicHMC.pool_posterior_matrices(t_result) )\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"See the DynamicHMC.jl documentation for more information on how to use the chains that are output by this method.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Inspection of the samples generated by hmc_sample shows that the posterior defined by the above model is typically smooth, well-behaved, and unimodal. In particular, we find that the sampled r_j for coefficients that are non-zero in the MLE are approximately Gaussian distributed while the logarithms of the sampled r_j are roughly Gaussian distributed for coefficients that are zero in the MLE; i.e.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"begincases\nX_j sim mathcalN  hat r_j  0 \ntextln left( X_j right) sim mathcalN  hat r_j = 0 \nendcases","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"where X_j are the samples of r_j obtained from the posterior and hat r_j is the maximum likelihood estimate of r_j. ","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"This indicates we may be able to approximate the posterior in the region surrounding the maximum a posteriori (MAP) value by the inverse of the Hessian matrix (see, e.g., Dovi et al. 1991), allowing us to estimate parameter uncertainties very cheaply. The inverse of the Hessian matrix is exactly equal to the variance-covariance matrix of the parameters for a Gaussian probability distribution; for other probability distributions, the inverse of the Hessian approximates the variance-covariance matrix of the parameters when the second-order expansion defined by the Hessian at the maximum is a reasonable approximation to the real objective function being optimized. A particularly simple form arises when the logarithm of the objective is quadratic in the fitting parameters, as in the Gaussian case, because the second derivatives of the objective are constant and do not depend on the fitting parameters or the MAP estimate.","category":"page"},{"location":"fitting/unconstrained/#Maximum-a-Posteriori-Optimization","page":"High-Level Methods for Unconstrained Fitting","title":"Maximum a Posteriori Optimization","text":"","category":"section"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Direct computation of the Hessian and its inverse is expensive, so we'd like another way to obtain it. The first-order, quasi-Newton BFGS optimization algorithm provides such a method as it iteratively builds a dense approximation to the inverse Hessian using the change in the gradient of the objective, which we can compute analytically. It is, however, much less memory efficient than the LBFGS algorithm we use in StarFormationHistories.fit_templates_lbfgsb. For moderate isochrone grids up to a few hundred model templates, this is not a problem. Beyond this it may be better to use StarFormationHistories.fit_templates_lbfgsb to obtain the MLE and hmc_sample to obtain posterior samples.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"We implement this optimization scheme in fit_templates, which is our recommended method for unconstrained SFH fitting (i.e., direct fitting of the r_j coefficients). See the next section for notes on more complicated, hierarchical models that can incorporate features like metallicity distribution functions.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.fit_templates\nStarFormationHistories.LogTransformFTResult","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.fit_templates","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.fit_templates","text":"result = fit_templates(models::AbstractVector{T},\n                       data::AbstractMatrix{<:Number};\n                       x0::AbstractVector{<:Number} = ones(S,length(models)),\n                       kws...) where {S <: Number, T <: AbstractMatrix{S}}\n\nFinds both maximum likelihood estimate (MLE) and maximum a posteriori estimate (MAP) for the coefficients coeffs such that the composite Hess diagram model is sum(models .* coeffs) using the provided templates models and the observed Hess diagram data. Utilizes the Poisson likelihood ratio (equations 7–10 in Dolphin 2002) for the likelihood of the data given the model. See the examples in the documentation for comparisons of the results of this method and hmc_sample which samples the posterior via Hamiltonian Monte Carlo. \n\nArguments\n\nmodels::AbstractVector{AbstractMatrix{<:Number}}: the list of template Hess diagrams for the simple stellar populations (SSPs) being considered; all must have the same size.\ndata::AbstractMatrix{<:Number}: the observed Hess diagram; must match the size of the templates contained in models.\n\nKeyword Arguments\n\nx0: The vector of initial guesses for the stellar mass coefficients. You should basically always be calculating and passing this keyword argument; we provide StarFormationHistories.construct_x0 to prepare x0 assuming constant star formation rate, which is typically a good initial guess.\n\nOther kws... are passed to Optim.options to set things like convergence criteria for the optimization. \n\nReturns\n\nresult is a NamedTuple containing two StarFormationHistories.LogTransformFTResult. The two components of result are result.map or result[1], which contains the results of the MAP optimization, and result.mle or result[2], which contains the results of the MLE optimization. The documentation for StarFormationHistories.LogTransformFTResult contains more information about these types, but briefly they contain the following fields, accessible as, e.g., result.map.μ, result.map.σ, etc.:\n\nμ::Vector{<:Number} are the optimized coeffs at the maximum.\nσ::Vector{<:Number} are the standard errors on the coeffs μ calculated from an estimate of the inverse Hessian matrix evaluated at μ. The inverse of the Hessian matrix at the maximum of the likelihood (or posterior) is a estimator for the variance-covariance matrix of the parameters, but is only accurate when the second-order expansion given by the Hessian at the maximum is a good approximation to the function being optimized (i.e., when the optimized function is approximately quadratic around the maximum; see Dovi et al. 1991 for more information). We find this is often the case for the MAP estimate, but the errors found for coefficients that are ≈0 in the MLE are typically unrealistically small. For coefficients significantly greater than 0, the σ values from the MAP and MLE are typically consistent to 5–10%.\ninvH::Matrix{<:Number} is the estimate of the inverse Hessian matrix at μ that was used to derive σ. The optimization is done under a logarithmic transform, such that θ[j] = log(coeffs[j]) are the actual parameters optimized, so the entries in the Hessian are actually\n\nH^(jk) ( boldsymbolhat theta ) = left fracpartial^2  J(boldsymboltheta)partial theta_j  partial theta_k rightvert_boldsymboltheta=boldsymbolhat theta\n\nresult is the full object returned by the optimization from Optim.jl; this is of type Optim.MultivariateOptimizationResults. Remember that the optimization is done with parameters θ[j] = log(coeffs[j]) when dealing with this raw output. This means that, for example, we calculate result.map.μ as exp.(Optim.minimizer(result.map.result)).\n\nThe special property of the StarFormationHistories.LogTransformFTResult type is that you can draw a set of N::Integer random parameter samples from the result using the inverse Hessian approximation discussed above by doing rand(result.map, N). This type implements the random sampling API of Distributions.jl so the other standard sampling methods should work as well. In our tests these samples compare very favorably against those from hmc_sample, which samples the posterior via Hamiltonian Monte Carlo and is therefore more robust but much more expensive. We compare these methods in the examples.\n\nNotes\n\nThis method uses the BFGS method from Optim.jl internally because it builds and tracks the inverse Hessian matrix approximation which can be used to estimate parameter uncertainties. BFGS is much more memory-intensive than LBFGS (as used for StarFormationHistories.fit_templates_lbfgsb) for large numbers of parameters (equivalently, many models), so you should consider LBFGS to solve for the MLE along with hmc_sample to sample the posterior if you are using a large grid of models (greater than a few hundred).\nThe BFGS implementation we use from Optim.jl uses BLAS operations during its iteration. The OpenBLAS that Julia ships with will often default to running on multiple threads even if Julia itself is started with only a single thread. You can check the current number of BLAS threads with import LinearAlgebra: BLAS; BLAS.get_num_threads(). For the problem sizes typical of this function we actually see performance regression with larger numbers of BLAS threads. For this reason you may wish to use BLAS in single-threaded mode; you can set this as import LinearAlgebra: BLAS; BLAS.set_num_threads(1).\n\n\n\n\n\nfit_templates(models::AbstractMatrix{S},\n              data::AbstractVector{<:Number};\n              x0::AbstractVector{<:Number} = ones(S,length(models)),\n              kws...) where S <: Number\n\nThis call signature supports the flattened formats for models and data. See the notes for the flattened call signature of StarFormationHistories.composite! for more details.\n\n\n\n\n\n","category":"function"},{"location":"fitting/unconstrained/#StarFormationHistories.LogTransformFTResult","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.LogTransformFTResult","text":"LogTransformFTResult(μ::AbstractVector{<:Number},\n                     σ::AbstractVector{<:Number},\n                     invH::AbstractMatrix{<:Number},\n                     result)\n\nType for containing the maximum likelihood estimate (MLE) and maximum a posteriori (MAP) results from fit_templates. The fitted coefficients are available in the μ field. Estimates of the standard errors are available in the σ field. These have both been transformed from the native logarithmic fitting space into natural units (i.e., stellar mass or star formation rate).\n\ninvH contains the estimated inverse Hessian of the likelihood / posterior at the maximum point in the logarithmic fitting units. result is the full result object returned by the optimization routine.\n\nThis type is implemented as a subtype of Distributions.Sampleable{Multivariate, Continuous} to enable sampling from an estimate of the likelihood / posterior distribution. We approximate the distribution as a multivariate Gaussian in the native (logarithmically transformed) fitting variables with covariance matrix invH and means log.(μ). We find this approximation is good for the MAP result but less robust for the MLE. You can obtain N::Integer samples from the distribution by rand(R, N) where R is an instance of this type; this will return a size length(μ) x N matrix, or fail if invH is not positive definite.\n\nExamples\n\njulia> result = fit_templates(models, data);\n\njulia> typeof(result.map)\nStarFormationHistories.LogTransformFTResult{...}\n\njulia> size(rand(result.map, 3)) == (length(models),3)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"Once you have obtained stellar mass coefficients from the above methods, you can convert them into star formation rates and compute per-age mean metallicities with StarFormationHistories.calculate_cum_sfr.","category":"page"},{"location":"fitting/unconstrained/","page":"High-Level Methods for Unconstrained Fitting","title":"High-Level Methods for Unconstrained Fitting","text":"StarFormationHistories.calculate_cum_sfr","category":"page"},{"location":"fitting/unconstrained/#StarFormationHistories.calculate_cum_sfr","page":"High-Level Methods for Unconstrained Fitting","title":"StarFormationHistories.calculate_cum_sfr","text":"(unique_logAge, cum_sfh, sfr, mean_MH) =\n    calculate_cum_sfr(coeffs::AbstractVector,\n                      logAge::AbstractVector,\n                      MH::AbstractVector,\n                      T_max::Number;\n                      normalize_value=1,\n                      sorted::Bool=false)\n\nCalculates cumulative star formation history, star formation rates, and mean metallicity evolution as functions of logAge = log10(age [yr]).\n\nArguments\n\ncoeffs::AbstractVector is a vector of stellar mass coefficients such as those returned by fit_templates, for example. Actual stellar mass in stellar population j is coeffs[j] * normalize_value.\nlogAge::AbstractVector is a vector giving the log10(age [yr]) of the stellar populations corresponding to the provided coeffs. For the purposes of calculating star formation rates, these are assumed to be left-bin edges.\nMH::AbstractVector is a vector giving the metallicities of the stellar populations corresponding to the provided coeffs.\nT_max::Number is the rightmost final bin edge for calculating star formation rates. For example, you might have logAge=[6.6, 6.7, 6.8] in which case a final logAge of 6.9 would give equal bin widths. In this case you would set T_max = exp10(6.9) / 1e9 ≈ 0.0079 so that the width of the final bin for the star formation rate calculation has the same log10(Age [yr]) step as the other bins.\n\nKeyword Arguments\n\nnormalize_value is a multiplicative prefactor to apply to all the coeffs; same as the keyword in partial_cmd_smooth.\nsorted::Bool is either true or false and signifies whether to assume logAge is sorted.\n\nReturns\n\nunique_logAge::Vector is essentially unique(sort(logAge)) and provides the x-values you would plot the other returned vectors against.\ncum_sfh::Vector is the normalized cumulative SFH implied by the provided coeffs. This is ~1 at the most recent time in logAge and decreases as logAge increases.\nsfr::Vector gives the star formation rate across each bin in unique_logAge. If coeffs .* normalize_value are in units of solar masses, then sfr is in units of solar masses per year.\nmean_MH::Vector gives the stellar-mass-weighted mean metallicity of the stellar population as a function of unique_logAge. \n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We have constructed an example Jupyter notebook that highlights some common use cases supported by the package. It is recommended that you read some of the background in our main documentation before or concurrently with the example. The notebook is available in the repository as examples/fitting1.ipynb and can be viewed in rendered form at this link. It relies on a custom isochrone file which can be made available upon request to the package author.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are other scripts in the examples directory of the source repository that are used to generate figures for the documentation and provide more targeted examples of usage.","category":"page"},{"location":"#overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package enables many different kinds of analysis related to astrophysical star formation histories (SFHs). Core among these functionalities are generation of mock color-magnitude diagrams (CMDs) from input SFHs and fitting of SFHs from observed CMDs. The methods of this package have been designed to be simple to use but easy to extend. It is recommended that you use this package in conjunction with InitialMassFunctions.jl which provides implementations of the most popular stellar initial mass functions as new types which are natively supported by this package's methods.","category":"page"}]
}
