<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · StarFormationHistories.jl</title><meta name="title" content="Overview · StarFormationHistories.jl"/><meta property="og:title" content="Overview · StarFormationHistories.jl"/><meta property="twitter:title" content="Overview · StarFormationHistories.jl"/><meta name="description" content="Documentation for StarFormationHistories.jl."/><meta property="og:description" content="Documentation for StarFormationHistories.jl."/><meta property="twitter:description" content="Documentation for StarFormationHistories.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">StarFormationHistories.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Overview</a></li><li><span class="tocitem">Deriving Star Formation Histories from Hess Diagrams</span><ul><li><a class="tocitem" href="../../fitting_intro/">Background and Template Construction</a></li><li><a class="tocitem" href="../../unconstrained/">High-Level Methods for Unconstrained Fitting</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox" checked/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Metallicity Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Generic-Methods"><span>Generic Methods</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3-2" type="checkbox"/><label class="tocitem" for="menuitem-2-3-2"><span class="docs-label">AMRs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linear_amr/">Linear Age-Metallicity Relation</a></li><li><a class="tocitem" href="../log_amr/">Logarithmic Age-Metallicity Relation</a></li><li><a class="tocitem" href="../fixed_amr/">Fixed Age-Metallicity Relations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3-3"><span class="docs-label">MZRs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../MZR/MZR/">Mass-Metallicity Relations (MZRs)</a></li></ul></li><li><a class="tocitem" href="../dispersion_models/">Metallicity Dispersion Models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/">Low-Level Functions</a></li><li><a class="tocitem" href="../../kernels/">Kernels</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../examples/">Examples</a></li><li><a class="tocitem" href="../../../simulate/">Simulating Color-Magnitude Diagrams</a></li><li><a class="tocitem" href="../../../binaries/">Binary Systems</a></li><li><a class="tocitem" href="../../../helpers/">Helper Functions</a></li><li><a class="tocitem" href="../../../release-notes/">Changelog</a></li><li><a class="tocitem" href="../../../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Deriving Star Formation Histories from Hess Diagrams</a></li><li><a class="is-disabled">Constrained Metallicity Evolution</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cgarling/StarFormationHistories.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cgarling/StarFormationHistories.jl/blob/main/docs/src/fitting/hierarchical/overview.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="metal_evo_intro"><a class="docs-heading-anchor" href="#metal_evo_intro">Overview</a><a id="metal_evo_intro-1"></a><a class="docs-heading-anchor-permalink" href="#metal_evo_intro" title="Permalink"></a></h1><p>Why should the metallicity evolution be constrained? While the above methods work well for optimizing the per-template <span>$r_j$</span> as a means for fitting SFHs, these methods can produce metallicity evolutions that could be considered unphysical, with large changes in the mean metallicity over small changes in time. An example of this type of behavior is shown in the SFH fit below.</p><p><img src="../figures/mean_mh.png" alt="Example of a SFH fit with variations in the metallicity evolution."/></p><p>While some metallicity variation in the star-forming gas is to be expected, these variations in the SFH fit can end up being quite large depending on the data and isochrone grid adopted. A solution is to construct a more physically-motivated model.</p><p>We can do this using a hierarchical model with a parameterized metallicity evolution where the the <span>$r_j$</span> are not the parameters directly optimized. Rather, we can optimize one stellar mass (or star formation rate) parameter per age bin, and then a number of metallicity evolution parameters that determine how that stellar mass is split between models with different metallicities at fixed age.</p><p>In most star formation history analyses, the metallicities are constrained through <em>age-metallicity relations (AMRs)</em>, where the mean metallicity at time <span>$t$</span> is a function of time and a small set of metallicity evolution parameters. A popular AMR model is the linear age-metallicity relation <span>$\langle [\text{M}/\text{H}] \rangle (t) = \alpha \, \left( T_\text{max} - t \right) + \beta$</span> with a Gaussian distribution in metallicity at fixed age. <span>$T_\text{max}$</span> here is the earliest lookback time under consideration such that <span>$\langle [\text{M}/\text{H}] \rangle (T_\text{max}) = \beta$</span>. This model is described in more detail <a href="../linear_amr/#linear_amr_section">here</a>.</p><p>AMRs have historically been popular because they are generally capable of producing reasonable fits to observed data and it is relatively easy to derive the gradient of the objective function with respect to the AMR parameters analytically. However, in AMR models there is no direct link between the SFRs being fit and the metallicity evolution as a function of time, even though the two should in principle have some correlation as stellar processes are responsible for enriching the ISM.</p><p>A promising avenue of research involves fitting <em>mass-metallicity relations</em> (MZRs) rather than AMRs. In these models, the mean metallicity of stars forming at time <span>$t$</span> is a function of the total stellar mass of the population at that time – therefore, the mean metallicity evolution changes self-consistently with the SFRs during the fitting process, resulting in a metallicity evolution that is meaningfully coupled to the star formation history. Additionally, AMRs can be difficult to compare between different galaxies because they do not reflect the different SFHs of the galaxies, whereas MZRs can be compared between galaxies much more easily. Our methods for MZR fitting are described in more detail <a href="../MZR/MZR/#MZR">here</a>.</p><h2 id="Generic-Methods"><a class="docs-heading-anchor" href="#Generic-Methods">Generic Methods</a><a id="Generic-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Methods" title="Permalink"></a></h2><p>While there are some methods in this package that are unique to AMR or MZR models, we present a minimal unified interface that can be used to fit SFHs under both types of models. To support multiple dispatch, we define <a href="#StarFormationHistories.AbstractMetallicityModel"><code>AbstractMetallicityModel</code></a> as the abstract supertype of <a href="../linear_amr/#StarFormationHistories.AbstractAMR"><code>AbstractAMR</code></a> and <a href="../MZR/MZR/#StarFormationHistories.AbstractMZR"><code>AbstractMZR</code></a>, which are each the supertypes for AMR and MZR types, respectively.</p><article><details class="docstring" open="true"><summary id="StarFormationHistories.AbstractMetallicityModel"><a class="docstring-binding" href="#StarFormationHistories.AbstractMetallicityModel"><code>StarFormationHistories.AbstractMetallicityModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>AbstractMetallicityModel{T &lt;: Real}</code> is the abstract supertype for all hierarchical metallicity models. Abstract subtypes are <a href="../linear_amr/#StarFormationHistories.AbstractAMR"><code>AbstractAMR</code></a> for age-metallicity relations and <a href="../MZR/MZR/#StarFormationHistories.AbstractMZR"><code>AbstractMZR</code></a> for mass-metallicity relations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/hierarchical_models.jl#L3">source</a></section></details></article><p>The generic methods that can be used for both AMRs and MZRs are described here. The main method for obtaining best-fit star formation histories is <a href="#StarFormationHistories.fit_sfh"><code>fit_sfh</code></a>.</p><article><details class="docstring" open="true"><summary id="StarFormationHistories.fit_sfh"><a class="docstring-binding" href="#StarFormationHistories.fit_sfh"><code>StarFormationHistories.fit_sfh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_sfh(MH_model0::AbstractMetallicityModel,
        disp_model0::AbstractDispersionModel,
        models::AbstractMatrix{&lt;:Number},
        data::AbstractVector{&lt;:Number},
        logAge::AbstractVector{&lt;:Number},
        metallicities::AbstractVector{&lt;:Number};
        x0::AbstractVector{&lt;:Number} = &lt;...&gt;
        kws...)
fit_sfh(MH_model0::AbstractMetallicityModel,
        disp_model0::AbstractDispersionModel,
        models::AbstractVector{&lt;:AbstractMatrix{&lt;:Number}},
        data::AbstractMatrix{&lt;:Number},
        logAge::AbstractVector{&lt;:Number},
        metallicities::AbstractVector{&lt;:Number};
        x0::AbstractVector{&lt;:Number} = &lt;...&gt;
        kws...)</code></pre><p>Returns a <a href="#StarFormationHistories.CompositeBFGSResult"><code>CompositeBFGSResult</code></a> instance that contains the maximum a posteriori (MAP) and maximum likelihood estimates (MLE) obtained from fitting the provided simple stellar population (SSP) templates <code>models</code> (with logarithmic ages <code>logAge = log10(age [yr])</code> and metallicities <code>metallicities</code>) to the provided <code>data</code>. The metallicity evolution is modelled using the provided <code>MH_model0</code>, whose parameters can be free or fixed, with metallicity dispersion at fixed time modelled by <code>disp_model0</code>, whose parameters can be free or fixed.</p><p>This method is designed to work best with a grid of stellar models, defined by the outer product of <code>N</code> unique entries in <code>logAge</code> and <code>M</code> unique entries in <code>metallicities</code>. See the examples for more information on usage.</p><p>We provide several options for age-metallicity relations and mass-metallicity relations that can be used for <code>MH_model0</code> and define APIs for users to create new models that will integrate with this function. Similar flexibility is allowed for the metallicity dispersion model <code>disp_model0</code>.</p><p>The primary method signature uses flattened formats for <code>models</code> and <code>data</code>. See the notes for the flattened call signature of <a href="../../internals/#StarFormationHistories.composite!"><code>StarFormationHistories.composite!</code></a> for more details, as well as <a href="../../fitting_intro/#StarFormationHistories.stack_models"><code>stack_models</code></a> that facilitates rearranging the <code>models</code> into this flattened format.</p><p><strong>Arguments</strong></p><ul><li><code>MH_model0</code> is an instance of <a href="#StarFormationHistories.AbstractMetallicityModel"><code>AbstractMetallicityModel</code></a> that defines how the average metallicity stars being formed in the population changes over time. The fittable parameters contained in this instance are used as the initial values to start the optimization. </li><li><code>disp_model0</code> is an instance of <a href="../dispersion_models/#StarFormationHistories.AbstractDispersionModel"><code>AbstractDispersionModel</code></a> that defines the distribution of metallicities of stars forming in a fixed time bin (i.e., the dispersion in metallicity around the mean at fixed time). The fittable parameters contained in this instance are used as the initial values to start the optimization. </li><li><code>models</code> are the template Hess diagrams for the SSPs that compose the observed Hess diagram.</li><li><code>data</code> is the Hess diagram for the observed data.</li><li><code>logAge::AbstractVector{&lt;:Number}</code> is the vector containing the effective ages of the stellar populations used to create the templates in <code>models</code>, in units of <code>log10(age [yr])</code>. For example, if a population has an age of 1 Myr, its entry in <code>logAge</code> should be <code>log10(10^6) = 6.0</code>.</li><li><code>metallicities::AbstractVector{&lt;:Number}</code> is the vector containing the effective metallicities of the stellar populations used to create the templates in <code>models</code>. These should be logarithmic abundances like [M/H] or [Fe/H]. There are some notes on the <a href="https://en.wikipedia.org/wiki/Metallicity">Wikipedia</a> that might be useful.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>x0</code> is the vector of initial guesses for the stellar mass coefficients per <em>unique</em> entry in <code>logAge</code>. We try to set reasonable defaults, but in most cases users should be calculating and passing this keyword argument. We provide <a href="../linear_amr/#StarFormationHistories.construct_x0_mdf"><code>StarFormationHistories.construct_x0_mdf</code></a> to prepare <code>x0</code> assuming a constant star formation rate and total stellar mass, which is typically a good initial guess.</li><li><code>kws...</code> are passed to <code>Optim.Options</code> and can be used to control tolerances for convergence.</li></ul><p><strong>Returns</strong></p><ul><li>This function returns a <a href="#StarFormationHistories.CompositeBFGSResult"><code>CompositeBFGSResult</code></a> that contains the output from both MLE and MAP optimizations, accessible via <code>result.mle</code> and <code>result.map</code>. These are each instances of <a href="#StarFormationHistories.BFGSResult"><code>BFGSResult</code></a>. See the docs for these structs for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/generic_fitting.jl#L201-L241">source</a></section></details></article><p>This function returns an instance of <a href="#StarFormationHistories.CompositeBFGSResult"><code>CompositeBFGSResult</code></a>.</p><article><details class="docstring" open="true"><summary id="StarFormationHistories.CompositeBFGSResult"><a class="docstring-binding" href="#StarFormationHistories.CompositeBFGSResult"><code>StarFormationHistories.CompositeBFGSResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompositeBFGSResult(map::BFGSResult, mle::BFGSResult)</code></pre><p>Type for containing the maximum a posteriori (MAP) <em>AND</em> maximum likelihood estimate (MLE) results from BFGS optimizations that use Optim.jl, which are individually accessible via the <code>:mle</code> and <code>:map</code> properties (i.e., for an instance of this type <code>t</code>, <code>t.mle</code> or <code>getproperty(t, :mle)</code> and <code>t.map</code> or <code>getproperty(t, :map)</code>).</p><p>Random samples can be drawn from an instance <code>t</code> as <code>rand(t, N::Integer)</code>. This will return a size <code>length(μ) x N</code> matrix. This will use the MLE result for the best-fit values and the inverse Hessian approximation to the covariance matrix from the MAP result, which is more robust when best-fit values that are constrained to be positive approach 0.</p><p>Per-SSP coefficients can be calculated with <code>calculate_coeffs(result::CompositeBFGSResult, logAge::AbstractVector{&lt;:Number}, metallicities::AbstractVector{&lt;:Number})</code>, which uses the MLE result (see <a href="#StarFormationHistories.calculate_coeffs">these docs</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/bfgs_result.jl#L94-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StarFormationHistories.BFGSResult"><a class="docstring-binding" href="#StarFormationHistories.BFGSResult"><code>StarFormationHistories.BFGSResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BFGSResult(μ::AbstractVector{&lt;:Number},
           σ::AbstractVector{&lt;:Number},
           invH::AbstractMatrix{&lt;:Number},
           result,
           MH_model::AbstractMetallicityModel,
           disp_model::AbstractDispersionModel)</code></pre><p>Type for containing the maximum likelihood estimate (MLE) <em>or</em> maximum a posteriori (MAP) results from BFGS optimizations that use Optim.jl. Fields are as follows:</p><ul><li><code>μ</code> contains the final values of the fitting parameters. The <code>mode</code> and <code>median</code> methods will both return <code>μ</code>, but the mean of samples is not always equal to <code>μ</code> due to the variable transformations we perform.</li><li><code>σ</code> contains the standard errors estimated for the parameters and is returned by the <code>std</code> method.</li><li><code>invH</code> is the BFGS approximation to the inverse Hessian, which is an estimator for the covariance matrix of the parameters if the objective function is approximately Gaussian near the best-fit <code>μ</code>.</li><li><code>result</code> is the full result object returned by Optim.jl.</li><li><code>MH_model</code> is the best-fit metallicity model.</li><li><code>disp_model</code> is the best-fit metallicity dispersion model.</li></ul><p>This type is implemented as a subtype of <code>Distributions.Sampleable{Multivariate, Continuous}</code> to enable sampling from an estimate of the likelihood / posterior distribution constructed from the <code>invH</code>. You can obtain <code>N::Integer</code> samples from the distribution with <code>rand(R, N)</code> where <code>R</code> is an instance of this type. This will return a size <code>length(μ) x N</code> matrix.</p><p>You can also directly obtain the per-SSP template coefficients (<span>$r_{j,k}$</span> in the <a href="../MZR/MZR/#mzr_derivation">derivation</a>) using the optimization results stored in a <code>BFGSResult</code> with <a href="#StarFormationHistories.calculate_coeffs"><code>calculate_coeffs</code></a>.</p><p><strong>See also</strong></p><ul><li><a href="#StarFormationHistories.CompositeBFGSResult"><code>CompositeBFGSResult</code></a> is a type that contains two instances of <code>BFGSResult</code>, one for the MAP and one for the MLE.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/bfgs_result.jl#L1-L24">source</a></section></details></article><p>This can be used to obtain random samples under a multivariable Normal approximation to the posterior or used to initialize a Hamiltonian Monte Carlo (HMC) sampling process to obtain more accurate posterior samples with <a href="#StarFormationHistories.sample_sfh"><code>sample_sfh</code></a> and its multi-threaded alternative <a href="#StarFormationHistories.tsample_sfh"><code>tsample_sfh</code></a>.</p><article><details class="docstring" open="true"><summary id="StarFormationHistories.sample_sfh"><a class="docstring-binding" href="#StarFormationHistories.sample_sfh"><code>StarFormationHistories.sample_sfh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sample_sfh(bfgs_result::CompositeBFGSResult, 
           models::AbstractMatrix{&lt;:Number},
           data::AbstractVector{&lt;:Number},
           logAge::AbstractVector{&lt;:Number},
           metallicities::AbstractVector{&lt;:Number},
           Nsteps::Integer;
           ϵ::Real = 0.05, # HMC step size
           reporter = DynamicHMC.ProgressMeterReport(),
           show_convergence::Bool = true,
           rng::AbstractRNG = default_rng())
sample_sfh(bfgs_result::CompositeBFGSResult, 
           models::AbstractVector{&lt;:AbstractMatrix{&lt;:Number}},
           data::AbstractMatrix{&lt;:Number},
           logAge::AbstractVector{&lt;:Number},
           metallicities::AbstractVector{&lt;:Number},
           Nsteps::Integer;
           kws...)</code></pre><p>Takes the SFH fitting result in <code>bfgs_result</code> and uses it to initialize the Hamiltonian Monte Carlo (HMC) sampler from DynamicHMC.jl to sample <code>Nsteps</code> independent draws from the posterior.</p><p>The primary method signature uses flattened formats for <code>models</code> and <code>data</code>. See the notes for the flattened call signature of <a href="../../internals/#StarFormationHistories.composite!"><code>StarFormationHistories.composite!</code></a> for more details, as well as <a href="../../fitting_intro/#StarFormationHistories.stack_models"><code>stack_models</code></a> that facilitates rearranging the <code>models</code> into this flattened format.</p><p><strong>Arguments</strong></p><ul><li><code>models, data, logAge, metallicities</code> are as in <a href="#StarFormationHistories.fit_sfh"><code>fit_sfh</code></a>.</li><li><code>Nsteps</code> is the number of Monte Carlo samples you want to draw.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ϵ</code> is the HMC step size. Convergence of the HMC samples is checked after sampling and if a convergence warning is issued, you should decrease this value.</li><li><code>reporter</code> is a valid reporter type from DynamicHMC.jl, either <code>NoProgressReport</code>, <code>ProgressMeterReport</code> for a basic progress meter, or <code>LogProgressReport</code> for more detailed reporting.</li><li><code>show_convergence</code> if <code>true</code>, will send sample convergence statistics to the default display.</li><li><code>rng</code> is a <code>Random.AbstractRNG</code> sampler instance that will be used when generating the random samples.</li></ul><p><strong>Returns</strong></p><p>A <code>NamedTuple</code> with two elements:</p><ul><li><code>posterior_matrix</code> is a <code>Matrix</code> with dimensions <code>(npar, Nsteps)</code> where <code>npar</code> is the number of fitting variables in the problem and is <code>npar = length(bfgs_result.mle.μ)</code>. Each column is one independent sample.</li><li><code>tree_statistics</code> contains convergence statistics that can be viewed with <code>DynamicHMC.Diagnostics.summarize_tree_statistics</code>.</li></ul><p><strong>See also</strong></p><ul><li>[<code>tsample_sfh</code>(@ref StarFormationHistories.tsample_sfh) for multi-threaded version.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/generic_fitting.jl#L387-L427">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StarFormationHistories.tsample_sfh"><a class="docstring-binding" href="#StarFormationHistories.tsample_sfh"><code>StarFormationHistories.tsample_sfh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tsample_sfh(bfgs_result::CompositeBFGSResult, 
            models::AbstractMatrix{&lt;:Number},
            data::AbstractVector{&lt;:Number},
            logAge::AbstractVector{&lt;:Number},
            metallicities::AbstractVector{&lt;:Number},
            Nsteps::Integer;
            ϵ::Real = 0.05, # HMC step size
            show_convergence::Bool=true,
            show_progress::Bool=true,
            rng::AbstractRNG=default_rng(),
            chain_length::Integer=100)
tsample_sfh(bfgs_result::CompositeBFGSResult, 
            models::AbstractVector{&lt;:AbstractMatrix{&lt;:Number}},
            data::AbstractMatrix{&lt;:Number},
            logAge::AbstractVector{&lt;:Number},
            metallicities::AbstractVector{&lt;:Number},
            Nsteps::Integer;
            kws...)</code></pre><p>Multi-threaded version of <a href="#StarFormationHistories.sample_sfh"><code>sample_sfh</code></a>; see that method&#39;s documentation for details.</p><p><strong>Implementation</strong></p><p>This method splits the requested number of samples <code>Nsamples</code> into a number of independent HMC chains, each of which has length <code>chain_length</code>. Initial positions for each chain are randomly drawn from the multivariate Gaussian approximation to the objective function stored in <code>bfgs_result</code>, approximating a warm start. Smaller values of <code>chain_length</code> achieve better load balancing while larger values of <code>chain_length</code> allow each chain more time to mix (see also <a href="https://arxiv.org/abs/1905.12247">Chen et al. 2020</a>). The default value of 100 results in good mixing with 24 fitting variables and a well-scaled step length ϵ – higher dimensional problems should increase <code>chain_length</code>. The downside to large <code>chain_length</code> is poor load balancing across available threads resulting in longer runtimes.</p><p><strong>Notes</strong></p><ul><li>if <code>show_progress</code> is <code>true</code>, we will show a progress bar that updates when individual chains complete. Currently this is not terribly useful unless the total number of chains is much greater than the number of available threads.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/generic_fitting.jl#L506-L533">source</a></section></details></article><p>The per-SSP stellar mass coefficients (<span>$r_{j,k}$</span> in the <a href="../MZR/MZR/#mzr_derivation">derivation</a>) can be derived from a metallicity model, a <a href="../dispersion_models/#dispersion_models">metallicity dispersion model</a>, the per-unique-log(age) stellar mass coefficients (<span>$R_j$</span> in the <a href="../MZR/MZR/#mzr_derivation">derivation</a>), and the set of SSP logarithmic ages <code>logAge = log10(age [yr])</code> and metallicites using <a href="#StarFormationHistories.calculate_coeffs"><code>calculate_coeffs</code></a>. Alternatively a <a href="#StarFormationHistories.CompositeBFGSResult"><code>CompositeBFGSResult</code></a> can be fed into this method and the first three arguments will be read from the result object.</p><article><details class="docstring" open="true"><summary id="StarFormationHistories.calculate_coeffs"><a class="docstring-binding" href="#StarFormationHistories.calculate_coeffs"><code>StarFormationHistories.calculate_coeffs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_coeffs(MH_model::AbstractMetallicityModel,
                 disp_model::AbstractDispersionModel,
                 mstars::AbstractVector{&lt;:Number}, 
                 logAge::AbstractVector{&lt;:Number},
                 metallicities::AbstractVector{&lt;:Number})</code></pre><p>Returns per-SSP stellar mass coefficients (<span>$r_{j,k}$</span> in the <a href="../MZR/MZR/#mzr_derivation">derivation</a>) using the provided metallicity model <code>MH_model</code> and metallicity dispersion model <code>disp_model</code> for the set of SSPs with logarithmic ages <code>logAge</code> and metallicities <code>metallicities</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_logage, n_mh = 10, 20; # Number of unique logAges, MHs

julia&gt; coeffs = calculate_coeffs(PowerLawMZR(1.0, -1.0),
                                 GaussianDispersion(0.2),
                                 rand(n_logage),
                                 repeat(range(7.0, 10.0; length=n_logage); inner=n_mh),
                                 repeat(range(-2.0, 0.0; length=n_mh); outer=n_logage));

julia&gt; coeffs isa Vector{Float64}
true

julia&gt; length(coeffs) == n_logage * n_mh
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/af2961800d425f1c53ff4c3b3eaa912726cad463/src/fitting/hierarchical/generic_fitting.jl#L3-L28">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../unconstrained/">« High-Level Methods for Unconstrained Fitting</a><a class="docs-footer-nextpage" href="../linear_amr/">Linear Age-Metallicity Relation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 27 November 2025 11:54">Thursday 27 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
