<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background and Template Construction · StarFormationHistories.jl</title><meta name="title" content="Background and Template Construction · StarFormationHistories.jl"/><meta property="og:title" content="Background and Template Construction · StarFormationHistories.jl"/><meta property="twitter:title" content="Background and Template Construction · StarFormationHistories.jl"/><meta name="description" content="Documentation for StarFormationHistories.jl."/><meta property="og:description" content="Documentation for StarFormationHistories.jl."/><meta property="twitter:description" content="Documentation for StarFormationHistories.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StarFormationHistories.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Deriving Star Formation Histories from Hess Diagrams</span><ul><li class="is-active"><a class="tocitem" href>Background and Template Construction</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#templates"><span>Constructing Templates</span></a></li><li><a class="tocitem" href="#A-Note-on-Array-Formatting"><span>A Note on Array Formatting</span></a></li><li><a class="tocitem" href="#A-Note-on-Threading"><span>A Note on Threading</span></a></li></ul></li><li><a class="tocitem" href="../unconstrained/">High-Level Methods for Unconstrained Fitting</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Metallicity Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../hierarchical/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-3-2" type="checkbox"/><label class="tocitem" for="menuitem-2-3-2"><span class="docs-label">AMRs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../hierarchical/linear_amr/">Linear Age-Metallicity Relation</a></li><li><a class="tocitem" href="../hierarchical/log_amr/">Logarithmic Age-Metallicity Relation</a></li><li><a class="tocitem" href="../hierarchical/fixed_amr/">Fixed Age-Metallicity Relations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3-3"><span class="docs-label">MZRs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../hierarchical/MZR/MZR/">Mass-Metallicity Relations (MZRs)</a></li></ul></li><li><a class="tocitem" href="../hierarchical/dispersion_models/">Metallicity Dispersion Models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../internals/">Low-Level Functions</a></li><li><a class="tocitem" href="../kernels/">Kernels</a></li></ul></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../simulate/">Simulating Color-Magnitude Diagrams</a></li><li><a class="tocitem" href="../../binaries/">Binary Systems</a></li><li><a class="tocitem" href="../../helpers/">Helper Functions</a></li><li><a class="tocitem" href="../../release-notes/">Changelog</a></li><li><a class="tocitem" href="../../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Deriving Star Formation Histories from Hess Diagrams</a></li><li class="is-active"><a href>Background and Template Construction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Background and Template Construction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cgarling/StarFormationHistories.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cgarling/StarFormationHistories.jl/blob/main/docs/src/fitting/fitting_intro.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="fitting"><a class="docs-heading-anchor" href="#fitting">Background and Template Construction</a><a id="fitting-1"></a><a class="docs-heading-anchor-permalink" href="#fitting" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>In the classic formulation of star formation history fitting from resolved-star photometry <a href="https://ui.adsabs.harvard.edu/abs/2002MNRAS.332...91D">(Dolphin 2002)</a>, an observed color-magnitude diagram (CMD) is binned into a 2-D histogram known as a Hess diagram. Such a CMD and Hess diagram pair is shown below.</p><p><img src="../figures/cmd_hess.png" alt="Comparison of CMD and a Hess diagram generated from the same observational data."/></p><p>The representation of the observations as a Hess diagram allows one to apply Poisson statistics, specifically the Poisson likelihood ratio (Equations 7–10 in Dolphin 2002), to model the observations. As the CMD of a complex stellar population is simply the sum of the CMDs of its sub-populations, one need only prepare a number of <strong>templates</strong> for each simple stellar population (SSP) which may make up the complex population in question and model the observed Hess diagram as a linear combination of these templates. Keeping the same notation as Dolphin 2002 (Equation 1), the complex model Hess diagram is simply</p><p class="math-container">\[m_i = \sum_j \, r_j \, c_{i,j}\]</p><p>where <span>$m_i$</span> is the value of the complex model in bin <span>$i$</span>, <span>$c_{i,j}$</span> is the value of simple template <span>$j$</span> in bin <span>$i$</span>, and <span>$r_j$</span> is the multiplicative coefficient determining how significant template <span>$j$</span> is to the complex population. In Dolphin 2002, he normalizes the templates to identical star formation rates (SFRs) and so the <span>$r_j$</span> are SFRs as well. In this package, we prefer to normalize our templates to identical population stellar masses, so our <span>$r_j$</span> are stellar masses, but the principal is the same.</p><p>Construction of the templates is, however, not a trivial exercise. Ideally, a template constructed to represent a particular SSP would accurately reflect the expectation of how such a population would be observed. Thus, these templates must be adjusted for photometric error, incompleteness, and other effects such as those caused by unresolved binary- and multi-star systems. Observational effects such as photometric error and incompleteness are best measured from artificial star tests (ASTs). It is worth mentioning that ASTs can often return &quot;best case&quot; results, as they typically neglect systematics like uncertainty in the point-spread model used for the photometry; as such it is sometimes necessary to add a systematic error floor to photometric error results from ASTs.</p><p>Such templates can be constructed by sampling many mock stars from an initial mass function (IMF), interpolating their absolute magnitudes from an isochrone of the relevant SSP, and &quot;mock observing&quot; them by applying photometric error and completeness functions (for example, by looking up the <span>$1\sigma$</span> photometric error and completeness value from a catalog of artificial stars). Such Monte Carlo templates can be slow to construct and exhibit Poisson shot-noise, requiring a statistical data–data comparison rather than a model–data comparison. Thus this method is non-optimal from both a practical and statistical perspective.</p><p>It is better to form what Dolphin 2002 calls a &quot;blurred isochrone;&quot; in this form of template, the SSP isochrone is first interpolated in initial stellar mass to improve the point density along the isochrone. The number of interpolated points is generally a function of the size of the bins in the Hess diagram and the observational error; more points are required as the bin size or photometric errors become smaller. These points are then weighted according to the IMF and the photometric completeness, and this weight is distributed into the Hess diagram following the photometric error distribution determined by similar artificial stars. Dolphin 2002 also mentions interpolating across stellar age/metallicity when constructing such templates; for example, for an SSP with an age of 1 Gyr and a metallicity of [M/H]=-1.0, you could interpolate the isochrones to introduce a Gaussian metallicity spread of 0.05 dex or an age spread of 100 Myr. The general effects of this form of interpolation is to broaden the model templates, particularly features that are very sharp in true SSP models. We neglect this form of interpolation in our implementation as it adds significant complexity and requires users to provide more information about the isochrones that are providing. Such widening of the individual templates is most impactful when photometric errors in the observational data are low (perhaps &lt;0.10 mag).</p><h2 id="templates"><a class="docs-heading-anchor" href="#templates">Constructing Templates</a><a id="templates-1"></a><a class="docs-heading-anchor-permalink" href="#templates" title="Permalink"></a></h2><p>While the above description summarizes the necessary components for constructing such a blurred isochrone, it can be a bit difficult to figure out how best to actually construct them. Specifically there are many ways that one could implement the observational effects of photometric error and incompleteness. We provide a method <a href="#StarFormationHistories.partial_cmd_smooth"><code>partial_cmd_smooth</code></a> to construct such templates under the assumption of Gaussian photometric error distributions, which is often a good approximation in the high-completeness regime. This method makes use of user-defined functions for the mean photometric error and completeness as a function of magnitude and filter, such that these can be defined in a number of ways; for example, as direct lookups from a large table of ASTs or as simple function evaluations of analytic approximations or fits to the ASTs.</p><p>This method begins by interpolating the provided SSP isochrone to increase point density. For every such point with <span>$i$</span> band apparent magnitude <span>$m_i$</span>, it calls a user-defined function to estimate the <span>$1\sigma$</span> photometric error as <span>$\sigma_i = f_i(m_i)$</span>. This is done for each provided photometric filter. These errors are used to define an asymmetric 2-D Gaussian kernel for each point in the interpolated isochrone. This kernel describes the probability distribution of where the isochrone point would be observed in the Hess diagram. The shape of the kernel is automatically adjusted to account for covariance when the magnitude on the y-axis of the Hess diagram also appears in the x-axis color, as occurs when only two filters of imaging are available (for example, an x-axis of <span>$B-V$</span> and a y-axis magnitude of <span>$V$</span>). Details on these kernels are given <a href="../kernels/#kernels">here</a>. However, the kernel also must be normalized (weighted) according to the IMF and observational completeness functions.</p><p>Assume that the vector of initial stellar masses for the points in the interpolated isochrone are <span>$m_i$</span> and that they are sorted such that <span>$m_i &lt; m_{i+1}$</span>. The IMF weight on point <span>$m_i$</span> can be approximated as the number fraction of stars born between <span>$m_i$</span> and <span>$m_{i+1}$</span> divided by the mean mass per star born <span>$\langle m \rangle$</span>, such that the weight effectively represents <strong>the number of stars expected to be born with masses between <span>$m_i$</span> and <span>$m_{i+1}$</span> per solar mass of star formation</strong>:</p><p class="math-container">\[\begin{aligned}
w_{i,\text{IMF}} &amp;= \frac{ \int_0^{m_{i+1}} \frac{dN(m)}{dm} dm - \int_0^{m_{i}} \frac{dN(m)}{dm} dm }{\int_0^\infty m \times \frac{dN(m)}{dm} dm} = \frac{ \int_{m_i}^{m_{i+1}} \frac{dN(m)}{dm} dm }{\langle m \rangle}
\end{aligned}\]</p><p>The numerator can either be calculated as the difference in the cumulative distribution function across the bin or approximated efficiently via the trapezoidal rule. The denominator is a function only of the IMF and need only be calculated once. Multiplying this weight by the probability of detection in the relevant bands gives the final weight.</p><p>A worked example comparing a sampled stellar population with a smooth Hess diagram template is available in <code>examples/templates/smooth_template.jl</code>. The smooth Hess diagram template is constructed with <a href="#StarFormationHistories.partial_cmd_smooth"><code>partial_cmd_smooth</code></a> and the Monte Carlo population is sampled with <a href="../../simulate/#StarFormationHistories.generate_stars_mass"><code>generate_stars_mass</code></a>, with observational effects modelled by <a href="../../simulate/#StarFormationHistories.model_cmd"><code>model_cmd</code></a>. The isochrone used comes from PARSEC and has an age of 12.6 Gyr and initial metallicity [M/H] of -2.8. The output figure is shown below. A distance modulus of 25 mag is used for this example, with photometric error and completeness functions roughly based on those we observe in the JWST/NIRCAM data of WLM (see <a href="https://ui.adsabs.harvard.edu/abs/2024ApJS..271...47W">Weisz et al. 2024</a>).</p><p><img src="../figures/template_compare.svg" alt="Comparison of CMD-sampled population with smooth Hess diagram template."/></p><p>At left is a population of stars sampled from an SSP with the methods described in the section of the documentation on <a href="../../simulate/#simulate">simulating CMDs</a>. The points from the isochrone are colored orange. The next figure shows the binned Hess diagram derived from these data. The next figure shows our smooth Hess diagram template calculated for this SSP. The final figure at right shows the residual between the data and model in units of standard deviations. These are sometimes called Pearson residuals. Below we show the distribution of these residuals, which should be Gaussian with mean 0 and standard deviation 1 if the model were perfect. Note that, because all bins with 0 observed stars are excluded from the distribution and the observed Hess diagram contains Poisson error, the mean of our distribution will always be slightly higher than 0. We do, however, achieve a standard deviation of nearly 1, indicating that our model is robust. We show a Gaussian PDF with standard deviation 1 and mean equal to the observed mean of the residuals for comparison.</p><p><img src="../figures/sigma_distribution.svg" alt="Distribution of data - model residuals, in units of standard deviations."/></p><p>The method used to create these smooth Hess diagram templates is <a href="#StarFormationHistories.partial_cmd_smooth"><code>partial_cmd_smooth</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.partial_cmd_smooth" href="#StarFormationHistories.partial_cmd_smooth"><code>StarFormationHistories.partial_cmd_smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">result::StatsBase.Histogram =
    partial_cmd_smooth(m_ini::AbstractVector{&lt;:Number},
                       mags::AbstractVector{&lt;:AbstractVector{&lt;:Number}},
                       mag_err_funcs,
                       y_index,
                       color_indices,
                       imf,
                       completeness_funcs=[one for i in mags],
                       bias_funcs=[zero for i in mags];
                       dmod::Number=0,
                       normalize_value::Number=1,
                       binary_model::AbstractBinaryModel=NoBinaries(),
                       mean_mass=mean(imf),
                       edges=nothing,
                       xlim=nothing,
                       ylim=nothing,
                       nbins=nothing,
                       xwidth=nothing,
                       ywidth=nothing)</code></pre><p>Main function for generating template Hess diagrams from a simple stellar population of stars from an isochrone, including photometric error and completeness.</p><p><strong>Arguments</strong></p><ul><li><code>m_ini::AbstractVector{&lt;:Number}</code> is a vector containing the initial stellar masses of the stars from the isochrone.</li><li><code>mags::AbstractVector{&lt;:AbstractVector{&lt;:Number}}</code> is a vector of vectors. Each constituent vector with index <code>i</code> should have <code>length(mags[i]) == length(m_ini)</code>, representing the magnitudes of the isochrone stars in each of the magnitudes considered. In most cases, mags should contain 2 (if y-axis mag is also involved in the x-axis color) or 3 vectors.</li><li><code>mag_err_funcs</code> must be an indexable object (e.g., a <code>Vector</code> or <code>Tuple</code>) that contains callables (e.g., a <code>Function</code>) to compute the 1σ photometric errors for the same filters provided in <code>mags</code>. Each callable must take a single argument (an <em>apparent</em> magnitude) and return a <code>Number</code>. The length <code>mag_err_funcs</code> must be equal to the length of <code>mags</code>.</li><li><code>y_index</code> gives a valid index (e.g., an <code>Int</code> or <code>CartesianIndex</code>) into <code>mags</code> for the filter you want to have on the y-axis of the Hess diagram. For example, if the <code>mags</code> argument contains the B and V band magnitudes as <code>mags=[B, V]</code> and you want V on the y-axis, you would set <code>y_index</code> as <code>2</code>. </li><li><code>color_indices</code> is a length-2 indexable object giving the indices into <code>mags</code> that are to be used to compute the x-axis color. For example, if the <code>mags</code> argument contains the B and V band magnitudes as <code>mags=[B, V]</code>, and you want B-V to be the x-axis color, then <code>color_indices</code> should be <code>[1,2]</code> or <code>(1,2)</code> or similar.</li><li><code>imf</code> is a callable that takes an initial stellar mass as its sole argument and returns the (properly normalized) probability density of your initial mass function model. All the models from <a href="https://github.com/cgarling/InitialMassFunctions.jl">InitialMassFunctions.jl</a> are valid for <code>imf</code>.</li><li><code>completeness_funcs</code> must be an indexable object (e.g., a <code>Vector</code> or <code>Tuple</code>) that contains callables (e.g., a <code>Function</code>) that return the single-filter completeness fractions as a function of <em>apparent</em> magnitude. Each callable in this argument must correspond to the matching filter provided in <code>mags</code>.</li><li><code>bias_funcs</code> must be an indexable object (e.g., a <code>Vector</code> or <code>Tuple</code>) that contains callables (e.g., a <code>Function</code>) that return the expected photometric bias as a function of <em>apparent</em> magnitude. The photometric bias is defined as the difference between measured and intrinsic magnitude (i.e., <code>output - input</code> for artificial star tests). Each callable in this argument must correspond to the matching filter provided in <code>mags</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dmod::Number=0</code> is the distance modulus in magnitudes to apply to the input <code>mags</code>. Leave at <code>0</code> if you are providing apparent magnitudes in <code>mags</code>.</li><li><code>normalize_value::Number=1</code> is the total stellar mass of the population you wish to model.</li><li><code>binary_model::AbstractBinaryModel=NoBinaries()</code> is the model to use for including binary systems. Currently only <a href="../../binaries/#StarFormationHistories.NoBinaries"><code>StarFormationHistories.NoBinaries</code></a> and <a href="../../binaries/#StarFormationHistories.RandomBinaryPairs"><code>StarFormationHistories.RandomBinaryPairs</code></a> are supported.</li><li><code>mean_mass::Number</code> is the expectation value of the initial mass for a random star drawn from your provided <code>imf</code>. This will be computed for you if your provided <code>imf</code> is a valid continuous, univariate <code>Distributions.Distribution</code> object.</li><li><code>edges</code> is a tuple of ranges defining the left-side edges of the bins along the x-axis (<code>edges[1]</code>) and the y-axis (<code>edges[2]</code>). Example: <code>(-1.0:0.1:1.5, 22:0.1:27.2)</code>. If <code>edges</code> is provided, it overrides the following keyword arguments that offer other ways to specify the extent of the Hess diagram.</li><li><code>xlim</code> is a length-2 indexable object (e.g., a <code>Vector</code> or <code>Tuple</code>) giving the lower and upper bounds on the x-axis corresponding to the provided <code>colors</code> array. Example: <code>(-1.0, 1.5)</code>. This is only used if <code>edges</code> is not provided. </li><li><code>ylim</code> is as <code>xlim</code> but for the y-axis corresponding to the provided <code>mags</code> array. Example <code>(25.0, 20.0)</code>. This is only used if <code>edges</code> is not provided.</li><li><code>nbins::NTuple{2, &lt;:Integer}</code> is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if <code>edges</code> is not provided.</li><li><code>xwidth</code> is the bin width along the x-axis for the <code>colors</code> array. This is only used if <code>edges</code> and <code>nbins</code> are not provided. Example: <code>0.1</code>.</li><li><code>ywidth</code> is as <code>xwidth</code> but for the y-axis corresponding to the provided <code>mags</code> array. Example: <code>0.1</code>.</li></ul><p><strong>Returns</strong></p><p>This method returns the Hess diagram as a <code>StatsBase.Histogram</code>; you should refer to the StatsBase documentation for more information. In short, if the output of this method is <code>result</code>, then the Hess diagram represented as a <code>Matrix</code> is available as <code>result.weights</code> (this is what you would want for <a href="../unconstrained/#StarFormationHistories.fit_templates"><code>fit_templates</code></a> and similar functions) and the edges of the histogram are available as <code>result.edges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/32e20eb0bf9aa8ab41da1f3fbb76a98bb08fd9f8/src/StarFormationHistories.jl#L780-L827">source</a></section></article><p>The user-provided functions returning magnitude errors (<code>mag_err_funcs</code>) and completeness values (<code>completness_functions</code>) given a star&#39;s intrinsic apparent magnitude are important for deriving good templates. These are typically derived from catalogs of artificial star tests. Some helper functions for constructing these are provided <a href="../../helpers/#phot_helpers">here</a>.</p><p>We note that in many cases it can also be helpful to add in a foreground/background template that models contamination of the Hess diagram from stars not in your population of interest – this is often done using observations of parallel fields though there are several other possible methods.</p><p>Photometric catalogs can be processed into Hess diagrams meeting our formatting requirements with the method <a href="#StarFormationHistories.bin_cmd"><code>bin_cmd</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.bin_cmd" href="#StarFormationHistories.bin_cmd"><code>StarFormationHistories.bin_cmd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">result::StatsBase.Histogram =
   bin_cmd(colors::AbstractVector{&lt;:Number},
           mags::AbstractVector{&lt;:Number};
           weights::AbstractVector{&lt;:Number} = ones(promote_type(eltype(colors),
                                                    eltype(mags)), size(colors)),
           edges  = nothing,
           xlim   = extrema(colors),
           ylim   = extrema(mags),
           nbins  = nothing,
           xwidth = nothing,
           ywidth = nothing)</code></pre><p>Returns a <code>StatsBase.Histogram</code> type containing the Hess diagram from the provided x-axis photometric <code>colors</code> and y-axis photometric magnitudes <code>mags</code>. These must all be vectors equal in length. You can either specify the bin edges directly via the <code>edges</code> keyword (e.g., <code>edges = (range(-0.5, 1.6, length=100), range(17.0, 26.0, length=100))</code>), or you can set the x- and y-limits via <code>xlim</code> and <code>ylim</code> and the number of bins as <code>nbins</code>, or you can omit <code>nbins</code> and instead pass the bin width in the x and y directions, <code>xwidth</code> and <code>ywidth</code>. See below for more info on the keyword arguments. To plot this with <code>PyPlot.jl</code> you should do <code>PyPlot.imshow(permutedims(result.weights), origin=&quot;lower&quot;, extent=(extrema(result.edges[1])..., extrema(result.edges[2]), kws...)</code> where <code>kws...</code> are any other keyword arguments you wish to pass to <code>PyPlot.imshow</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>weights::AbstractVector{&lt;:Number}</code> is a array of length equal to <code>colors</code> and <code>mags</code> that contains the probabilistic weights associated with each point. This is passed to <code>StatsBase.fit</code> as <code>StatsBase.Weights(weights)</code>. The following keyword arguments are passed to <a href="../internals/#StarFormationHistories.calculate_edges"><code>StarFormationHistories.calculate_edges</code></a> to determine the bin edges of the histogram.</li><li><code>edges</code> is a tuple of ranges defining the left-side edges of the bins along the x-axis (edges[1]) and the y-axis (edges[2]). Example: <code>(-1.0:0.1:1.5, 22:0.1:27.2)</code>. If <code>edges</code> is provided, <code>weights</code> is the only other keyword that will be read; <code>edges</code> supercedes the other construction methods. </li><li><code>xlim</code> is a length-2 indexable object (e.g., a vector or tuple) giving the lower and upper bounds on the x-axis corresponding to the provided <code>colors</code> array. Example: <code>[-1.0, 1.5]</code>. This is only used if <code>edges</code> is not provided. </li><li><code>ylim</code> is like <code>xlim</code> but  for the y-axis corresponding to the provided <code>mags</code> array. Example <code>[25.0, 20.0]</code>. This is only used if <code>edges</code> is not provided.</li><li><code>nbins::NTuple{2, &lt;:Integer}</code> is a 2-tuple of integers providing the number of bins to use along the x- and y-axes. This is only used if <code>edges</code> is not provided.</li><li><code>xwidth</code> is the bin width along the x-axis for the <code>colors</code> array. This is only used if <code>edges</code> and <code>nbins</code> are not provided. Example: <code>0.1</code>. </li><li><code>ywidth</code> is like <code>xwidth</code> but for the y-axis corresponding to the provided <code>mags</code> array. Example: <code>0.1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/32e20eb0bf9aa8ab41da1f3fbb76a98bb08fd9f8/src/StarFormationHistories.jl#L519-L542">source</a></section></article><h2 id="A-Note-on-Array-Formatting"><a class="docs-heading-anchor" href="#A-Note-on-Array-Formatting">A Note on Array Formatting</a><a id="A-Note-on-Array-Formatting-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-on-Array-Formatting" title="Permalink"></a></h2><p>It is expected that the user will typically have model templates stored as two-dimensional matrices as these are the obvious choice for representing a binned two-dimensional histogram. We fully support supplying the list of model templates as a list of matrices (e.g., a <code>Vector{Matrix{&lt;:Number}}</code>) to the fitting functions discussed below. The important computational kernels <a href="../internals/#StarFormationHistories.composite!"><code>composite!</code></a> and <a href="../internals/#StarFormationHistories.∇loglikelihood!"><code>∇loglikelihood!</code></a> have custom loops for these input types.</p><p>However, additional optimizations are possible by flattening the data. By flattening each matrix in the list of model templates into a column vector and concatenating them such that the list of model templates becomes a single matrix, we can compute the complex model Hess diagram as a single matrix-vector product rather than using a custom loop. The same optimization can be made when computing the gradient of the loglikelihood (discussed more below). The majority of all computation for the fitting methods below is spent in these two functions, so optimizing their performance translates directly to improved fitting runtimes. With this flattened memory arrangement we can use the highly optimized <code>LinearAlgbera.mul!</code> method to do the in-place matrix-vector product. This will typically be translated into a call to a BLAS function like <code>gemv!</code>. As such, we can benefit from Julia&#39;s ability to switch BLAS implementations at runtime to use Intel&#39;s <a href="https://github.com/JuliaLinearAlgebra/MKL.jl">Math Kernel Library</a>, Apple&#39;s <a href="https://github.com/JuliaLinearAlgebra/AppleAccelerate.jl">Accelerate</a>, and <a href="https://github.com/JuliaLinearAlgebra/libblastrampoline">others</a>.</p><p>Most of the fitting methods below support both the natural and flattened data layouts. We provide the <a href="#StarFormationHistories.stack_models"><code>stack_models</code></a> method to produce the optimized layout for the list of model templates.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StarFormationHistories.stack_models" href="#StarFormationHistories.stack_models"><code>StarFormationHistories.stack_models</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stack_models(models::AbstractVector{&lt;:AbstractMatrix{&lt;:Number}})</code></pre><p>Transforms a vector of matrices into a single matrix, with each matrix from <code>models</code> being transcribed into a single column in the output matrix. This data layout enables more efficient calculations in some of our internal functions like <a href="../internals/#StarFormationHistories.composite!"><code>composite!</code></a> and <a href="../internals/#StarFormationHistories.∇loglikelihood!"><code>∇loglikelihood!</code></a>. This function is just <code>reduce(hcat, map(vec, models))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; stack_models([rand(5,5) for i in 1:10])
25×10 Matrix{Float64}:
...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgarling/StarFormationHistories.jl/blob/32e20eb0bf9aa8ab41da1f3fbb76a98bb08fd9f8/src/fitting/utilities.jl#L1-L12">source</a></section></article><h2 id="A-Note-on-Threading"><a class="docs-heading-anchor" href="#A-Note-on-Threading">A Note on Threading</a><a id="A-Note-on-Threading-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-on-Threading" title="Permalink"></a></h2><p>While generally the methods using BLAS routines offer significant performance improvements, there is a caveat when multithreading from within Julia. By default Julia will allow BLAS to use multiple threads even if Julia itself is started with a single thread (i.e., by running <code>julia -t 1</code>). BLAS threads do not compose with Julia threads. That is, if you start Julia with <code>N&gt;1</code> threads (<code>julia -t N</code>) and write a threaded workload where each Julia thread is doing BLAS operations concurrently, you can easily oversubscribe the CPU. Specific recommendations vary depending on BLAS vendor (see <a href="https://carstenbauer.github.io/ThreadPinning.jl/dev/examples/ex_blas/">this page</a> and the linked discourse threads), but generally this package is in the regime of doing many small calculations that do not individually benefit much from BLAS threading (e.g., performance for OpenBLAS with 8 threads is only ~2x the 1 thread performance). As such it is often sufficient to set BLAS to use a single thread (via <code>LinearAlgbera.BLAS.set_num_threads(1)</code> or environment variables; see above link).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Overview</a><a class="docs-footer-nextpage" href="../unconstrained/">High-Level Methods for Unconstrained Fitting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 8 July 2025 18:42">Tuesday 8 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
